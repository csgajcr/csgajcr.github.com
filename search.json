[{"title":"Hexo - 10分钟0成本搭建博客系统","url":"/2020/04/07/Hexo10%E5%88%86%E9%92%9F0%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>10分钟、0成本这两个词毫不夸张。对于许多想写博客的小伙伴来说。在哪里写博客一直是一个难题，有的人选择CSDN，有的人选择知乎、有的人选择简书，还有的人选择自己搭建博客系统。</p>\n<blockquote>\n<p>PS：作为一名程序员，当然要用个性化的博客系统才有意思嘛。</p>\n</blockquote>\n<p>所以对比了许多博客系统之后我选择了 Hexo.</p>\n<span id=\"more\"></span>\n<blockquote>\n<p>想直接看怎么搭建的小伙伴，请跳至「二、开始！」阅读。</p>\n</blockquote>\n<h2 id=\"一、为什么选择-Hexo\"><a href=\"#一、为什么选择-Hexo\" class=\"headerlink\" title=\"一、为什么选择 Hexo\"></a>一、为什么选择 Hexo</h2><h3 id=\"1-1-Hexo-的优势\"><a href=\"#1-1-Hexo-的优势\" class=\"headerlink\" title=\"1.1 Hexo 的优势\"></a>1.1 Hexo 的优势</h3><p>Hexo 官网对 Hexo 的一句话概括为：</p>\n<blockquote>\n<p>A fast, simple &amp; powerful blog framework</p>\n</blockquote>\n<p>这句话概括了 Hexo 的优点：</p>\n<ul>\n<li>快速搭建</li>\n<li>简洁、方便</li>\n<li>功能强大</li>\n</ul>\n<p>在我个人使用 Hexo 的过程中，能够感觉到 Hexo 特别适合个人博客的编写。特别针对是程序员群体，使用 Markdown 标记语言，让写作者无需太关心排版和格式。如果配上 Git 版本管理和 GitHub Pages 的发布。那更是无需充钱，也能更强！</p>\n<h3 id=\"1-2-对比-WordPress\"><a href=\"#1-2-对比-WordPress\" class=\"headerlink\" title=\"1.2 对比 WordPress\"></a>1.2 对比 WordPress</h3><p>拿我自己的真实使用经历来说，在使用 Hexo 之前，很长时间我一直使用的 WordPress。WordPress就像博客界的老大哥，生态强大，系统强大，支持的东西很多。但正因为这样，使得 WordPress 变得重了起来。在使用时部署成本和管理成本较高。这里我自己总结了一下对比的表格： </p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>WordPress</th>\n<th>Hexo</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>部署成本</td>\n<td>高</td>\n<td>极低</td>\n</tr>\n<tr>\n<td>使用成本</td>\n<td>低</td>\n<td>中</td>\n</tr>\n<tr>\n<td>费用</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>中</td>\n<td>高</td>\n</tr>\n<tr>\n<td>管理成本</td>\n<td>高</td>\n<td>低</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注：这里没有列出具体的对比项，仅是综合成了一个项目方便对比。比如 WordPress 部署成本包括：服务器、域名（备案）、数据库、PHP环境、性能要求等。</p>\n</blockquote>\n<p>总结一下，在个人博客的场景：  </p>\n<ul>\n<li>如果没有一点儿程序基础。建议使用 WordPress.</li>\n<li>如果有程序基础，建议使用 Hexo.</li>\n</ul>\n<h3 id=\"1-3-对比其他博客系统\"><a href=\"#1-3-对比其他博客系统\" class=\"headerlink\" title=\"1.3 对比其他博客系统\"></a>1.3 对比其他博客系统</h3><p>其他的博客系统因为没有使用过，所以不敢妄言。在非静态博客上，WordPress 可以作为代表进行对比（参考上方）。静态博客上，Jekyll 给我个人的感觉各方面都不如 Hexo。</p>\n<h2 id=\"二、开始！\"><a href=\"#二、开始！\" class=\"headerlink\" title=\"二、开始！\"></a>二、开始！</h2><p>终于开始了~这里可以恰个表，看一下你的操作步骤加起来使用了多久？</p>\n<h3 id=\"2-1-准备工作\"><a href=\"#2-1-准备工作\" class=\"headerlink\" title=\"2.1 准备工作\"></a>2.1 准备工作</h3><p>以下软件是需要准备的：</p>\n<ul>\n<li>nodejs/npm - <a href=\"https://nodejs.org/en/\">官网地址</a></li>\n<li>Git </li>\n</ul>\n<p>如果不知道如何安装/使用请百度。<br>Windows 系统的控制台可以使用 GitBash.</p>\n<h3 id=\"2-2-安装-Hexo\"><a href=\"#2-2-安装-Hexo\" class=\"headerlink\" title=\"2.2 安装 Hexo\"></a>2.2 安装 Hexo</h3><ol>\n<li>打开 <code>控制台</code> </li>\n<li>输入 <code>npm install hexo-cli -g</code></li>\n</ol>\n<p>输入后效果如下：<br><img src=\"/img/hexo/1586677596533.jpg\"></p>\n<ol start=\"3\">\n<li><p>CD 到你的博客目录。比如我要在桌面创建一个目录，则 CD 到桌面。  </p>\n</li>\n<li><p>输入 <code>hexo init my_blog</code></p>\n</li>\n</ol>\n<p>这一步可能比较耗时，因为是从网上下载最新的 hexo 博客项目到本地。<br>执行效果如下：<br><img src=\"/img/hexo/WX20200412-165150@2x.png\"></p>\n<ol start=\"5\">\n<li>输入 <code>cd my_blog</code></li>\n<li>输入 <code>npm install</code></li>\n<li>输入 <code>hexo server</code></li>\n</ol>\n<p>执行结果如下：<br><img src=\"/img/hexo/WX20200412-165732@2x.png\"></p>\n<p>打开浏览器 访问 <a href=\"http://localhost:4000/\">http://localhost:4000/</a> 即可看到博客的样子了。<br><img src=\"/img/hexo/1586681972615.jpg\"></p>\n<p>到这里，一个基础的博客系统就搭建完成了。这里使用的是默认主题 landscape.如果你觉得这个主题还 OK 的话，就可以开始你的写作啦。</p>\n<hr>\n<p>这里简单介绍一下博客目录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── _config.yml 博客配置文件</span><br><span class=\"line\">├── db.json</span><br><span class=\"line\">├── node_modules </span><br><span class=\"line\">├── package-lock.json</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds 模板</span><br><span class=\"line\">│   ├── draft.md 新草稿的模板</span><br><span class=\"line\">│   ├── page.md 新页面的模板</span><br><span class=\"line\">│   └── post.md 新文章的模板</span><br><span class=\"line\">├── source </span><br><span class=\"line\">│   └── _posts 文章目录</span><br><span class=\"line\">│       └── hello-world.md 自动生成的文章，可删除.</span><br><span class=\"line\">└── themes 主题目录</span><br><span class=\"line\">    └── landscape 默认主题（landscape）</span><br><span class=\"line\">            ├── _config.yml 主题的配置文件</span><br></pre></td></tr></table></figure>\n\n<p>在 Hexo 中，任何的页面、文章，我们都可以用 Markdown 文件来书写。所以在上图中，文章和页面的模板都是<code>.md</code>文件，创建时，都会以模板文件的格式创建。</p>\n<h3 id=\"2-3-写博客\"><a href=\"#2-3-写博客\" class=\"headerlink\" title=\"2.3 写博客\"></a>2.3 写博客</h3><ol>\n<li>输入 <code>hexo n &quot;第一篇博客&quot;</code></li>\n</ol>\n<p>输入后会在 <code>source/_posts</code> 目录下创建一篇新的<code>第一篇博客.md</code>文件。编辑它就可以开始写作啦。</p>\n<p>生成的文件格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 第一篇博客</span><br><span class=\"line\">date: 2020-04-12 17:16:10</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>我们可以为这篇文章添加分类和标签，格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 第一篇博客</span><br><span class=\"line\">date: 2020-04-12 17:16:10</span><br><span class=\"line\">tags: [标签1,标签2]</span><br><span class=\"line\">categories: 分类名</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>在<code>---</code>之后的就是文章的正文了。文章的内容就写在这里。</p>\n<blockquote>\n<p>关于写作相关的指令，深入的使用方式请参考官方文档链接，在「四、参考资料」中。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>关于编辑器的选型：  </p>\n<ol>\n<li>Visual Studio Code (推荐) 清爽的写作环境，安装 Markdown 插件后支持可视化编辑。</li>\n<li>IDEA/WebStorm/…  习惯使用 <code>jetbrains</code> 系列软件的可以使用。同样需要安装 Markdown 插件后支持可视化编辑。</li>\n<li>Sublime Text   </li>\n</ol>\n</blockquote>\n<p>编辑器选型可以看自己的爱好。用任何文本编辑器都可以。Hexo 也提供可视化博客管理插件。详情可查看：<a href=\"https://github.com/jaredly/hexo-admin\">https://github.com/jaredly/hexo-admin</a></p>\n<h3 id=\"2-4-发布到-Github-Pages\"><a href=\"#2-4-发布到-Github-Pages\" class=\"headerlink\" title=\"2.4 发布到 Github Pages\"></a>2.4 发布到 Github Pages</h3><p>Github Pages 是一个由 Github 提供给开源项目的免费静态网页部署服务。只需要你将静态网页文件提交到仓库，按照格式配置，即可使用。<br>成功部署后的域名为 <code>***.github.io</code> 参考：<a href=\"https://csgajcr.github.io/\">https://csgajcr.github.io/</a><br>操作步骤如下：  </p>\n<ol>\n<li>拥有一个 Github 账号</li>\n<li>新建一个仓库，仓库名字为 [你的账号名].github.io  </li>\n</ol>\n<p>比如我的账号名叫 csgajcr 那么我的仓库名称就需要叫 <code>csgajcr.github.io</code></p>\n<ol start=\"3\">\n<li>安装 Hexo git 部署插件 </li>\n</ol>\n<p>控制台执行命令 <code>npm install hexo-deployer-git --save</code>  </p>\n<blockquote>\n<p>注：在 Hexo 中，部署可以直接使用插件来部署，很方便。除了 git 之外也支持其他多种部署方式。请参考：<a href=\"https://hexo.io/docs/one-command-deployment\">https://hexo.io/docs/one-command-deployment</a></p>\n</blockquote>\n<ol start=\"4\">\n<li>配置博客配置文件</li>\n</ol>\n<p>打开 <code>_config.yml</code>.<br>将文件最后面 <code>deploy</code> 的配置修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">- type: git</span><br><span class=\"line\">  repository: git@github.com:csgajcr/csgajcr.github.io.git #</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>发布</li>\n</ol>\n<p>控制台执行命令 <code>hexo clean &amp;&amp; hexo d -g</code><br>发布成功后，就可以在你的 git 仓库下看到生成的静态文件啦。<br>此时访问 [你的账号名].github.io 即可查看你的博客了。</p>\n<blockquote>\n<p>如果 Github Pages 未生效，到仓库设置中查看 Github Pages 选项是否正常。<br>正常的截图如下：<br><img src=\"/img/hexo/1586684326821.jpg\"></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>注：这里多说一句，部署的原理是将 <code>hexo clean &amp;&amp; hexo d -g</code> 命令生成的文件提交到 <code>Github</code> 仓库（生成的文件在 <code>public</code> 目录下）。所以在排查一些问题的时候，可以查看生成的 <code>public</code> 文件夹下的网页文件是否正常。</p>\n</blockquote>\n<h2 id=\"三、常用功能\"><a href=\"#三、常用功能\" class=\"headerlink\" title=\"三、常用功能\"></a>三、常用功能</h2><h3 id=\"3-1-更换主题\"><a href=\"#3-1-更换主题\" class=\"headerlink\" title=\"3.1 更换主题\"></a>3.1 更换主题</h3><p>如果你是一个专注写作，不在意博客主题的人，那么也许这里你可以选择跳过。默认的 <code>landscape</code> 主题美观度和支持度上都算不错。<br>如果你是一个有个性的人，那么你可以花几个小时的时间来选择和配置一款你自己喜欢的主题。<br>如果你是一个喜欢折腾的人，那么你可以花几天的时间，来定制化你的主题，并为你的主题增添很多独有的色彩。  </p>\n<hr>\n<p>主题的文件在 <code>themes</code> 目录下：<br>在一个初始的项目下，里面会自带一个 <code>landscape</code> 的文件夹，这便是主题的文件了。<br>那么如何更换主题呢？</p>\n<ol>\n<li>选择一款你中意的主题，在这里选择。 <a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a> </li>\n<li>这里我们随便拿一个举例，比如 <code>A-Ayer</code><img width=\"240px\" src=\"/img/hexo/1587219784808.jpg\"/>\n这里点进去，就是预览主题。在预览主题的最下方，会有主题的 `Github` 链接。\n<img width=\"240px\" src=\"/img/hexo/1587220246946.jpg\"/></li>\n</ol>\n<blockquote>\n<p>当然这是先预览再看主题安装的方式，如果你不想预览，你也可以直接在 <code>Github</code> 上搜索你想使用的主题。</p>\n</blockquote>\n<p>一般来说在主题的 Github 仓库的 README 文件中有相应主题的配置教程。例如 <code>A-Ayer</code> 的主题配置教程如下：</p>\n<img width=\"240px\" src=\"/img/hexo/1587222831141.jpg\"/>\n<br/>\n\n<blockquote>\n<p><strong>每种不同的主题，安装方式都大致相同，参数配置可能会有所区别。这里就是大家主要花时间需要去折腾的地方了。</strong></p>\n</blockquote>\n<h3 id=\"3-2-配置文件解析\"><a href=\"#3-2-配置文件解析\" class=\"headerlink\" title=\"3.2 配置文件解析\"></a>3.2 配置文件解析</h3><p>详细全面的项目配置文件解析请参考 「四、参考资料」 中 Hexo 博客配置文件详解. <a href=\"https://hexo.io/zh-cn/docs/configuration.html\">https://hexo.io/zh-cn/docs/configuration.html</a><br>博客的整体配置文件路径(<code>source/_config.yaml</code>)，下面介绍的栏目都在此配置文件中修改。</p>\n<ol>\n<li><p>网站标题 - title<br>顾名思义，修改后会影响博客的标题。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: Jcr&#x27;s Blog</span><br></pre></td></tr></table></figure></li>\n<li><p>网站描述 - description<br>修改后会影响博客的描述信息。例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">description: &#x27;Jcr - An Android developer &#x27;</span><br></pre></td></tr></table></figure></li>\n<li><p>网站部署链接 - url<br>部署链接会影响项目资源的生成，请设置自己实际的部署域名。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: http://blog.jcr.pub</span><br><span class=\"line\">root: /</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中 root 为博客所部署的 <code>path</code> 信息，如果设置不对，可能会导致网页的部分资源访问不到。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"3-3-添加页面\"><a href=\"#3-3-添加页面\" class=\"headerlink\" title=\"3.3 添加页面\"></a>3.3 添加页面</h3><p>在 <code>Hexo</code> 中，页面也是一个 <code>markdown</code> 文件。我们新建页面和新建文章有一点点区别。<br>新建页面的命令为：<code>hexo new page [页面名称]</code>。以新建关于页面的操作步骤举例：</p>\n<ol>\n<li>执行 <code>hexo new page about</code></li>\n</ol>\n<p>执行成功后控制台会提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">INFO  Created: ~/Desktop/my_blog/source/about/index.md</span><br></pre></td></tr></table></figure>\n<p>一般的主题都会附带关于页面的配置（即为主题配置文件中包含<code>  about: /about/</code>），所以关于页面的新建就完成啦。</p>\n<h3 id=\"3-4-分类、标签和模板\"><a href=\"#3-4-分类、标签和模板\" class=\"headerlink\" title=\"3.4 分类、标签和模板\"></a>3.4 分类、标签和模板</h3><p>我们挨个介绍吧。</p>\n<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4><p>模板是指的我们新建文章或页面后，自动生成的 <code>MD</code> 文件里的内容。比如你的博客开头都是以某种格式的，就可以去模板里修改，修改后生成的新文章都会根据模板来创建。</p>\n<h4 id=\"分类、标签\"><a href=\"#分类、标签\" class=\"headerlink\" title=\"分类、标签\"></a>分类、标签</h4><p>文章的分类标签是在文章的信息定义处指定，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: Typescript学习记录</span><br><span class=\"line\">date: 2020-04-13 19:46:25</span><br><span class=\"line\">categories: javascript</span><br><span class=\"line\">tags: [javascript,前端,Web,typescript]</span><br></pre></td></tr></table></figure>\n<p>分类只能指定一个，标签可以多个。通过这种方式设置的标签和分类将会在博客的<code>标签</code>页和<code>分类</code>页中自动生成。   </p>\n<p>分类、标签的另一种配置方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: Hexo - 10分钟0成本搭建博客系统</span><br><span class=\"line\">categories:</span><br><span class=\"line\">  - 博客</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - 博客</span><br><span class=\"line\">  - Hexo</span><br><span class=\"line\">  - 教程</span><br><span class=\"line\">date: 2020-04-07 17:00:00</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-5-其他\"><a href=\"#3-5-其他\" class=\"headerlink\" title=\"3.5 其他\"></a>3.5 其他</h3><h4 id=\"发布注意事项\"><a href=\"#发布注意事项\" class=\"headerlink\" title=\"发布注意事项\"></a>发布注意事项</h4><p>每次发布之前，必须要执行 <code>hexo clean</code> ，否则将会导致一些奇怪的问题发生。如果你觉得每次发布都要执行两条命令很麻烦，可以整合一下。<br>修改 <code>package.json</code> 文件，在 <code>script</code> 一栏中，增加 <code>release</code> 这条指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class=\"line\">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class=\"line\">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class=\"line\">    &quot;server&quot;: &quot;hexo server&quot;,</span><br><span class=\"line\">    &quot;release&quot;: &quot;hexo clean &amp;&amp; hexo d -g&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>之后再执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run release</span><br></pre></td></tr></table></figure>\n<p>即可完成发布</p>\n<h2 id=\"四、参考资料\"><a href=\"#四、参考资料\" class=\"headerlink\" title=\"四、参考资料\"></a>四、参考资料</h2><ol>\n<li>Hexo 主题列表</li>\n</ol>\n<p><a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a></p>\n<ol start=\"2\">\n<li>Hexo 插件列表</li>\n</ol>\n<p><a href=\"https://hexo.io/plugins/\">https://hexo.io/plugins/</a></p>\n<ol start=\"3\">\n<li>Hexo 博客配置文件详解</li>\n</ol>\n<p><a href=\"https://hexo.io/zh-cn/docs/configuration.html\">https://hexo.io/zh-cn/docs/configuration.html</a></p>\n<ol start=\"4\">\n<li>Hexo 命令大全</li>\n</ol>\n<p><a href=\"https://hexo.io/zh-cn/docs/commands\">https://hexo.io/zh-cn/docs/commands</a></p>\n<ol start=\"5\">\n<li>Hexo 模板的使用</li>\n</ol>\n<p><a href=\"https://hexo.io/zh-cn/docs/templates\">https://hexo.io/zh-cn/docs/templates</a></p>\n<ol start=\"6\">\n<li>Hexo 写作</li>\n</ol>\n<p><a href=\"https://hexo.io/zh-cn/docs/writing\">https://hexo.io/zh-cn/docs/writing</a></p>\n","categories":["博客"],"tags":["博客","Hexo","教程"]},{"title":"Kotlin反射遇到的细节问题记录","url":"/2020/04/18/Kotlin%E5%8F%8D%E5%B0%84%E9%81%87%E5%88%B0%E7%9A%84%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在做公司的项目的时候，经常会用到Kotlin和Java混合开发。官方对于Kotlin的介绍上，说的是可以和Java互相调用完美兼容。但在实际使用的时候，还是有一些瑕疵在里面，这篇文章主要是记录遇到的一些问题以及如何处理。</p>\n<span id=\"more\"></span>\n<h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><p>我想要达到的效果输入一段JSON，里面包含着方法名和每个参数的信息。然后根据反射的方式调用到具体的接口实现上。（有点类似远程调用的协议）<br>类似这样一段JSON：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;methodName&quot;,</span><br><span class=\"line\">\t&quot;args&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;name&quot;:&quot;jcr&quot;,</span><br><span class=\"line\">\t\t&quot;age&quot;:24</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args为方法的参数列表，以KV的形式记录，</span><br></pre></td></tr></table></figure>\n<p>方法的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun testMethod(</span><br><span class=\"line\">    @Param(&quot;age&quot;) age: Int,</span><br><span class=\"line\">    @Param(&quot;name&quot;) name: String</span><br><span class=\"line\">): String</span><br></pre></td></tr></table></figure>\n<p>前面JSON的解析的操作较为简单就不说了。我们要完成这个功能，映射方法名也是通过注解来的，这里就不做过多赘述了。我们直接来说说如何映射到参数上吧，<br>在上方定义了testMethod这么一个方法，我们需要通过反射来获取@Param注解中的值。<br>首先来看@Param注解的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface Param &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 参数名称</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java反射注解的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static String[] getMethodParamsName(Method method) &#123;</span><br><span class=\"line\">        String[] names = new String[method.getParameterAnnotations().length];</span><br><span class=\"line\">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class=\"line\">        for (int i = 0; i &lt; parameterAnnotations.length; i++) &#123;</span><br><span class=\"line\">            Annotation[] parameterAnnotation = parameterAnnotations[i];</span><br><span class=\"line\">            for (Annotation annotation : parameterAnnotation) &#123;</span><br><span class=\"line\">                if (annotation instanceof Param) &#123;</span><br><span class=\"line\">                    names[i] = ((Param) annotation).value();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return names;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>Kotlin的版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun getMethodParamsName(method: Method): Array&lt;String&gt; &#123;</span><br><span class=\"line\">        val names = Array(method.parameterAnnotations.size) &#123; &quot;&quot; &#125;</span><br><span class=\"line\">        val parameterAnnotations =</span><br><span class=\"line\">            method.parameterAnnotations</span><br><span class=\"line\">        for (i in parameterAnnotations.indices) &#123;</span><br><span class=\"line\">            val parameterAnnotation = parameterAnnotations[i]</span><br><span class=\"line\">            for (annotation in parameterAnnotation) &#123;</span><br><span class=\"line\">                if (annotation is Param) &#123;</span><br><span class=\"line\">                    names[i] = annotation.value</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return names</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>拿到注解的值后，我们就需要进行映射了。将最初的JSON串中的args下name和age的值拿出来。通过反射调用方法。<br>这里实现的想法是：<br>首先遍历参数列表，然后根据注解上的值与JSON中的args的键值对，进行判断，如果args下的key和参数上的@Param注解的值相等，则给这个参数附上相应的值。<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">args.forEach&#123;</span><br><span class=\"line\">    getMethodParamsName(method).forEach&#123;</span><br><span class=\"line\">        // if...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但在实现的时候，因为参数类型是可以变化的，不确定，所以在反序列化JSON的时候，无法确定类型，就会导致无法反序列化。所以这里，就考虑将方法的类型class(method.parameterTypes)获取出来，传入Gson，根据类型反序列化。<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">val type = TypeToken.getParameterized(CommandParam::class.java, paramType).type</span><br><span class=\"line\">                return gson.fromJson(it, type)</span><br></pre></td></tr></table></figure>\n<p>这样写了在测试过后发现，只完成了一半。因为如果参数的类型是Kotlin的基础数据类型，交给gson反序列化的时候会报错。非基础数据类型就达成了效果。<br>那么为什么Kotlin的基础数据类型就不支持呢？<br>于是我尝试了使用Java的数据类型，即将接口的定义改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun testMethod(</span><br><span class=\"line\">    @Param(&quot;age&quot;) age: Integer,</span><br><span class=\"line\">    @Param(&quot;name&quot;) name: String</span><br><span class=\"line\">): String</span><br></pre></td></tr></table></figure>\n<p>这样就可以正常工作了。于是我下断点调试了，发现Kotlin的Int和Java的Integer是两个不同的Class。<br>Int的ClassName为：”Int”<br>Integer的ClassName为：”java.lang.Integer”<br>在平时的Kotlin和Java的互相调用时，编译器会将Int和Integer、int当成一种类型，在传参、回调、泛型等场景都可以满足。<br>而在反射里却不是这样了。Int和Integer、int是完全不同的Class。所以要满足上面的需求，就需要手动添加区分他们的代码。<br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun kotlinClassConvert(clazz: Class&lt;*&gt;): Class&lt;*&gt; &#123;</span><br><span class=\"line\">        when (clazz) &#123;</span><br><span class=\"line\">            Int::class.java -&gt;</span><br><span class=\"line\">                return Integer::class.java</span><br><span class=\"line\">            Boolean::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Boolean::class.java</span><br><span class=\"line\">            Float::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Float::class.java</span><br><span class=\"line\">            Double::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Double::class.java</span><br><span class=\"line\">            Byte::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Byte::class.java</span><br><span class=\"line\">            Char::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Character::class.java</span><br><span class=\"line\">            Short::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Short::class.java</span><br><span class=\"line\">            Long::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Long::class.java</span><br><span class=\"line\">            else -&gt;</span><br><span class=\"line\">                return clazz</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>将Kotlin基础数据类型全部转换为Java的之后，上面的问题也就得到了解决。</p>\n","categories":["Android"],"tags":["Android","Kotlin","Java","反射"]},{"title":"Typescript学习记录","url":"/2020/04/13/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>TypeScript 是一门很好的语言 - Jcr</p>\n</blockquote>\n<p>这句话足以代表我对 <code>TypeScript</code> （以下简称TS）的评价。<br>说说学习 TS 的缘由吧。最近公司突然需要我用 TS 研发前端项目。虽然我是一名 Android 开发者，但是公司需要我，我当然就得站出来了~ 于是我花了半天时间学习 TS，好在我有 ES6 和 Kotlin 的基础。所以 TS 学习起来也很轻松，学习完成后直接上手使用感觉非常顺手。让我逐渐爱上了这门语言。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p><strong>这篇文章主要写一些感悟，没有什么干货。</strong></p>\n</blockquote>\n<h2 id=\"学习经历\"><a href=\"#学习经历\" class=\"headerlink\" title=\"学习经历\"></a>学习经历</h2><p>因为项目的紧急程度，所以只有计划 4H 的工作时间来学习，我没有去找一套视频教程来慢慢看慢慢实践，而是直接跑去找了一个 Gitbook 的 TS 教程，里面挑重要的看，一些基础的变量，循环这些就直接跳过了。文档地址：<a href=\"https://ts.xcatliu.com/basics/primitive-data-types\">https://ts.xcatliu.com/basics/primitive-data-types</a>   </p>\n<h2 id=\"项目实践经历\"><a href=\"#项目实践经历\" class=\"headerlink\" title=\"项目实践经历\"></a>项目实践经历</h2><p>我们项目是使用的 <code>Vuejs</code> 所以其实还需要去学习 <code>vue-porperty-decorator</code> 相关的东西。这里我们只讨论项目中 TS 的实战经历，开始使用 TS 的时候，让我感觉很有亲切感。TS 终于让写前端回到了有面向对象的感觉，熟悉的接口定义，熟悉的 Kotlin 问号操作符等等特性让我能够运筹帷幄。这些优化，都让项目的可维护性和代码可读性强了很多。想到之前自己一直是用 ES6 写前端写着玩还自我感觉良好，真后悔没有早点学 TS。<br>另外，TS用了会上瘾，用了之后再也不想去用 ES 了~</p>\n<h2 id=\"后续计划\"><a href=\"#后续计划\" class=\"headerlink\" title=\"后续计划\"></a>后续计划</h2><p>我准备把我后续或者正在研发的项目都改为 TS ，虽然可能工作量比较大，但是 TS 的语言魅力还是很足的。并且之前我都是用 <code>WebStorm</code> 进行前端的开发，后续也会尝试 <code>VSCode</code> 来开发。</p>\n","categories":["Web前端"],"tags":["Web","javascript","前端","typescript"]},{"title":"《学会提问》读书笔记","url":"/2022/03/20/asking-the-right-questions-after-reading/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《学会提问》是一本批判性思维入门书籍，因为对批判性思维的好奇，以及网上对这本书的评价还不错，所以我阅读了这本书。<br>本书主要介绍了常用批判性思维方式、如何得知一个结论的准确性、以及常见的谬误等等，如果你想有清晰的思维，想有精准的判断力，想知道别人是不是在忽悠你，那这本书一定能帮助你。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"精华语录\"><a href=\"#精华语录\" class=\"headerlink\" title=\"精华语录\"></a>精华语录</h2><h3 id=\"批判性思维鼓励你倾听他人，向他人学习\"><a href=\"#批判性思维鼓励你倾听他人，向他人学习\" class=\"headerlink\" title=\"批判性思维鼓励你倾听他人，向他人学习\"></a>批判性思维鼓励你倾听他人，向他人学习</h3><h3 id=\"批判性思维者的价值观\"><a href=\"#批判性思维者的价值观\" class=\"headerlink\" title=\"批判性思维者的价值观\"></a>批判性思维者的价值观</h3><ol>\n<li>自主决断</li>\n<li>好奇心</li>\n<li>谦恭有礼</li>\n<li>发自内心的尊重严密的论证</li>\n</ol>\n<h3 id=\"一个运用批判性思维的好方法是得出论点之前，充分论证这个论点的反面对论点并加以辩驳。\"><a href=\"#一个运用批判性思维的好方法是得出论点之前，充分论证这个论点的反面对论点并加以辩驳。\" class=\"headerlink\" title=\"一个运用批判性思维的好方法是得出论点之前，充分论证这个论点的反面对论点并加以辩驳。\"></a>一个运用批判性思维的好方法是得出论点之前，充分论证这个论点的反面对论点并加以辩驳。</h3><h3 id=\"提出批判性问题\"><a href=\"#提出批判性问题\" class=\"headerlink\" title=\"提出批判性问题\"></a>提出批判性问题</h3><ol>\n<li>论题和结论是什么</li>\n<li>理由是什么</li>\n<li>哪些词语或短语的意思不明确</li>\n<li>价值观假设和描述性假设是什么</li>\n</ol>\n<h3 id=\"批判性阅读的主要目标，就是判断结论是不是强有力，价值是大还是小。\"><a href=\"#批判性阅读的主要目标，就是判断结论是不是强有力，价值是大还是小。\" class=\"headerlink\" title=\"批判性阅读的主要目标，就是判断结论是不是强有力，价值是大还是小。\"></a>批判性阅读的主要目标，就是判断结论是不是强有力，价值是大还是小。</h3><h3 id=\"人身攻击性谬误：针对个人进行攻击，而不反驳其理由\"><a href=\"#人身攻击性谬误：针对个人进行攻击，而不反驳其理由\" class=\"headerlink\" title=\"人身攻击性谬误：针对个人进行攻击，而不反驳其理由\"></a>人身攻击性谬误：针对个人进行攻击，而不反驳其理由</h3><h3 id=\"叙述谬误：错误的假设一个貌似可以正在发生的故事，并将假设和事实联系\"><a href=\"#叙述谬误：错误的假设一个貌似可以正在发生的故事，并将假设和事实联系\" class=\"headerlink\" title=\"叙述谬误：错误的假设一个貌似可以正在发生的故事，并将假设和事实联系\"></a>叙述谬误：错误的假设一个貌似可以正在发生的故事，并将假设和事实联系</h3><h3 id=\"滑坡谬误：假设采取某种做法会引发一连串不可控的不利事件，而实际上有现成的程序可以用来放置此类连锁事件的发生。\"><a href=\"#滑坡谬误：假设采取某种做法会引发一连串不可控的不利事件，而实际上有现成的程序可以用来放置此类连锁事件的发生。\" class=\"headerlink\" title=\"滑坡谬误：假设采取某种做法会引发一连串不可控的不利事件，而实际上有现成的程序可以用来放置此类连锁事件的发生。\"></a>滑坡谬误：假设采取某种做法会引发一连串不可控的不利事件，而实际上有现成的程序可以用来放置此类连锁事件的发生。</h3><h3 id=\"追求完美方案谬误：错误的认为如果尝试某种解决方案还有遗留问题未解决，那么这种解决方案就不该采用。\"><a href=\"#追求完美方案谬误：错误的认为如果尝试某种解决方案还有遗留问题未解决，那么这种解决方案就不该采用。\" class=\"headerlink\" title=\"追求完美方案谬误：错误的认为如果尝试某种解决方案还有遗留问题未解决，那么这种解决方案就不该采用。\"></a>追求完美方案谬误：错误的认为如果尝试某种解决方案还有遗留问题未解决，那么这种解决方案就不该采用。</h3><h3 id=\"诉诸公众谬误：试图通过引述很多人都持有这一观点，以证明某个断言有道理，错误的认为很多人支持的事就是可取的。\"><a href=\"#诉诸公众谬误：试图通过引述很多人都持有这一观点，以证明某个断言有道理，错误的认为很多人支持的事就是可取的。\" class=\"headerlink\" title=\"诉诸公众谬误：试图通过引述很多人都持有这一观点，以证明某个断言有道理，错误的认为很多人支持的事就是可取的。\"></a>诉诸公众谬误：试图通过引述很多人都持有这一观点，以证明某个断言有道理，错误的认为很多人支持的事就是可取的。</h3><h3 id=\"诉诸可疑权威谬误：引用某一权威的话来证明结论，而该权威对这一论题并没有特别的专门知识。\"><a href=\"#诉诸可疑权威谬误：引用某一权威的话来证明结论，而该权威对这一论题并没有特别的专门知识。\" class=\"headerlink\" title=\"诉诸可疑权威谬误：引用某一权威的话来证明结论，而该权威对这一论题并没有特别的专门知识。\"></a>诉诸可疑权威谬误：引用某一权威的话来证明结论，而该权威对这一论题并没有特别的专门知识。</h3><h3 id=\"诉诸情感谬误：使用带有强烈情感色彩的语言分散读者注意力，让他们忽视相关理由和证据。（恐惧、希望、爱国、怜悯、同情）\"><a href=\"#诉诸情感谬误：使用带有强烈情感色彩的语言分散读者注意力，让他们忽视相关理由和证据。（恐惧、希望、爱国、怜悯、同情）\" class=\"headerlink\" title=\"诉诸情感谬误：使用带有强烈情感色彩的语言分散读者注意力，让他们忽视相关理由和证据。（恐惧、希望、爱国、怜悯、同情）\"></a>诉诸情感谬误：使用带有强烈情感色彩的语言分散读者注意力，让他们忽视相关理由和证据。（恐惧、希望、爱国、怜悯、同情）</h3><h3 id=\"稻草人谬误：歪曲对方的观点，使其容易受到攻击，进而攻击事实上根本就不存在的观点。\"><a href=\"#稻草人谬误：歪曲对方的观点，使其容易受到攻击，进而攻击事实上根本就不存在的观点。\" class=\"headerlink\" title=\"稻草人谬误：歪曲对方的观点，使其容易受到攻击，进而攻击事实上根本就不存在的观点。\"></a>稻草人谬误：歪曲对方的观点，使其容易受到攻击，进而攻击事实上根本就不存在的观点。</h3><h3 id=\"虚假的-2-选-1-谬误：存在两种以上的选择时，假想只有两种选择。\"><a href=\"#虚假的-2-选-1-谬误：存在两种以上的选择时，假想只有两种选择。\" class=\"headerlink\" title=\"虚假的 2 选 1 谬误：存在两种以上的选择时，假想只有两种选择。\"></a>虚假的 2 选 1 谬误：存在两种以上的选择时，假想只有两种选择。</h3><h3 id=\"乱扣帽子谬误：错误地认为因为你给某个特定事件或行为起了名字，所以你合理解释了这一事件。\"><a href=\"#乱扣帽子谬误：错误地认为因为你给某个特定事件或行为起了名字，所以你合理解释了这一事件。\" class=\"headerlink\" title=\"乱扣帽子谬误：错误地认为因为你给某个特定事件或行为起了名字，所以你合理解释了这一事件。\"></a>乱扣帽子谬误：错误地认为因为你给某个特定事件或行为起了名字，所以你合理解释了这一事件。</h3><h3 id=\"计划谬误：人们倾向于低估完成一项工作所需的时间，尽管有很多过去的经验显示他们曾一直低估完成某件事的时间。\"><a href=\"#计划谬误：人们倾向于低估完成一项工作所需的时间，尽管有很多过去的经验显示他们曾一直低估完成某件事的时间。\" class=\"headerlink\" title=\"计划谬误：人们倾向于低估完成一项工作所需的时间，尽管有很多过去的经验显示他们曾一直低估完成某件事的时间。\"></a>计划谬误：人们倾向于低估完成一项工作所需的时间，尽管有很多过去的经验显示他们曾一直低估完成某件事的时间。</h3><h3 id=\"粉饰谬误：使用模糊、引发人们强烈情感认同的描述品行的词语，使我们倾向于同意某件事而不去细查其理由。\"><a href=\"#粉饰谬误：使用模糊、引发人们强烈情感认同的描述品行的词语，使我们倾向于同意某件事而不去细查其理由。\" class=\"headerlink\" title=\"粉饰谬误：使用模糊、引发人们强烈情感认同的描述品行的词语，使我们倾向于同意某件事而不去细查其理由。\"></a>粉饰谬误：使用模糊、引发人们强烈情感认同的描述品行的词语，使我们倾向于同意某件事而不去细查其理由。</h3><h3 id=\"转移话题谬误：插入一个不相干的话题，已将人们的注意力从原来的论题上转移开。\"><a href=\"#转移话题谬误：插入一个不相干的话题，已将人们的注意力从原来的论题上转移开。\" class=\"headerlink\" title=\"转移话题谬误：插入一个不相干的话题，已将人们的注意力从原来的论题上转移开。\"></a>转移话题谬误：插入一个不相干的话题，已将人们的注意力从原来的论题上转移开。</h3><h3 id=\"循环论证谬误：在论证过程中假设自己结的结论成立的论证\"><a href=\"#循环论证谬误：在论证过程中假设自己结的结论成立的论证\" class=\"headerlink\" title=\"循环论证谬误：在论证过程中假设自己结的结论成立的论证\"></a>循环论证谬误：在论证过程中假设自己结的结论成立的论证</h3><h3 id=\"怎么判断事实的准确性？\"><a href=\"#怎么判断事实的准确性？\" class=\"headerlink\" title=\"怎么判断事实的准确性？\"></a>怎么判断事实的准确性？</h3><ul>\n<li>你的证据是什么？</li>\n<li>你怎么知道它是真的？</li>\n<li>证据在哪里？</li>\n<li>你为什么相信它？</li>\n<li>你确信它是真的吗？</li>\n<li>你能证明吗？</li>\n</ul>\n<h3 id=\"以偏概全谬误：一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论\"><a href=\"#以偏概全谬误：一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论\" class=\"headerlink\" title=\"以偏概全谬误：一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论\"></a>以偏概全谬误：一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论</h3><h3 id=\"好的科学研究使我们获得证据的一个优质来源，因为科学研究强调可重复性、控制和精确性。\"><a href=\"#好的科学研究使我们获得证据的一个优质来源，因为科学研究强调可重复性、控制和精确性。\" class=\"headerlink\" title=\"好的科学研究使我们获得证据的一个优质来源，因为科学研究强调可重复性、控制和精确性。\"></a>好的科学研究使我们获得证据的一个优质来源，因为科学研究强调可重复性、控制和精确性。</h3><h3 id=\"强求确定性谬误：认为一个研究结论如果不是百分百确定，就应该被抛弃。\"><a href=\"#强求确定性谬误：认为一个研究结论如果不是百分百确定，就应该被抛弃。\" class=\"headerlink\" title=\"强求确定性谬误：认为一个研究结论如果不是百分百确定，就应该被抛弃。\"></a>强求确定性谬误：认为一个研究结论如果不是百分百确定，就应该被抛弃。</h3><h3 id=\"过度简化因果关系谬误：依赖并不足以解释整个事件的因果因素来解释一个事件，或者过分强调这些因素中的一个或多个因素的作用。\"><a href=\"#过度简化因果关系谬误：依赖并不足以解释整个事件的因果因素来解释一个事件，或者过分强调这些因素中的一个或多个因素的作用。\" class=\"headerlink\" title=\"过度简化因果关系谬误：依赖并不足以解释整个事件的因果因素来解释一个事件，或者过分强调这些因素中的一个或多个因素的作用。\"></a>过度简化因果关系谬误：依赖并不足以解释整个事件的因果因素来解释一个事件，或者过分强调这些因素中的一个或多个因素的作用。</h3><h3 id=\"因果关系谬误：将时间的起因和结果相混淆，或未能认识到两件事之间可能是相互影响的关系。\"><a href=\"#因果关系谬误：将时间的起因和结果相混淆，或未能认识到两件事之间可能是相互影响的关系。\" class=\"headerlink\" title=\"因果关系谬误：将时间的起因和结果相混淆，或未能认识到两件事之间可能是相互影响的关系。\"></a>因果关系谬误：将时间的起因和结果相混淆，或未能认识到两件事之间可能是相互影响的关系。</h3><h3 id=\"忽略共同原因谬误：未能认识到两件事之间之所以有联系，是因为第三种因素在起作用。\"><a href=\"#忽略共同原因谬误：未能认识到两件事之间之所以有联系，是因为第三种因素在起作用。\" class=\"headerlink\" title=\"忽略共同原因谬误：未能认识到两件事之间之所以有联系，是因为第三种因素在起作用。\"></a>忽略共同原因谬误：未能认识到两件事之间之所以有联系，是因为第三种因素在起作用。</h3><h3 id=\"事后归因谬误：假设乙事件是由甲事件引发的，仅仅因为乙在时间上紧随甲之后发生。\"><a href=\"#事后归因谬误：假设乙事件是由甲事件引发的，仅仅因为乙在时间上紧随甲之后发生。\" class=\"headerlink\" title=\"事后归因谬误：假设乙事件是由甲事件引发的，仅仅因为乙在时间上紧随甲之后发生。\"></a>事后归因谬误：假设乙事件是由甲事件引发的，仅仅因为乙在时间上紧随甲之后发生。</h3><h3 id=\"很多事件并非只有一种简单的解释\"><a href=\"#很多事件并非只有一种简单的解释\" class=\"headerlink\" title=\"很多事件并非只有一种简单的解释\"></a>很多事件并非只有一种简单的解释</h3><h2 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h2><p>在阅读《学会提问》之前，我一直以为这是一本告诉我们怎么提问的书籍，但实际上这本书的内容不止告诉我们该怎么提问，还告诉我们提问的底层逻辑是什么，如何通过提问去寻找事实的真相，对于一个观点、一个结论，从理由到结论的整条论证链路有哪些是准确的，有哪些是可以相信的，有哪些是存疑的，有哪些是不可相信甚至谬误的，这本书都有系统性的梳理和案例。<br>读完之后，我感受到我更能「讲道理」了，看到一些看似说服力很强的文章和观点，也能提出一些批判性问题来判断真实性。除此之外，科学的提问还可以增加思考的深度，帮助我更加接近结论的本质。总的来说，《学会提问》是一本很提升思考能力的书籍。</p>\n"},{"title":"Typescript npm 库项目框架搭建","url":"/2021/01/08/build-ts-lib/","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>npm 库对大家来说并不陌生，就和 java 的 maven 坐标一样，在前端项目中可以使用 npm 轻松管理这些依赖。<br>前些时间因为一些机缘巧合的需求，我需要编写一个监控埋点 npm 库以供应用使用。拿到这个需求之后，我第一时间做了一个初步的设计，项目无需 UI 组件，需要满足 Web、H5、小程序这三个平台的使用。考虑到 typescript 的种种优势，我选择使用 typescript 来开发，并觉得采用插件式的架构思想来对这个库进行拆分。网上有许多关于 typescript 编写 npm 库的文章和描述，但这些库相对于我的需求来说，总是多了一些东西或是少了一些东西，最终我根据网上的资料和自身的需求做了一个 npm 库的框架，适合用于中小型无 UI 组件的独立库，而如何搭建，如何取舍框架内的组件，就是本篇文章的主题。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、搭建思路\"><a href=\"#一、搭建思路\" class=\"headerlink\" title=\"一、搭建思路\"></a>一、搭建思路</h2><p>由于项目框架是针对中小型无 UI 组件的独立库，所以在整体的搭建思路上更加偏向于轻量、快速、简洁，在设计模式上更加偏向独立，控制库的接口对外暴露，内部具体实现则无需对外暴露，接入方通过库的接口进行操作，减少项目的侵入性和耦合度。</p>\n<h3 id=\"1-1-框架要求\"><a href=\"#1-1-框架要求\" class=\"headerlink\" title=\"1.1 框架要求\"></a>1.1 框架要求</h3><p>几经权衡，在既想保证库的简洁，又要保证基本功能都有的要求下，最终决定这样要求：</p>\n<ul>\n<li>使用 typescript 开发</li>\n<li>具备单元测试能力</li>\n<li>使用代码静态检查（tslint）</li>\n<li>代码风格统一</li>\n</ul>\n<p>看到这里，大家对框架的技术选型已经能猜个八九不离十了吧。根据以上几个点来说，相应的组件库即为：</p>\n<ul>\n<li>typescript/tslint</li>\n<li>jest</li>\n<li>prettier &amp; .editorconfig</li>\n</ul>\n<p>同时为了解决环境和打包的问题还配备了 <code>cross-env</code>、<code>webpack</code> 和 <code>uglifyjs</code></p>\n<p>这里没有选用一些市面上主流 npm 库框架的全家桶，是因为我认为要想做到轻量、快速和简洁，框架提供一些必要且能基本满足需求的组件就足够了，如果有更深入的需求再添加也不迟。   </p>\n<p>对于这个项目框架来说，考虑后但舍弃的有以下组件：</p>\n<ul>\n<li>mockjs 没有考虑 mockjs 的原因是使用 mockjs 的成本较高，在与后端快速开发时往往会直接对接口进行联调，mock 数据并不一定需要。即使需要，也有许多接口管理类产品（yapi、rap、swagger 等）可以支持。使用 mockjs 来模拟的诉求并不强烈。</li>\n<li>commitlint 提交检测，commitlint 可以让 commit message 变得更加规范，保证提交的代码的稳定性，方便管理协作开发，多人协作时效率更高。舍弃 commitlint 的原因是，针对中小型的 UI 组件库，往往协作开发的人数较少，且业务相对较为简单。commitlint 在这种场景下增加了使用成本。</li>\n</ul>\n<h3 id=\"1-2-构建流程\"><a href=\"#1-2-构建流程\" class=\"headerlink\" title=\"1.2 构建流程\"></a>1.2 构建流程</h3><p>基于以上的技术选型，我们将源文件 <code>.ts</code> 经过编译、压缩后最终生成 <code>.js</code> 文件和 <code>.d.ts</code> 文件，再将这些文件发布。<br>具体流程如下：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-2-18/1613638730533-image.png\"></p>\n<h2 id=\"二、操作步骤\"><a href=\"#二、操作步骤\" class=\"headerlink\" title=\"二、操作步骤\"></a>二、操作步骤</h2><h3 id=\"2-1-配置-typescript\"><a href=\"#2-1-配置-typescript\" class=\"headerlink\" title=\"2.1 配置 typescript\"></a>2.1 配置 typescript</h3><p>执行命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev typescript</span><br><span class=\"line\">tsc --init</span><br></pre></td></tr></table></figure>\n<p>执行后会在目录下生成 <code>tsconfig.js</code> 配置文件。<br>配置 <code>tsconfig.js</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class=\"line\">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class=\"line\">    &quot;declaration&quot;: true,</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;./dist&quot;,</span><br><span class=\"line\">    &quot;strict&quot;: true,</span><br><span class=\"line\">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class=\"line\">    &quot;esModuleInterop&quot;: true,</span><br><span class=\"line\">    &quot;skipLibCheck&quot;: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;include&quot;: [</span><br><span class=\"line\">    &quot;src&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;exclude&quot;: [</span><br><span class=\"line\">    &quot;node_modules&quot;,</span><br><span class=\"line\">    &quot;**/__tests__/*&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-配置-tslint、editorconfig、prettier\"><a href=\"#2-2-配置-tslint、editorconfig、prettier\" class=\"headerlink\" title=\"2.2 配置 tslint、editorconfig、prettier\"></a>2.2 配置 tslint、editorconfig、prettier</h3><p>项目根目录下新建 .editorconfig   </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># EditorConfig is awesome: http://EditorConfig.org</span><br><span class=\"line\"></span><br><span class=\"line\"># top-most EditorConfig file</span><br><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\"># Unix-style newlines with a newline ending every file</span><br><span class=\"line\">[*]</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Matches multiple files with brace expansion notation</span><br><span class=\"line\"># Set default charset</span><br><span class=\"line\">[*.&#123;js,jsx,ts,tsx,html,scss,css&#125;]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">trim_trailing_whitespace = true</span><br></pre></td></tr></table></figure>\n<p>执行命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev prettier tslint tslint-config-prettier</span><br></pre></td></tr></table></figure>\n\n<p>新建 <code>tslint.json</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: [&quot;tslint:recommended&quot;, &quot;tslint-config-prettier&quot;],</span><br><span class=\"line\">  &quot;rules&quot;: &#123;</span><br><span class=\"line\">    &quot;no-console&quot;: false,</span><br><span class=\"line\">    &quot;object-literal-sort-keys&quot;: false,</span><br><span class=\"line\">    &quot;member-access&quot;: false,</span><br><span class=\"line\">    &quot;ordered-imports&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;linterOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;exclude&quot;: [&quot;**/*.json&quot;, &quot;node_modules&quot;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新建 <code>.prettierrc</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;trailingComma&quot;: &quot;all&quot;,</span><br><span class=\"line\">  &quot;tabWidth&quot;: 4,</span><br><span class=\"line\">  &quot;semi&quot;: false,</span><br><span class=\"line\">  &quot;singleQuote&quot;: true,</span><br><span class=\"line\">  &quot;endOfLine&quot;: &quot;lf&quot;,</span><br><span class=\"line\">  &quot;printWidth&quot;: 120,</span><br><span class=\"line\">  &quot;overrides&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;files&quot;: [&quot;*.md&quot;, &quot;*.json&quot;, &quot;*.yml&quot;, &quot;*.yaml&quot;],</span><br><span class=\"line\">      &quot;options&quot;: &#123;</span><br><span class=\"line\">        &quot;tabWidth&quot;: 2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里配置了基本的 <code>tslint</code> 校验规则和 <code>prettier</code> 代码风格规则，可根据需求修改。</p>\n</blockquote>\n<h3 id=\"2-3-配置-jest\"><a href=\"#2-3-配置-jest\" class=\"headerlink\" title=\"2.3 配置 jest\"></a>2.3 配置 jest</h3><p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest ts-jest @types/jest</span><br></pre></td></tr></table></figure>\n<p>配置 <code>jestconfig.json</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;transform&quot;: &#123;</span><br><span class=\"line\">    &quot;^.+\\\\.(t|j)sx?$&quot;: &quot;ts-jest&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;testRegex&quot;: &quot;(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.(jsx?|tsx?)$&quot;,</span><br><span class=\"line\">  &quot;moduleFileExtensions&quot;: [&quot;ts&quot;, &quot;tsx&quot;, &quot;js&quot;, &quot;jsx&quot;, &quot;json&quot;, &quot;node&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里使用了正则匹配单元测试文件的目录及后缀，需要放在 <code>__tests__</code> 目录下。如果使用 IDEA 想要直接通过「绿色箭头」直接执行单元测试，需要在 “Run Configuration” 中配置 Jest Options: <code> --config jestconfig.json</code></p>\n</blockquote>\n<h3 id=\"2-4-配置-webpack\"><a href=\"#2-4-配置-webpack\" class=\"headerlink\" title=\"2.4 配置 webpack\"></a>2.4 配置 webpack</h3><p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev webpack webpack-cli cross-env</span><br><span class=\"line\">npm install --save-dev uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure>\n<p>配置 <code>webpack.config.js</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;);</span><br><span class=\"line\">const production = process.env.NODE_ENV === &#x27;production&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    entry: &#x27;./src/main/index.ts&#x27;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        filename: &#x27;index.js&#x27;,</span><br><span class=\"line\">        path: __dirname + &#x27;/dist&#x27;,</span><br><span class=\"line\">        libraryTarget: &#x27;umd&#x27;,</span><br><span class=\"line\">        library: process.env.npm_package_name,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mode: production ? &#x27;production&#x27; : &#x27;development&#x27;,</span><br><span class=\"line\">    externals: &#123;&#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.tsx?$/,</span><br><span class=\"line\">                loader: &#x27;ts-loader&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">        extensions: [&#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    optimization: &#123;</span><br><span class=\"line\">        minimizer: [</span><br><span class=\"line\">            // we specify a custom UglifyJsPlugin here to get source maps in production</span><br><span class=\"line\">            new UglifyJsPlugin(&#123;</span><br><span class=\"line\">                uglifyOptions: &#123;</span><br><span class=\"line\">                    compress: true,</span><br><span class=\"line\">                    ecma: 5,</span><br><span class=\"line\">                    mangle: false,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                sourceMap: !production,</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里在配置中使用 <code>ts-loader</code> 和 <code>uglifyjs</code> 对编译生成的 js 进行处理。</p>\n</blockquote>\n<h3 id=\"2-5-配置-package-json\"><a href=\"#2-5-配置-package-json\" class=\"headerlink\" title=\"2.5 配置 package.json\"></a>2.5 配置 package.json</h3><p>在 <code>scripts</code> 下添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;test&quot;: &quot;jest --config jestconfig.json --coverage&quot;,</span><br><span class=\"line\">&quot;build&quot;: &quot;rimraf ./dist &amp;&amp; cross-env NODE_ENV=production webpack&quot;,</span><br><span class=\"line\">&quot;release&quot;: &quot;rimraf ./dist &amp;&amp; cross-env NODE_ENV=production webpack &amp;&amp; yarn publish&quot;,</span><br><span class=\"line\">&quot;format&quot;: &quot;prettier --write \\&quot;src/**/*.ts\\&quot; \\&quot;src/**/*.js\\&quot;&quot;,</span><br><span class=\"line\">&quot;lint&quot;: &quot;tslint -p tsconfig.json&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>轻量、快速、简洁是我这次搭建 npm 库的要求，目的是为了让这个 npm 库可以做到「适合」需求。要做到「适合」，并不是一件容易的事情。这次是我首次使用 Typescript 研发，使用之前的 SDK 研发原则和经验进行尝试，并抽象出了这么一个 ts npm 库的框架。除去语言本身，SDK 的研发原则和思路是相通的，在各个端都能以这种方式进行。有了原则和思路，就能确定项目的结构和流程，使用什么语言也就不重要了。</p>\n<p>Github 地址：<a href=\"https://github.com/csgajcr/ts-lib-skeleton\">https://github.com/csgajcr/ts-lib-skeleton</a></p>\n","categories":["Web前端"]},{"title":"和「洞宾」的一次聊天","url":"/2021/04/04/chat-with-dongbin/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>借着清明节回老家祭祖的机会，我来到了浙江杭州。与我的前同事「洞宾」见了个面，聊了聊各自的一些情况和一些思考。<br>简单介绍一下洞宾，洞宾是他在轻推团队的花名，2020 年之前是我在轻推团队的同事。现在阿里巴巴淘系研发部门担任高级研发工程师（P6），但他的职责包含但不限于项目负责人、资深 HR、实习生收割机、后端工程师、团队气氛组组长、电商理论专家、段子手等。<br>我们聊天的范围很广，从工作、技术、生活、成长以及情感都有所涉及，以下我将挑选一些值得思考和记录的点作为本文的内容。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、技术\"><a href=\"#一、技术\" class=\"headerlink\" title=\"一、技术\"></a>一、技术</h2><p>这一年的工作中，虽然我和洞宾写代码的工作都很少，但作为我们技术人来说，技术的话题那是必须得聊的。    </p>\n<h3 id=\"技术只是实现业务的一种工具\"><a href=\"#技术只是实现业务的一种工具\" class=\"headerlink\" title=\"技术只是实现业务的一种工具\"></a>技术只是实现业务的一种工具</h3><p>国内各个大厂招聘，无论是校招还是社招，对技术基础的要求很高，从框架的使用、框架的源码、设计思路，直至数据结构算法。这让很多人（包括我）都以为阿里巴巴是一个技术氛围很浓，而且特别重视技术的公司。但这次聊天的得到结果却大相径庭。除了阿里云之外的其他几乎所有事业部都只关注业务，甚至研发人员招聘进去之后，大部分时间都在做业务，少部分时间写代码。这是为什么呢？<br>因为「技术只是实现业务的一种工具」，阿里之所以对技术要求很高，是因为技术能力达标，有足够的判断力之后，就可以将重心更多的往业务方向转，从而提高整体的效益。业务才是价值转换的核心。</p>\n<h3 id=\"框架、语言只是表层，更重要的是对技术底层的原理和技术的抽象能力\"><a href=\"#框架、语言只是表层，更重要的是对技术底层的原理和技术的抽象能力\" class=\"headerlink\" title=\"框架、语言只是表层，更重要的是对技术底层的原理和技术的抽象能力\"></a>框架、语言只是表层，更重要的是对技术底层的原理和技术的抽象能力</h3><p>洞宾提到，以前在轻推板栗看板团队时，前期他因为工作效率过高，将后端代码重构了 4 遍，尝试了 4 种不同的后端技术栈，除了框架使用不一样以外，业务本身是一样的。框架、语言在这其中仅仅只会影响实现业务手段中的「使用」层面。对业务模型的编码，设计模式的划分是相通的。<br>在评估一个人技术能力如何时，框架和语言只是参考项，更重要的是用技术解决业务的能力，而技术底层的原理和技术的抽象能力就是基础。</p>\n<h3 id=\"不要陷入技术思维的旋涡中\"><a href=\"#不要陷入技术思维的旋涡中\" class=\"headerlink\" title=\"不要陷入技术思维的旋涡中\"></a>不要陷入技术思维的旋涡中</h3><p>作为技术人，往往都会本能的喜欢去折腾新技术，想把一些牛逼的技术应用到产品上，这有助于提升自己的成就感、技术实践经验和简历上的内容，这些都没有问题，但是会形成技术思维的旋涡，让我们在面对问题时，习惯用更复杂、更新、更牛逼的技术去解决。在实际场景中， 95% 以上的业务需求，都可以用当前已经很普遍很成熟的技术来实现，使用这些技术能够提高效率和稳定性。例如，「微服务」是一个适合具备一定规模化和高可用的业务场景。并不是业务模块多、相互调用频繁就需要「微服务」，在许多中小型产品的技术选型上，微服务都不是一个很合适的架构选型，但许多小产品团队却选择微服务作为后端技术架构方案。<br>所以在技术方案制定时，「适合」是第一要素。技术思维旋涡会让我们过多的从技术角度思考，从而去实践一些风险更大，成本更高，更复杂的技术。</p>\n<h2 id=\"二、研发管理\"><a href=\"#二、研发管理\" class=\"headerlink\" title=\"二、研发管理\"></a>二、研发管理</h2><p>阿里号称「狼性团队」，洞宾对「狼性」所带来的效率提升评价也很高。任何一个研发管理方案都具备两面性，不会十全十美。那么阿里的「狼性」研发管理流程和赛迪的研发管理流程，各自具备哪些特点呢。\b</p>\n<h3 id=\"阿里的研发管理\"><a href=\"#阿里的研发管理\" class=\"headerlink\" title=\"阿里的研发管理\"></a>阿里的研发管理</h3><p>阿里的研发管理文化以「狼性」为核心，说的社会一点就叫「只要干不死，就往死里干」。从绩效层面来说，每年有 10% 的员工将会没有年终奖（阿里的年终奖受到绩效影响很大），同时年终奖会受到员工所在部门的 KPI 影响，部门效益好，那么同样绩效等级的员工拿的就越多。这一规则使得部门层面要更高效的做更多的事情，完成更多的 KPI 以获得更多的奖金。<br>从研发效率层面来说，因为受到部门 KPI 的影响，研发的排期节奏都会拉快，没有员工会想去当那 10%，所以大部分员工往往在估研发时间时，会算上加班时间。如果以普通标准表单查询的「页面」为单位，以赛迪的 P4 岗级研发人员工作一天的工作量为基准，那么同样的工作时间，阿里员工的工作效率大约是赛迪的 1.4 倍左右。（据洞宾的反馈估算）<br>从目标的层面来说，在实现目标上，阿里的模式是这样的：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-6/1617699165362-image.png\"><br>从上至下目标越来越清晰，被拆分成一个又一个执行点，当每个最小单元员工能按时按量的完成任务时，金字塔就能堆砌起来。如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-6/1617700270433-image.png\"><br>这样达成目标的模式很容易理解，但在实施层面要做到是非常困难的。这里面的核心在于<strong>拆分</strong>，确定做了一件事，可以达成一个目标，需要对业务非常深入的理解。例如做一个推荐品类优化的功能点可以让总订单量提升 5%。洞宾用一句话形容的是：</p>\n<blockquote>\n<p>大目标一般看起来很离谱，就是看上去不可能完成的那种，例如 3 个月订单量翻 10 倍，但真正按照这样的模式做了之后，跳一跳还真摸得着。我在其中只做了一个小功能点，做了这个点真的就真的可以达到小目标的效果。   </p>\n</blockquote>\n<p>从员工职业生涯层面来看，在阿里能够得到晋升主要凭借「机遇」，当然「能力」是必备的。一般绩效中等的普通研发的尽头就是 P7 了，有过杰出效果可以到 P8。如果能干出一个一鸣惊人的事情时，上限就改成了 P10，岗位也会随之提升。在往上就是「神の领域」了，一般是整个事业部的 CTO、国内外有影响力的专家，高级科研人员等。</p>\n<h3 id=\"赛迪的研发管理\"><a href=\"#赛迪的研发管理\" class=\"headerlink\" title=\"赛迪的研发管理\"></a>赛迪的研发管理</h3><p>说到自己公司的研发管理，虽然是自己最熟悉、最了解的，但却有一种一言难尽的感觉。公司在 21 年 3 月做了一次体系的调整，其中会涉及到研发管理体系的变更。而这一部分目前还没有公布。<br>按照当前和之前的研发管理现状来看，赛迪的研发体系更加偏稳定。<br>从绩效层面，给绩效好的员工奖励有限，给绩效较差的员工奖励也不会完全没有，大家更像是吃大锅饭，波动性不高。<br>从研发效率层面来说，赛迪的研发效率相比阿里这样的一线互联网公司依然有差距，但差距不在研发管理流程上，而是个人能力上的差距，这一点也很好理解。<br>从目标层面来讲，和阿里的模式是一致的，但执行效果有一些差距。这里面主要的原因有两点：</p>\n<ul>\n<li>阿里的平台大，资源投放丰富，产出质量高很多。</li>\n<li>对目标的分解和评估更准确，有专业的成本计算、数据分析和风控机制来保证分解后的功能点能够为目标带来效益。   </li>\n</ul>\n<p>（突然有点慌，毕竟自己还在这工作，万一被领导叫去喝茶了咋办~~）<br>但近年来，赛迪的客户也逐渐全面转向 to B，目标上和阿里淘系的目标有着本质上的差距，所以在研发管理有一些差别也很正常。以上仅是对当年还在做 C 端产品的分析。<br>从员工职业生涯层面来看，emmmm，虽然只是个人理解，但我依然还是觉得「机遇」贯穿了整个职业生涯，能否遇到和把握住机遇，是每一个职场人都在做的事情。</p>\n<h3 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h3><p>聊聊自己的感想，大型互联网公司并不神圣，虽然他们是国内技术巅峰的代表，但同样全心全力服务于业务。这让我在想，到底是「学一门技术走天下」还是「学一门业务走天下」。我们感叹技术所带来的通用性，到哪里都不怕。又不得不去深入业务，去探索结合技术所能带来的价值。<br>无论是 IT 行业、工业、传统实业，本质都是在创造价值，而再牛逼的技术所创造的价值都是有限的，都需要找到应用的业务场景，而业务变化所带来的价值才是无限的。</p>\n<h2 id=\"三、成长\"><a href=\"#三、成长\" class=\"headerlink\" title=\"三、成长\"></a>三、成长</h2><p>成长是我个人很喜欢的一个话题，在面对「绩效达人」洞宾时，一定得聊聊他平时有哪些习惯，如何持续学习，怎么让自己的绩效很好的。</p>\n<h3 id=\"沟通能力是核心，并不是锦上添花。\"><a href=\"#沟通能力是核心，并不是锦上添花。\" class=\"headerlink\" title=\"沟通能力是核心，并不是锦上添花。\"></a>沟通能力是核心，并不是锦上添花。</h3><p>这个观点来自于洞宾，一般的技术人都会认为做技术，技术能力是核心，沟通能力不是那么重要。但在真实的工作场景下，无论是大厂还是小厂，一个人的沟通、协调能力，分析思考能力是影响这个人最重要的两大因素。而如果缺失良好沟通能力，其他能力的体现都会大打折扣。<br>在这一点上与我很有共鸣，我的沟通能力不算优秀，在工作中也因为沟通能力不够好而遇到一些困难，当然我也在努力提升。沟通能力有多重要的案例大家一定都知道许多，我就不多写了。<br>只是意识到重要并不重要，坚持改变才重要，而改变的过程才是最困难的过程。</p>\n<h3 id=\"不要畏惧新事物\"><a href=\"#不要畏惧新事物\" class=\"headerlink\" title=\"不要畏惧新事物\"></a>不要畏惧新事物</h3><p>这算是我和洞宾的一个共同点，我们都对新的技术，新的发展趋势保持着较高的兴趣，平时会看文章并持续关注，不会因为害怕新技术所带来的坑和不稳定性而阻止我们学习。<br>我认为新技术的学习重要的不是技术本身，而是技术的起源，在当下的环境为什么会出现，他是如何解决现有的问题的等等。本质上是从「新」的东西中挖掘特性，这些思考会为未来各类的问题解决思路提供不错的基座。</p>\n<h3 id=\"认识自己\"><a href=\"#认识自己\" class=\"headerlink\" title=\"认识自己\"></a>认识自己</h3><p>认识到自己有几斤几两是洞宾认为很重要且一直在做的事情。早期在赛迪的时候，洞宾就经常出去其他公司面试，倒不是为了多么想跳槽，只是为了从面试的过程看到自己还缺什么，市场价值怎么样。只要你面的足够多，你对自己的认识就越准确。当然认识自己的方法有很多，多面试只是其中一种。<br>「自信」就源于对自己认识的准确程度，在公司的大环境下，很容易受到公司各种氛围的影响。例如你会根据公司的绩效而觉得自己的水平很强或是很弱，会因为领导的评价而觉得自己是不是很好或者很差，会因为同事的讨论而错误估计自己的观点的客观性。如果有足够客观的手段，来更好的认识自己，能让自己的在职场道路中有更明确的方向前进，遇到自己被高估的情况，可以潜心找到自己的不足继续提升，遇到被误解的情况，也可以继续坚持自己的观点。    </p>\n<h3 id=\"机遇\"><a href=\"#机遇\" class=\"headerlink\" title=\"机遇\"></a>机遇</h3><p>洞宾对机遇的理解是：「我会尽量去做上线更高的事情，因为我认为这样的事情机遇大，做好可以带来更高的收益，但这样的事情可遇不可求，比较看运气。」<br>既然叫机遇嘛，随机性是一定有的，你一定听过要做好充分的准确，提升自己的实力才能把握住机遇这样的观点。<br>这样的观点当然是很合理的，除了这种观点之外，之前我还看到过另外一种观点。这种观点是这样描述的：「降低机遇在你人生规划中影响」。<br>这是一个与「高风险、高回报」的反思路，这个观点主张我们依然会全力应对机遇，但不能过度依靠机遇所带来的价值，应该花足够的精力去规划，「如果没有足够的机遇，我应该怎么做」。对任何一个人来说，完全没有机遇是不可能的，但过度依赖机遇同样是有风险的，我个人更加喜欢这样的思路，更像「稳中求胜」。</p>\n<h2 id=\"四、花絮\"><a href=\"#四、花絮\" class=\"headerlink\" title=\"四、花絮\"></a>四、花絮</h2><p>说点花絮吧，写了一篇的散点，也不是很全，本来只是一起吃个饭唠唠嗑，也没有准备啥话题，但聊着聊着觉得还是有很多可以思考的地方，所以就写了这篇文章，希望能给读者你带来一些收获吧。<br>洞宾是一个很有意思的人，有一些新奇的观点，例如论证了将电商那一套曝光量 * 转化率 + 漏斗的体系用在相亲场景是多么多么合理，以及具体如何操作和实践等等，虽然我个人表示怀疑态度，但他讲的确是很有道理。</p>\n","categories":["思考"],"tags":["聊天","访谈","朋友"]},{"title":"聊聊技术人的核心竞争力","url":"/2021/08/05/core-competitiveness-of-programmer/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>做了 4 年开发，写了 4 年代码，接触过不少技术栈，与千千万万个技术人一样，我也是一名一直专注于代码一线的技术人，技术水平自我感觉还不错。随着对技术和业务的深入，看到的技术人越来越多，他们有的是职场萌新，还在摸爬滚打，有的是业界大佬，已经立足于巅峰，更多的人则还是在这条络绎不绝技术之路上积累、学习和竞争。技术人之间往往难以分辨出孰高孰低，每个人掌握的知识都不一样，都有应用的领域，各有千秋。那么作为技术人来说，要怎么做才能更厉害呢？是学习更多的技术？更深入？更全面？还是跟着公司转型做业务和管理？<br>于是我开始思考：一个技术人的核心竞争力到底是什么？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>谈到核心竞争力，技术人的业务能力也是核心竞争力中非常重要的因素，但本篇文章我们抛开业务能力，单从技术的视角来看，一名技术人的核心竞争力有些什么。<br>我把技术人的核心竞争力分为 3 个层次，分别是：</p>\n<ul>\n<li>第一层次：技术能力、协同能力、学习能力</li>\n<li>第二层次：解决问题的能力、全局思维能力</li>\n<li>第三层次：影响力、创造力</li>\n</ul>\n<p>你可能会问我，为什么没有沟通能力？领导力？这些能力呢，这些不也是核心能力吗？<br>这些能力当然很重要，我把他们统一归到「协同能力」的范畴中，代表技术人所需要具备的基础能力。\b</p>\n<h2 id=\"第一层次：技术能力、协同能力、学习能力\"><a href=\"#第一层次：技术能力、协同能力、学习能力\" class=\"headerlink\" title=\"第一层次：技术能力、协同能力、学习能力\"></a>第一层次：技术能力、协同能力、学习能力</h2><p><strong>为什么把这仨能力放到第一层次呢？</strong><br>因为这是技术人必要的三种能力，技术能力帮我实现业余需求，解决业务问题，学习能力让我们进步，协同能力让我们高效。站在一个技术人的视角，只要做好这三点，就已经是一名很优秀的技术人了。<br>大部分的技术人的核心竞争力都在第一层次，想在他们之中脱颖而出，需要夯实基础，老老实实提升这仨能力就可以了。<br>那么怎么提升这些能力呢？</p>\n<ul>\n<li><strong>技术能力</strong> - 技术能力的提升说简单很简单，说难也很难。简单是因为我们只要在工作，就不断的在提升技术。难是因为，大家都在工作，都在提升，当大家都在以相同的速度提升时，大家也是相对静止的。所以如果想在技术能力上获得优势，就得比其他人提升的更快。例如：可以选择更有挑战性的任务，可以在工作之余学习课程，可以多总结复盘，可以参与领域讨论和实践等等。</li>\n<li><strong>协同能力</strong> - 基础的协同能力大家都有，否则是没法在这个行业下混了，那么怎么提升呢？我认为最重要的思想就是「站在团队的视角」谈协同，我们协同的目的是为了更加高效，从而完成团队的目标，好的协同能力可以让团队更快、更好的完成目标。本着这个指导思想，再去思考工作中的协同过程，就可以找到很多提升的方法了。</li>\n<li><strong>学习能力</strong> - 学习能力是很难提升的，它就像我们成长的加速度，提升它可以让我们学习其他能力更快。我把学习能力分为三个部分：「方法」、「思维」、「天赋」。天赋部分我们无法改变，随着年龄的增长，学习的速率肯定是会受到影响，但我们可以提升方法和思维两个部分。这两个部分网上都有许多资料，有专业的研究来教你如何专注、高效、系统化的学习，可以参考。在这两部分中，我认为最核心的就是要有「框架思维」，可以将知识的「点」，组成「线」和「面」，最终形成知识框架，用框架解决问题，从而触类旁通。</li>\n</ul>\n<h2 id=\"第二层次：解决问题的能力、全局思维能力\"><a href=\"#第二层次：解决问题的能力、全局思维能力\" class=\"headerlink\" title=\"第二层次：解决问题的能力、全局思维能力\"></a>第二层次：解决问题的能力、全局思维能力</h2><p>第二层次的能力往往针对团队中的技术主导者、架构师、技术负责人、技术总监、CTO 等角色。他们已经拥有了扎实的技术能力、学习能力和协同能力，能够独挡一面。团队需要他们来做润滑剂，打通业务和技术的桥梁。<br>对于这一部分技术人来说，解决问题的能力和全局思维能力就是他们竞争力的核心。<br>我们拿架构师举例来说，和一般开发者不同，随着职责的变更，架构师不只是要实现业务上的需求了，他还会面临更多的技术问题和非技术问题，这些问题并不是非黑即白，0 和 1 之间做选择，更多的是需要架构师做好 trade-off（权衡），给出一个更优解，所以解决问题的能力核心就在于如何做好 trade-off。做好 trade-off 不仅需要扎实的技术能力和多视角的思考，还需要保持一颗开放和透明的心态，尽可能客观、准确的评估各个相关因素。<br>解决问题的能力可以让团队「做到」，而全局思维能力能让团队「做好」，我们还是拿架构师这个角色来举例，全局思维能力要求架构师能够跳出技术的思维定式，站在全局的角度来思考，懂技术而不只用技术，发挥自己在技术领域的优势，迈入业务的领地，与其他领域的人一起思考，找到技术在这其中应该是什么形态，怎么和业务匹配，怎么和运营结合，让技术和业务的桥梁不光能通行，还能高速、稳定的通行。<br>抛开架构师这个角色，其他角均是一般，和架构师大同小异，区别仅仅是侧重点不一样。</p>\n<h2 id=\"第三层次：影响力（Impactive）、创造力-Creative\"><a href=\"#第三层次：影响力（Impactive）、创造力-Creative\" class=\"headerlink\" title=\"第三层次：影响力（Impactive）、创造力(Creative)\"></a>第三层次：影响力（Impactive）、创造力(Creative)</h2><p>第三层次的能力是那些生于技术，而不止于技术，致力于价值创造的人的核心竞争力。<br>举例来说，他们有的是产品总监（张小龙）、有的是自媒体博主（…）、有的是自由开发者（尤雨溪）等等，角色很多，他们在各自的领域发光发热，发挥着超乎技术的价值，\b 他们的共同点就是：拥有超凡的影响力或创造力。<br>所以，我把「影响力」和「创造力」归为第三层次的核心竞争力。<br>「影响力」和「创造力」的体现，可以是具备划时代意义的创造，也可以是我们一次代码当中的小重构。所以哪怕是最普通的程序员，也很需要它们，只是对于他们来说，其他能力可能在当下更加重要。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>每个技术人都同时具备第一、二、三层次的能力，只是能力水平和侧重点不一样，在不同的角色和职责下，三个层次的能力重要性各不相同。</p>\n<ul>\n<li>作为普通开发者，第一层次的能力就是核心竞争力。</li>\n<li>作为技术负责人或架构师，那么第一、二层次的能力就是核心竞争力。</li>\n<li>作为一个价值创造者，那么第一、二、三层次的能力都是核心竞争力。</li>\n</ul>\n","categories":["思考"],"tags":["思考","成长"]},{"title":"《深度思维》读书笔记","url":"/2020/04/19/deep-thinking-after-reading/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《深度思维》是一本适合精读的书，里面的思维方式需要仔细去琢磨和体会，每一次阅读我相信都会有收获。<br>这是一篇会持续更新的博客，直到本书读完为止。在写这篇博客之前，我已经粗读了一部分，感觉收获明显。现在我将从头开始再读一次，将其中的一些心得体会都分享到这里。希望能在分享的过程中，将所得的知识更加精炼，提升自己。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思维即命运\"><a href=\"#思维即命运\" class=\"headerlink\" title=\"思维即命运\"></a>思维即命运</h2><p>这一节讲述了对于普通人来说，有这些问题：没有良好的资源和背景，接触不到上层的信息，格局小，对事情的判断很简单等问题。这些都可以统一称为与之对标的“浅度思维”。所以更加需要深度思维来强化自己。深度思维是在我们做事情、观察事物的本质上，考虑的更多，更深。学会深度思维，可以使我们在人生中多了一把利器，面对困难和挑战时，披荆斩棘，成功的把握更高。   </p>\n<h2 id=\"一、深度思维的利益\"><a href=\"#一、深度思维的利益\" class=\"headerlink\" title=\"一、深度思维的利益\"></a>一、深度思维的利益</h2><p>本节以一个生产车间老板处理问题的方式的问题为例，体现出了深度思维中逻辑思维的作用。在这一节阅读后，我认为平时在解决问题时更应该去注重问题的本质。比如修复一个 BUG ，不能只局限于修复 BUG 本身所产生的问题。更要去探索 BUG 为什么会产生，是因为什么。如果是因为粗心，那么这里有没有什么提升空间，来减少粗心的概率。如果是因为逻辑复杂，是否可以让代码更加抽象，减小耦合度，使复杂的逻辑简单化，提高容错率等等。逻辑思维是深度思维中最基本的，往往越是高手，在对问题的考虑上越深。</p>\n<h3 id=\"1-1-5why-思考法\"><a href=\"#1-1-5why-思考法\" class=\"headerlink\" title=\"1.1 5why 思考法\"></a>1.1 5why 思考法</h3><p>5why 思考法描述了在解决问题多问为什么，以此方式，来探求最有效的办法。作者举了两个例子来模拟 5why 思考法是如何帮助我们解决的。里面我认为较为重要的点为：  </p>\n<ol>\n<li>5why 思考法对提问有要求，应该尽量往我们解决问题的方向上提，而不是随意提。否则任何提问到最后都会是物质的起源等等无意义的问题，这对于我们解决问题来说，并没有太大意义，这样的 5why 思考是错误的。</li>\n<li>5why 思考法对回答也有要求，在回答的时候，同样应该以解决问题未中心回答，例如：年轻人为什么喜欢喝快乐水？两个回答分别是“因为快乐水可以解渴”和“因为快乐水好喝”这两个回答哪个更合适立见分晓。</li>\n<li>5why 思考法解决问题时，一般来说，至少要提 5 个why才可以相对更加深入的了解问题的本质。那么多少个why是截止呢？这里就取决于什么时候问到无意义的问题，就可以终止了。比如：“人为什么要喝水”，“人为什么要生活” 等等。</li>\n</ol>\n<p>综合来说，5why思考法也属于基本逻辑思维能力的一部分。</p>\n<h3 id=\"1-2-5so-思考法\"><a href=\"#1-2-5so-思考法\" class=\"headerlink\" title=\"1.2 5so 思考法\"></a>1.2 5so 思考法</h3><p>5so 思考法和 5why思考法有些不同。5why 思考法是根据一个问题，不断地溯源。5so 思考法是根据一个信息，不断的往后推论。所以 5so 思考法和 5why 思考法的关键点也有明显差距。在本届中，作者以一个上海自贸区的案例来讲述了具有深度思维能力的投资者应该如何思考和推断。这个案例非常好理解，但同时也给了我一种很虚的感觉。举一个最近发生，且很真实的例子。<br>关于本次新冠肺炎，其实早在12月底1月初，就有相应的报道。假设我是一个很厉害的AI机器人，拥有世界上所有的知识储备。那么我可以推断出以下思维逻辑链条：</p>\n<ol>\n<li>新冠肺炎感染渠道多，且潜伏期长。所以传播会非常快。 so?</li>\n<li>随着感染人数的裂变式增加，医院的床位很快将被耗尽。 so？</li>\n<li>防护用品会因为疫情严重而迅速被抢空。 so？</li>\n<li>小区会限制大家出行，减少接触 so？</li>\n<li>超市里的生鲜蔬菜、速冻，方便食品必将会被快速抢光 so？</li>\n<li>宅在家里与外界沟通只能通过互联网 so？</li>\n<li>互联网游戏、电视剧、电影等线上业务会增加。so？</li>\n<li>….</li>\n</ol>\n<p>这里就不继续推论下去了，其实上面的推论看了之后你会说，这只是很小一部分。确实如此，因为新冠肺炎影响之大，涉及之广，往往一个效果可以推断出许多个可能。比如“小区会限制大家出行，减少接触” 会影响的地方绝不止“超市”。所以整个新冠的思维逻辑链条即多又广。而 5so 思考法的精髓，正是根据这些信息，推论出正确的结果。往往一个合理和正确的 5so 思维逻辑链条是很难推断准确的。需要对推断的领域具有很深的认知才可以进行下去。否则很容易在前两步推断就已经错误，更不用谈后续的推断了。在实战中，5so 思考法越往后的推断概率一般是越小的。<br>总结一下：5so 思考法的案例很精彩，如果用得好也会显得很华丽。但 5so 思考法的精髓并不是如何使用。而是在使用 5so 思考法时，自己对该领域的认知和了解。犹如自我的内功，内功越深，5so 思考法就越有价值。</p>\n<h3 id=\"1-3-多方法综合使用\"><a href=\"#1-3-多方法综合使用\" class=\"headerlink\" title=\"1.3 多方法综合使用\"></a>1.3 多方法综合使用</h3><p>本节以一个精彩的案例讲述了 5why 思考法和 5so 思考法的综合使用。案例中杂志社的一名资深编辑通过一个公司的一个普通的通知，分析出了其利益关系，再合结合当下的情况和未来的趋势。分析出了整个公司的运营情况和未来公司的走向。随后为自己的未来早早的做了规划，并尽早按照规划前进。<br>在多方法综合思考都比较准确的情况下，能够让我们精准的判断当下的形式，为未来做出规划。听起来很炫酷，但是我认为多方法综合使用同样非常考验一个人对思考领域的认知程度，思考如果出现偏差，容易出现失之毫厘谬以千里的问题。对于我这样的思考新手来说，往往思考最近两步还能保证准确性。在做稍微长远和大局思考的时候，有明显的劣势，容易出现思考偏差。</p>\n<h2 id=\"二、换位思考-为何你的努力别人不买账\"><a href=\"#二、换位思考-为何你的努力别人不买账\" class=\"headerlink\" title=\"二、换位思考 - 为何你的努力别人不买账\"></a>二、换位思考 - 为何你的努力别人不买账</h2><p>第二章换位思考主要讲述深度思维中的换位思考，本节中以三个反面案例和一个正面案例来讲述换位思考的作用。在反面案例中，分别以普通职员、好闺蜜、管理者三种角色来举例。表达了换位思考无论是在工作中还是在生活中都发挥着重要的作用。作者还提到了换位思考的深度，这一点我的体会很明显，以前的换位思考都是基于自己想当然的去思考。没有真正的站在对方的角度，也可以说是站在自己的角度换位思考。这样的换位思考缺点很明显。很容易出现思考的偏差，然后做出错误的决定。<br>作者在本节中还说到，换位思考在从前作为一个人生活和交际的能力出现，到现在随着社会的进步，已经成为了职场人士基本能力不可或缺的一部分。比如产品岗位、运营岗位、设计岗位等，越来也多的岗位都需要深度的换位思考才可以做好。</p>\n<h3 id=\"2-1-进入别人的视角（上）\"><a href=\"#2-1-进入别人的视角（上）\" class=\"headerlink\" title=\"2.1 进入别人的视角（上）\"></a>2.1 进入别人的视角（上）</h3><p>本节举了很多的案例，表达了换位思考的方式和前提。换位思考的方式是需要在思考之前进入别人的视角，然后得出结论。而不是带着自己想当然换位思考的结论再去别人的视角。在换位思考的前提上，需要和被换位的人保证大致相同的认知，如果认知不一致同样会造成截然不同的思考结果。这在「美国作家」的案例中表现的很明显。在换位思考的技巧上，作者提到，如果自己有着被换位者相似的经历，那么可以去尝试着回忆这段经历，带着这段记忆来换位思考有助于思考的结果更加准确。但是这种方式也有缺点，那就是人一旦脱离了曾经的环境，即使自己有过相似的经历，靠回忆也很难完全的身临其境的去换位思考。<br>通过这一节的学习，收获挺大，至少在生活中我知道了如何去更准确的换位思考，而不是去做一些想当然无意义的思考。</p>\n<h3 id=\"2-2-进入别人的视角（下）\"><a href=\"#2-2-进入别人的视角（下）\" class=\"headerlink\" title=\"2.2 进入别人的视角（下）\"></a>2.2 进入别人的视角（下）</h3><p>本节接上节「进入别人的视角（上）」的内容作了解决方案的分析。面对这么多换位思考的要求，作者给了两种练习方案。</p>\n<ol>\n<li>刻意练习，在平时看到同时、家人遇到什么事情时，尝试着让自己站在对方的角度去思考看看怎么处理，然后对照着对方真实的处理方式去优化。这样的训练需要不断的坚持和刻意练习，否则在遇到事情时很容易无意识的忘记训练。</li>\n<li>抽离感。在自己做某件事情的时候，尝试着以一个旁观者的身份看自己。比如自己在写代码，和别人讨论，工作的时候，试想着自己是一个旁观者在看着自己写代码，和别人讨论，工作。这样的目的同样是为了练习自己的换位思考能力，可以让自己更加客观的看待正在经历的事情。避免以自我为中心所引起的判断偏差。</li>\n</ol>\n<p>换位思考最大的克星就是以自我为中心的思考方式，这种方式本没有错，因为这是人类的本性之一。那么为了做到更准确的换位思考，就需要让自我为中心思维的影响尽量的小。这也是以上 2 个练习方式的根本目的。</p>\n<h3 id=\"2-3-六顶思考帽\"><a href=\"#2-3-六顶思考帽\" class=\"headerlink\" title=\"2.3 六顶思考帽\"></a>2.3 六顶思考帽</h3><p>六顶思考帽分别代表着六种思维特质的人，在大部分的场景，我们往往无法找到 6 种不同思维特质的人来帮助我们进行思考。所以，六顶思考帽的思维方式就是让我们自己通过上面提到的换位思考，去扮演 6 种不同思维特质的人去思考一个问题。让问题的思考更加全面。<br>六顶思考帽代表着不同的视角，他们分别是：</p>\n<ol>\n<li>蓝色 - 蓝色思考帽负责控制和调节思维过程。负责控制各种思考帽的使用顺序，规划和管理整个思考过程，并负责做出结论。</li>\n<li>白色 - 白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。</li>\n<li>红色 - 红色是情感的色彩。戴上红色思考帽，人们可以表现自己的情绪，人们还可以表达直觉、感受、预感等方面的看法。</li>\n<li>黄色 - 黄色代表价值与肯定。戴上黄色思考帽，人们从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。</li>\n<li>绿色 - 绿色代表茵茵芳草，象征勃勃生机。绿色思考帽寓意创造力和想象力。具有创造性思考、头脑风暴、求异思维等功能。</li>\n<li>黑色 - 戴上黑色思考帽，人们可以运用否定、怀疑、质疑的看法，合乎逻辑的进行批判，尽情发表负面的意见，找出逻辑上的错误。</li>\n</ol>\n<p>六顶思考帽的应用场景主要分为两种，一种是个人使用，一种是会议中多人使用。<br>在个人使用时，我们可以随意一些，根据事情的重要程度，选择性使用某些帽子即可。越重要的事情，越建议使用更多的帽子来思考。<br>在会议中多人使用时，使用方式会有一些不同。在讨论一个事情的时候，需要每种帽子都出场进行思考，同时，需要会议中的所有的人在同一时间扮演同一个帽子。这样的目的，是让不同观点的人，能够在同一时间为同一个方向思考，避免出现因观点不同而导致无休止的争论。<br>总的来说，六顶思考帽是一种以换位思考为基础的综合性思维训练模式。就我个人而言，我对这种思考方式很感兴趣，但是我也知道，想要思考全面，光用这种方式是不够的。这种方式需要不断的练习和训练，来提高思维的深度和广度，在这种思考方式的训练下，可以有效的缓解一个人各项思维特质不平衡的问题。如果运用得当，六顶思考帽将会带来很大的收益。</p>\n<h3 id=\"2-4-一个完整的使用案例\"><a href=\"#2-4-一个完整的使用案例\" class=\"headerlink\" title=\"2.4 一个完整的使用案例\"></a>2.4 一个完整的使用案例</h3><p>本节以一个「广告行业的工作选择」的案例，描述了主人公在面临老家和深圳两地的广告业工作的选择中，如何从最开始的迷茫，不知所措。到后来通过六顶思考帽完整的梳理优缺点，合理做出决策的过程。这个过程给出了在个人的场景中，六顶思考帽该如何使用，遇到思维混乱的时候该如何解决以及如何控制帽子的出场顺序。<br>通过这一节的学习，我对六顶思考帽的使用方式有了一个大致的概念。有了这个案例的帮助，使得后续我在练习使用这个参考的过程中，避免进入思考误区之中。</p>\n<h2 id=\"三、可视化思维\"><a href=\"#三、可视化思维\" class=\"headerlink\" title=\"三、可视化思维\"></a>三、可视化思维</h2><h3 id=\"3-1-不可不知的大脑原理\"><a href=\"#3-1-不可不知的大脑原理\" class=\"headerlink\" title=\"3.1 不可不知的大脑原理\"></a>3.1 不可不知的大脑原理</h3><p>本节讲述了一些计算机的基础知识，并把计算机和大脑的思考方式进行了对比。得出计算机的「草稿纸」很大，可以容下大量的信息。而人脑的「草稿纸」很小，一个人平均的工作思维「草稿纸」的大小为 4 个信息单元，超过 4 个信息单元就会容易记不住导致思考不过来。这个时候就需要借助外部工具来辅助思考。</p>\n<h3 id=\"3-2-矩阵分析法\"><a href=\"#3-2-矩阵分析法\" class=\"headerlink\" title=\"3.2 矩阵分析法\"></a>3.2 矩阵分析法</h3><p>本节列举了矩阵思维的通用特性，矩阵思维的优势在于将人的思维从一维拓展到了二维，从二维的角度让思维更加清晰。作者拿出了矩阵思维的几个特例分析了起优势和劣势。这几个矩阵思维分别是：</p>\n<ol>\n<li>安索夫矩阵 - 用于企业发展战略，以市场渗透、市场开发、产品延伸、多远经营 4 个维度分析。</li>\n<li>艾森豪威尔矩阵 - 重要且紧急、重要不紧急、紧急不重要、不紧急不重要 4 个维度   </li>\n</ol>\n<p>分析之后，这两种矩阵不太适合现代工作的场景，特别是针对拖延症患者来说。不适合主要体现在两点，其一为工作信息多元化，很多工作难以衡量出重要或者不重要，紧急或者不紧急，导致维度划分困难，或者不准确。其二为对于拖延症患者来说，重要、紧急两个维度，并不能帮助拖延症做出准确判断，帮助拖延症尽快执行具体的任务。所以，作者自己创立了一种矩阵思维：「策略师矩阵」，适用于现代工作的年轻人和拖延症患者。<br>策略师矩阵主要分为四个维度：重要且容易、重要且不容易、不重要且容易、不重要且不容易。<br>策略是矩阵的指导思想是：优先做容易的事情。容易的事情先做，能够有效避免拖延症所导致的事情越累积越多。这一点对我来说深有体会，我个人就是一个中度拖延症，所以后续我也会尝试使用这种思维方式来缓解。</p>\n<h3 id=\"3-3-工作仪表盘\"><a href=\"#3-3-工作仪表盘\" class=\"headerlink\" title=\"3.3 工作仪表盘\"></a>3.3 工作仪表盘</h3><p>工作仪表盘就像一个中控系统一样，将你所关心的信息都呈现在上面。其核心的原理就是将重要的信息归纳到一起，让自己只需要关注仪表盘，而不用分散思维去想每个单独的重要信息。本节列举了一些案例，比如司机、管理者、投资人家为什么要用仪表盘。以及在当下信息庞杂的时代，我们作为普通工作的个人，应该如何使用仪表盘。作者自己发明了一个6个区域的仪表盘思维，来解决作者平日生活的问题。<br>通过本节的阅读，我发现目前我正在使用的「看板」工具管理个人的安排和计划。其实也可以说成是工作仪表盘的一种，对于我们这样的互联网行业从业者，电脑比便签更加方便和快捷。工作仪表盘不比注重于形式，最重要的是适合自己，所以，下去我将会根据本节的案例再对我「看板」上的工作仪表盘做一次优化。</p>\n<h2 id=\"四、流程思维\"><a href=\"#四、流程思维\" class=\"headerlink\" title=\"四、流程思维\"></a>四、流程思维</h2><h3 id=\"4-1-秘籍型思维的谬误\"><a href=\"#4-1-秘籍型思维的谬误\" class=\"headerlink\" title=\"4.1 秘籍型思维的谬误\"></a>4.1 秘籍型思维的谬误</h3><p>本节作者列举了许多的例子来证明秘籍型思维所产生的误导。秘籍型思维产生误导的核心原因是因为，秘籍型思维中的秘籍在事情当中往往能够产生作用，秘籍型思维会将秘籍所产生的作用无限放大，比如一个人的成功，「情商高」和「会说话」都很重要，但在「成功」的整个事件中，可能只占到一成，更多的还需要其他的因素，比如对市场准确的判断，对产品和用户有着准确的认知以及强大的协调和管理能力等等。但是秘籍型思维会告诉我们，「情商高」和「会说话」在其中占到 5 成，甚至更多。这会导致我们在盲目跟风之后，或许达不到想要的结果。<br>总结一下，通过本节的学习，让我知道很多生活中的秘籍型思维应该被警惕。理智的分析，才能让自己的决策更加准确。</p>\n<h3 id=\"4-2-全流程优化\"><a href=\"#4-2-全流程优化\" class=\"headerlink\" title=\"4.2 全流程优化\"></a>4.2 全流程优化</h3><p>本节作者讲述了全流程的概念，和全流程优化所带来的收益。其收益高的主要原因是因为流程复杂，导致各个环节一般都有可提升空间，那么如果复杂的流程每个环节都提升了，哪怕提升的幅度很小，一条链路乘算起来的收益也很大。所以全流程优化如果能做好，是很有价值的，也很有必要去做的。<br>通过本节的阅读，我个人的感想其实全流程也许很多时候并没有那么理想。首先，很多事情、行业，基于当下的流程，要优化个 10% 出来其实已经很难很难了。可能需要投入的 100% 的精力投入。虽然作者提到，投入的精力多很正常，投入加算，收益乘算，但其中还是有一个阀值，当投入超过某个点过后，就会出现流程化的收益无法超过投入，这里面甚至还有时间成本，很多流程转化率会随着时间有所衰减。<br>没有那么理想并不代表流程化思维没用，其实在我个人的很多事情当中，还是有很大优化空间的。我可以使用全流程优化的思想去解决生活中的一些问题。</p>\n<h3 id=\"4-3-识别流程的类型与结构\"><a href=\"#4-3-识别流程的类型与结构\" class=\"headerlink\" title=\"4.3 识别流程的类型与结构\"></a>4.3 识别流程的类型与结构</h3><p>流程的类型主要分为两种：连贯性流程、顺序性流程。他们分别代表着前后关系大和前后关系不大的两种情况。这两种流程在我们生活中比比皆是。全流程优化能起到质变作用的是连贯性流程，但同样，连贯性流程也承载着巨大的风险。作者还将流程分为串联和并联，并联流程具有较高的稳定性。<br>从全流程优化来说，我们不可能做到真正的全流程优化，因为时间精力有限，我们总是会选择成本最少，收益最高的先优化。那么如何选择，作者在本文中是这么介绍的：在策略师时间矩阵中，越容易的事情和越重要的事情会先做。所以连贯性流程的优化一定是从容易和重要入手。而对于复杂混合型流程，除了容易、重要这两个基本信息之外，还需要分析每个环节的扩散度。做出准确的分析之后，再决定优化哪个环节。<br>全流程优化是一项具有挑战的过程，通过本节的阅读之后，我了解到全流程优化并不是那么简单，挨着坐就行了。里面需要带有更加深度的分析，来决定先做什么后做什么，哪些做，哪些不做。</p>\n<h2 id=\"五、生态思维比个体力量更强大的是生态\"><a href=\"#五、生态思维比个体力量更强大的是生态\" class=\"headerlink\" title=\"五、生态思维比个体力量更强大的是生态\"></a>五、生态思维比个体力量更强大的是生态</h2><p>从第五章开始，《深度思维》一书进入下篇 - 思维的格局。</p>\n<h3 id=\"5-1-生态思维的基础原理\"><a href=\"#5-1-生态思维的基础原理\" class=\"headerlink\" title=\"5.1 生态思维的基础原理\"></a>5.1 生态思维的基础原理</h3><p>本节以多个案例从浅至深正面印证了生态思维的重要性。生态思维，指的我们在思考一个问题或者一个事情的时候，应该去思考这个这个问题的生态系统是怎样的，这个生态系统是如何影响这个问题的。应该避免“出淤泥而不染”的思维方式，而改变为“如何让淤泥变少”。人总是会受到周边的环境影响的，而环境又受生态影响。所以生态总是不断的影响生态中的事物。生态思维的核心，就是通过深度的换位思考来感受事物在其中受到的影响，进而做出准确的判断。本节中案例大多偏向企业、游戏主播等具有一定规模的事业，在大型决策上生态思维所产生的作用，下一篇会将在个人的情况中，生态思维应该如何产生价值。<br>通过本节的阅读，我对生态思维有了更加全面的理解。</p>\n<h3 id=\"5-2-衍生模型1：淘金模型\"><a href=\"#5-2-衍生模型1：淘金模型\" class=\"headerlink\" title=\"5.2 衍生模型1：淘金模型\"></a>5.2 衍生模型1：淘金模型</h3><p>本节作者举了一个美国 19 世纪中前期加利福尼亚淘金的案例，在这个案例中，淘金所得的收益是非常诱人。所以随着时间的推进，去淘金的人越来越多，如果这个时候你作为当时的一个普通美国人，你是否愿意去参与这次淘金？如果去，那么就需要承担去的风险，淘金的人那么多，不一定能淘到。并且就算能淘到，淘到一些金沙的收益比起不去直接在原处工作也不会好多少，甚至持平。如果不去，那么也许你会后悔一辈子，万一淘到金块了呢。其实大部分人纠结的点都在去或者不去，有冒险精神的也许会选择搏一搏。但作者在这个案例中，给出的答案是：去，但是不是去淘金，而是去卖牛仔裤。\b看到这个答案的时候，我突然顿悟好像确实是这样，在这个案例中，淘金作为聚焦的点，吸引了大部分人的目光和思考的范围。却很少有人关注淘金的生态，在淘金的人大幅度增多时，必定会影响淘金生态的一系列东西，牛仔裤只是其中一个思路，比如淘金工具，一些日常配备等等都是很有价值空间的。<br>在这一节中，作者还举了一个个人场景下使用淘金模型的案例。不过我认为这个案例的适用性不是特别大。所以就不做过多详述了。总的来说，通过本节的阅读，我认为，生态性思维的核心是要跳出事物本身，去关注其生态对其带来的影响。以更大的视角来分析问题，以获得更好的结论。</p>\n<h3 id=\"5-3-衍生模型2：森林模型\"><a href=\"#5-3-衍生模型2：森林模型\" class=\"headerlink\" title=\"5.3 衍生模型2：森林模型\"></a>5.3 衍生模型2：森林模型</h3><p>森林模型，类比着人在社会生态中的定位。其核心在于，找到自己的定位，不断努力进化。作者以森林举例，将那些资源丰厚的巨佬比喻为虎和狼，将我们这样的普通人比喻为兔子。虎和狼占据着森林的中央，而兔子则在森林边缘的草地生存。<br>一些鸡汤告诉我们，普通人只要努力，足够的努力，加倍的努力，就可以在一个领域做到很精，成为这个领域的佼佼者，然后和那些强者一搏高下。但这毕竟是鸡汤，现实是，我们作为普通人，资质上和资源上都无法和那些强者比拼。试想一下，一个比你聪明，比你资源更丰富的人和你一样努力，在同样的轨道上，无疑会快你很多。当这样的人在你所在的团队中还不止一个的时候，你的竞争压力就会越来越大。很多时候，鸡汤总会拿那些弱势的强者来举例。但当我们真正努力到能够探及强者的世界的时候，你会发现，大部分强者也在努力，根据马太效应，即使你们是同样的努力，你们的差距也会越来越大。所以，作为普通人来说，不是每一个人都可以只靠努力，就可以达到领域内超顶尖水平的，达不到也并不是因为努力不够，而是因为综合的很多原因。那么，我们应该如何做呢。参考「森林模型」中的兔子，兔子如果想要通过不断进化，来打败老虎和狼，进而获得生存空间，可以发现，基本是不可能的，但是如果兔子改变想法，选择不与老虎和狼直接竞争，而是避开他们，提升自己的移动速度和繁殖能力，在森林的边缘找到自己的生存空间。这也未必不是一条好的生存方式。再回到现实中去，普通人亦是如此，不是每个普通人都可以成为商业巨佬，也不是每个人都可以成为清华北大的优质学生。大部分的普通人都是「兔子」，所以案例中「兔子」的生存之道，更适合于我们。当然如果你是一名强者，去和其他强者们竞争一下，也是一个不错的选择。<br>森林模型的误区在于，在面对强者的时候，解决问题的方式并不只是避开。而是避开的同时，提升自己的能力，找到自己的生存空间。<br>通过本节的阅读，结合我自身的情况，森林模型的内容给了我一些启发，让我在后续的人生思考中有了新的角度。</p>\n<h3 id=\"5-4-衍生模型3：池塘模型\"><a href=\"#5-4-衍生模型3：池塘模型\" class=\"headerlink\" title=\"5.4 衍生模型3：池塘模型\"></a>5.4 衍生模型3：池塘模型</h3><p>池塘模型，也可以理解成「平台模型」，其核心在于，在自己一定有了一定成绩之后，面对市场的竞争激励，发展瓶颈的困境时，如何改变思维格局，从平台的视角出发，自己从竞争者转变为平台拥有者所带来的收益。本节作者以一个游戏主播的案例，说句题外话，虽然作者没说出这个主播的名字，但是我知道是谁，他就是「伍声2009」，浙大的传奇人物。回归正题，在这个案例中，当事人主播由于之前的淘金模型，通过淘宝店赚了一些钱，粉丝也积累了很多。但是那一类游戏玩家的数量有限，随着更多的游戏主播涌入，对直播热度和淘宝店的销量都是一大波冲击，他的发展也进入了瓶颈期，在这个时候，他改变了思维，将自己变成一个平台，去招募一些新入有潜力的中小主播，往往这样的中小主播，不具备一整套流量变现的体系，所以他的平台提供了这么一套变现运营体系，只要中小主播愿意加入，也能够赚取比他们当下更高的收益。而他的平台则可以在其中进行抽成。在这个案例中，他改变了思维的格局，从竞争者变成了平台，从而获取了较大的利益。<br>通过本节的阅读，我认为池塘模型应用的基础在于自己的实力已经不错，且有一些不错的资源。在这样的基础上，通过池塘模型的思维来思考，也许会给自己带来新的思路。</p>\n<h3 id=\"5-5-本章结语\"><a href=\"#5-5-本章结语\" class=\"headerlink\" title=\"5.5 本章结语\"></a>5.5 本章结语</h3><p>生态思维是后续文章的基础，其目的在提高宏观思维能力，即思维的格局。宏观思维能力最核心的要求就是不要将你的视角聚焦在事物本身。需要去关注事物的环境、生态对其带来的影响。<br>宏观思维能力更加精彩，也更加难学，更加难以运筹帷幄。这样的思维方式，会让你在人生中的思考更加全面，更加有力。</p>\n<h2 id=\"六、系统思维在更高的层面上解决问题\"><a href=\"#六、系统思维在更高的层面上解决问题\" class=\"headerlink\" title=\"六、系统思维在更高的层面上解决问题\"></a>六、系统思维在更高的层面上解决问题</h2><h3 id=\"6-1-线性逻辑的局限\"><a href=\"#6-1-线性逻辑的局限\" class=\"headerlink\" title=\"6.1 线性逻辑的局限\"></a>6.1 线性逻辑的局限</h3><p>本节列举了很多案例，证明线性逻辑在一些特殊的场景下应用时，并达不到很好的效果。什么是线性逻辑，就是在本书中前面所介绍的一些思维工具和方法。我们在遇到问题时，并不是所有的问题都可以用这些方法很好的解决。线性逻辑的局限，正是在讲那些线性逻辑不好解决的问题。<br>本节的案例我看了之后没有什么感觉，这些案例似乎用上一节的生态思维去思考更为合适，但案例中使用的是线性逻辑。所以导致解决效果不好。</p>\n<h3 id=\"6-2-重新认识因果\"><a href=\"#6-2-重新认识因果\" class=\"headerlink\" title=\"6.2 重新认识因果\"></a>6.2 重新认识因果</h3><p>本节的内容比较抽象，同样是以两个详细的案例来讲述因果。在这两个案例中有一个共同点，就是因为一个线性逻辑分析出来的决策，所导致了一个恶性循环。这个循环是毁灭性的，触发条件也可能是正常事件或者偶然事件。在我看来，其实这是换位思维和生态思维运用不到位的表现。两个案例中，都只就问题而展开的分析和决策，并没有去换位思考和进行生态性思考，导致决策造成了意向不到的影响。而这个决策在这种影响之下，愈演愈烈，最终导致混乱。<br>通过本节的阅读，我认为本节其实这是一个换位思维和生态思维的加强说明的一节，突出我们面对一个问题，在其影响面较大的时候，一定要经过缜密的分析和换位思考，切忌仅在自我视角，这样再厉害的思维能力也会造成意想不到的问题。</p>\n<h3 id=\"6-3-系统的非常规特性\"><a href=\"#6-3-系统的非常规特性\" class=\"headerlink\" title=\"6.3 系统的非常规特性\"></a>6.3 系统的非常规特性</h3><p>本节将前面两节的案例做一个归纳和总结，总结出其中的共同点。系统思维不能以常规逻辑思维来分析，比如 1 个人的工作效果是 100% ，2 个人的工作效率不一定是 200% 。有可能更高，也有可能更低。这是最简单的系统思维。<br>通过本节的阅读，我发现其实逻辑思维是系统思维的一种特例，即在基本逻辑思维中，任务分解的粒度之间独立，联系较小，影响较小。这才可以让逻辑思维分析之后的变得更加清晰，但这也失去了系统思维中对关联性的判断。</p>\n<h3 id=\"6-4-从更宏观的角度解决问题\"><a href=\"#6-4-从更宏观的角度解决问题\" class=\"headerlink\" title=\"6.4 从更宏观的角度解决问题\"></a>6.4 从更宏观的角度解决问题</h3><p>本节将前面几节的案例进行了分析，并给出了解决方案。作者根据前面所绘制的系统动力图，分析出，哪些点是可以被改变的，哪些点是不能改变的，哪些点是需要控制的。通过对系统动力图的分析和改造，最终决定出解决方案。这个解决方案也许在有的时候是匪夷所思的，根据普通线性逻辑思维可能无法推论出解决方案的合理性。但在系统思维中，它影响着多个节点，最终使得整个系统的运作流程和机制变更，以达到解决问题的目的。作者还总结道：往往可以被改变和控制的节点，都不是物理世界所注定的那些死的定律。而是那些较为感性的东西，比如信念、情绪、思维方式。<br>通过本节的阅读，我感觉要绘制出一个正确的系统动力图是宏观角度解决问题的核心。很多时候，我们分析可能不够全面，导致系统动力图不准确，从而影响决策。在分析到位的情况下，才可以根据动力图的节点来改变流向，进而影响系统的运作，解决问题。</p>\n<h3 id=\"6-5-良性循环是怎样构造出来的\"><a href=\"#6-5-良性循环是怎样构造出来的\" class=\"headerlink\" title=\"6.5 良性循环是怎样构造出来的\"></a>6.5 良性循环是怎样构造出来的</h3><p>前几节都是以系统思维去分析的几个负面的例子。本节列举了两个正向的例子，告诉我们应该如何去运用系统的正向循环。如何去构造一个良性循环的系统，这里，作者拿我们个人的生活举例。如果把业余时间用于提升自己作为前提，以构建一个良性循环。当然这个良性循环到一定程度会衍生出一些其他的因素来平衡，使得这个良性循环并不是无限受益并放大的。<br>通过这一节的阅读，我对系统思维有着更深入的理解，其实在生活中，很多时候我们都没有去分析我们所在系统的动力图，导致有的决策考虑的不够深入，无法预测其影响。在个人系统动力图中，我很认可作者的观点，我个人正在经历这个看似良性的循环，\b希望我可以继续坚持下去。</p>\n<h3 id=\"本章结语\"><a href=\"#本章结语\" class=\"headerlink\" title=\"本章结语\"></a>本章结语</h3><p>系统思维是生态思维的一种特殊形式，由于有更复杂的逻辑，所以单独列出来。<br>作者：系统思维能以精深的智慧评估形势，以大胆、反常的行为开创局面。它将我们的格局和境界带到高远的地方，如同云端之神俯视大地。</p>\n<h2 id=\"七、大势思维与天地同力的思维方式\"><a href=\"#七、大势思维与天地同力的思维方式\" class=\"headerlink\" title=\"七、大势思维与天地同力的思维方式\"></a>七、大势思维与天地同力的思维方式</h2><h3 id=\"7-1-时来天地皆同力\"><a href=\"#7-1-时来天地皆同力\" class=\"headerlink\" title=\"7.1 时来天地皆同力\"></a>7.1 时来天地皆同力</h3><p>本节列举了许多的案例来证明趋势的重要性，无论个人多厉害，有多么充足的资源和能力。在违背趋势的情况下，这些个人的东西，显得那么苍白无力。其实，这也是「选择比努力更重要」的一种侧面证明。我们需要顺应趋势，无论是工作还是生活，这是我们的生存之道。<br>通过本节的阅读，我的感触很深，以前的我，经常会把精力投入到那些我热爱的东西。而这些东西往往不是顺应趋势的。所以，在经过很大的努力之后，收效甚微，甚至很多时候都是用爱发电。我们可以美其名曰为了自己的信仰，可现实很残酷。最终违背趋势的信仰也会逐渐消亡，而我，也会成为踏入趋势潮流中的一员。</p>\n<h3 id=\"7-2-抓住趋势的本质\"><a href=\"#7-2-抓住趋势的本质\" class=\"headerlink\" title=\"7.2 抓住趋势的本质\"></a>7.2 抓住趋势的本质</h3><p>本节作者讲述了「趋势」和「风口」的区别。一个趋势必定会造出很多风口。但风口不等于趋势，他们的内在区别是趋势是有强有力、且充足的内在规律可循的。而风口，可能是一些人创造出来了，在近几年，有无数的风口成为了趋势，也有无数的风口消逝了。所以趋势的本质就是内在的规律。<br>通过本节的阅读，我认为趋势的本质虽然触发和造就了趋势，但是作为一个普通人来说，很难洞悉出一个趋势的全部本质。不完整的分析，是对我们造成判断偏差的重要因素之一。   </p>\n<ul>\n<li>趋势，是因为某种内在规律而导致的未来的大概率或者必然走向。</li>\n</ul>\n<h3 id=\"7-3-能够创造趋势的强大规律\"><a href=\"#7-3-能够创造趋势的强大规律\" class=\"headerlink\" title=\"7.3 能够创造趋势的强大规律\"></a>7.3 能够创造趋势的强大规律</h3><p>“凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来。”——《新约·马太福音》   </p>\n<p>本节的内容很长，从开始的马太效应，到后来的如何创造大势思维，每个重要的观点，都配有很多代表性的案例。其中，核心的主要有两个：马太效应和人口规律。这两个点的效果很强大，强大到可以推翻其他规律所造成的影响。在我们决策当中体现为：请在决策是，以这两个定律为第一优先级。<br>作者还谈到大势思维的真正瓶颈，真正的瓶颈是通过一些趋势的分析，我们所得到的和大家所得到的是一致的，我们无法想到那些别人想不到的，而往往只有这样的信息才更有价值和机会。这也是让很多人面对大家所通识的大势之时，即使知道其影响，也会忽略的原因。<br>通过本节的阅读，让我对许多规律和有了新的认知，特别是在马太效应上，如何成为马太效应的收益一方，是一直所需要思考和执行的。</p>\n<h3 id=\"7-4-大势训练场\"><a href=\"#7-4-大势训练场\" class=\"headerlink\" title=\"7.4 大势训练场\"></a>7.4 大势训练场</h3><p>本节作者描述了我们应该如何训练大势思维。大势思维并不是独立存在的，他需要和其他的思维方式一起思考，无论是系统、生态思维，还是逻辑性思维里面的 5 why，5 so 思考法。都可以与之结合。而深度思维的常态，正式这些多种逻辑性思维和生态、大势思维结合使用。 面对复杂的现实世界，多种思维方法综合应用才是制胜之道。<br>通过本节的阅读，我认为更多的实践才能真正训练自己的思维能力，本书的思维方式主要是抛砖引玉。更多的需要我们做实际，通过不断的思考，来提升思考的价值和效率。</p>\n<h3 id=\"本章结语-1\"><a href=\"#本章结语-1\" class=\"headerlink\" title=\"本章结语\"></a>本章结语</h3><p>作者：在本章最后，让我们感叹并铭记趋势的恢宏与磅礴吧！所谓时来天地皆同力，运去英雄不自由。大势若至，神鬼难敌；乘风踏浪，顺势为王。</p>\n<h2 id=\"八、兵法思维如何设计自己的人生胜负手\"><a href=\"#八、兵法思维如何设计自己的人生胜负手\" class=\"headerlink\" title=\"八、兵法思维如何设计自己的人生胜负手\"></a>八、兵法思维如何设计自己的人生胜负手</h2><h3 id=\"8-1-为什么你要懂点兵法思维\"><a href=\"#8-1-为什么你要懂点兵法思维\" class=\"headerlink\" title=\"8.1 为什么你要懂点兵法思维\"></a>8.1 为什么你要懂点兵法思维</h3><p>人生如战争，对于那些没有背景，家境普通的人来说，社会竞争的激烈让我们不得不得像打仗一样。所以兵法思维其意在让我们在这场激烈的竞争中获得优势。通过兵法思维设计自己的胜负手，并通晓兵法之道，无论遇到任何事情，都能应对自如，做出最优决定。<br>作者本章力推《孙子兵法》中的兵法之道，选取了孙子兵法中可以在现代社会中运用的很好的部分，加以详述。</p>\n<h3 id=\"8-2-先胜后战\"><a href=\"#8-2-先胜后战\" class=\"headerlink\" title=\"8.2 先胜后战\"></a>8.2 先胜后战</h3><p>胜兵先胜而后求战，败兵先战而后求胜。——《孙子兵法·军形篇》<br>先胜后战理论的目的是告诉我们，在做任何事情之前，先要去思考如何取胜。虽然在很多事情，比如创业、投资之类的，很难去想到如何取胜。但这并不妨碍我们做事情之前去思考，以确保提升胜率。<br>本节提到了一个误区，很多人以为自己已经理解先胜后战了。但是在我们真实的生活中，有太多太多的事情不需要我们去思考如何先胜后战，比如逛街、外出吃饭等等琐事。如果没有养成这样的习惯，那么我们很难在真正需要严谨先胜后战的场景分析的很全面。<br>通过本节的阅读，我认为先胜后战是一种理念，提醒着我们在做一些关键事情之前，需要进行先胜后战的思考。确定最大成功率，再去执行。而这样的思维，并不是想的时候用，而是需要平时多加训练，才能提高其效果。</p>\n<h3 id=\"8-3-致人而不致于人\"><a href=\"#8-3-致人而不致于人\" class=\"headerlink\" title=\"8.3 致人而不致于人\"></a>8.3 致人而不致于人</h3><p>善战者，致人而不致于人。 ——《孙子兵法·虚实篇》<br>本节所有的案例和理论都围绕这这句话来说。其意为我们的决策不能让自己陷入两难的境地，或者说，如果别人为我们设置了两难的陷阱，但我们的选择应该去避免。这一节的核心思想很抽象，要在实际中应用似乎很难，而且具有争议性。那么到底如何使用呢，我的理解是我们在面临选择或者作出决策的时候，应该充分使用逻辑思维分析出利弊，这种利弊是更加全局的，不只是针对自身。有了更加全局的分析，才能作出更加正确的选择。</p>\n<h3 id=\"8-4-胜可知，不可为\"><a href=\"#8-4-胜可知，不可为\" class=\"headerlink\" title=\"8.4 胜可知，不可为\"></a>8.4 胜可知，不可为</h3><p>胜可知，不可为。我们总是在担心未来，总是在焦虑。面对生活中处处的对比，他人的成功，我们的耐心越来越小。有太多太多的人，不愿意等待，或是在等待的过程选择自甘平庸或一次无把握的赌博。无论是自甘平庸或者无把握的赌博，迎接来的都是残酷的现实，没有一丝怜悯。<br>胜可知，不可为，讲述的是无论是战争，还是人生，成功一直都不取决于自己，而取决你的对手。我们无法控制对手，无法预知天机，无法掌控未来。我们只能做的是让自己不断变强，然后等待，等待着机会的来临。有很多人在等待的时候迷失了自我，做出了自以为正确，但不符合当下的决定。而本节就是告诉我们，思考，不应该以自我为核心，例如：我已经 30 岁了，还没有任何成就，所以我应该去闯一闯类似的理论。应该客观把握当下的机会，继续等待，提升自我，直到机会的来临。</p>\n<h3 id=\"本章结语-2\"><a href=\"#本章结语-2\" class=\"headerlink\" title=\"本章结语\"></a>本章结语</h3><p>作者：<br>先胜后战告诉我们不要莽撞盲目，先算清楚胜败再行动，凯利公式又为这一理念打上了数学补丁，让其更加具有可操作性。致人而不致于人让我们高瞻远瞩，不要等到情况变得显而易见、不可扭转才发现，而要见微知著，从一开始就不出现微小的差池，最典型的就是不要受制于人，要时刻掌握主动权。胜可知不可为则告诉我们，要敢于出击，更要能够等待，要搞清楚什么能做什么不能做，无仗可打的时候要耐得住寂寞。</p>\n<h2 id=\"九、慢即是快如果没有背景，缺乏资源，你该如何逆袭\"><a href=\"#九、慢即是快如果没有背景，缺乏资源，你该如何逆袭\" class=\"headerlink\" title=\"九、慢即是快如果没有背景，缺乏资源，你该如何逆袭\"></a>九、慢即是快如果没有背景，缺乏资源，你该如何逆袭</h2><p>作者：在这个鼓吹少年得志的时代里，我更崇尚大器晚成。对于出身平凡、缺乏资源、没有背景的人来说，专注做好一件事才是大概率的生存之道。慢即是快，这是技术，也是心法。    </p>\n<h3 id=\"9-1-你在羡慕别人的精彩人生吗\"><a href=\"#9-1-你在羡慕别人的精彩人生吗\" class=\"headerlink\" title=\"9.1 你在羡慕别人的精彩人生吗\"></a>9.1 你在羡慕别人的精彩人生吗</h3><p>本节介绍了跨界天才和斜杠青年的案例，案例中的主角总是那么耀眼，令人羡慕。我们每个人都有一个属于自己的主角梦，而往往这个梦想并不是那么简单就可以实现的。作者在本节中强调这样的梦想并不适合所有人，特别是没有资源、背景的人，甚至过度的模仿那些成功者的路线，会让我们功亏一篑。</p>\n<h3 id=\"9-2-没有背景、缺乏资源的人该如何逆袭\"><a href=\"#9-2-没有背景、缺乏资源的人该如何逆袭\" class=\"headerlink\" title=\"9.2 没有背景、缺乏资源的人该如何逆袭\"></a>9.2 没有背景、缺乏资源的人该如何逆袭</h3><p>专注，是普通人的最好出路。本节所有的都围绕这「专注」一次进行着。读下来，有一丝梦想终结者的感受。作者否定了事业的多元化发展，表达了想要多个领域都做到优秀对普通人来说是一件不太可能的事情。同时，现实有很多这样的包装过的案例，诱导着我们，让我们认为斜杠青年才是我们的目标。<br>通过本节的阅读，我认为对于事业的专注是必须的。多元化发展，则是锦上添花，这里的多元化发展并不是指的兴趣爱好。而是事业的多元化发展，这往往的确不适合普通人。</p>\n<h3 id=\"9-3-我的故事\"><a href=\"#9-3-我的故事\" class=\"headerlink\" title=\"9.3 我的故事\"></a>9.3 我的故事</h3><p>作者开始是一名普通人，也曾经梦想成为斜杠青年，跨界人才。但经过长达多年的努力之后，效果甚微。这时，他迷茫、困惑。之后他放弃了许多自己研究的领域，开始专注思维和学习的研究。专注之后不久就有了效果。再后来，他持续专注这两个领域，并获得了较高的成就。<br>作者的故事，再次强调了专注的重要性。对于普通人来说，专注是也许是唯一的出路。本节的末尾，作者提到，如果你一直专注，一直努力，并且方向也没选错，可当下效果还是不好，该怎么办。他提到了精神图腾，也许作者想用这样的方式一直激励着自己前进吧。</p>\n<h3 id=\"9-4-送你一个精神图腾\"><a href=\"#9-4-送你一个精神图腾\" class=\"headerlink\" title=\"9.4 送你一个精神图腾\"></a>9.4 送你一个精神图腾</h3><p>本节的内容给了我极大的震撼。作者花了很大的篇幅来讲解司马懿的一生，这一生是非常极端的，在剧情里，司马懿专注了接近 50 年，才达到了自己的目的，他受到了太多非正向，不公平的待遇。换成我们正常的思维，早已无法坚持下去了。而作者将司马懿的故事作为精神图腾，其意在不断的激励我们进步，无论在任何时候，都不要放弃。<br>本节的精神图腾可能不太适合我，我的目标和人生观与这样的精神图腾有一些区别。我能感受到本节作者的文字变得缥缈起来，像是寓意着本书的终结和作者的未来。</p>\n<h3 id=\"本章结语-本书结语\"><a href=\"#本章结语-本书结语\" class=\"headerlink\" title=\"本章结语/本书结语\"></a>本章结语/本书结语</h3><p>作者：<br>你我都在命运的局中出生，但谁会在樊笼里终老？《深度思维》讲述的不仅是思维的技术与格局，也是人生的策略和对平庸命运的抗争。    </p>\n<h2 id=\"我的结语\"><a href=\"#我的结语\" class=\"headerlink\" title=\"我的结语\"></a>我的结语</h2><p>至此，本书阅读完成。《深度思维》一书，带给了我无尽的思考。面对当下的迷茫，也许这本书的知识可以帮助我成长。我将继续与命运和现实抗争，感谢你，叶修。</p>\n","categories":["读书"]},{"title":"初识「数据分析」","url":"/2020/05/09/first-understanding-data-analysis/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在未来，无论是从事什么工作的人，数据分析的思维能力是必备的，初识数据分析，可以让我们了解数据分析的基础思维。在职场和生活中，这个能力可以让我们从数据中洞察出深层次的规律。学会数据分析思维能力，更能让我们脱颖而出。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>作者是一名程序员，最近才开始了解数据分析这一部分的知识，开始的时候，在网上搜索了一些资料进行阅读。但网络上的资料混杂，很难找到一个既简洁又官方的讲解，大部分的资料都是从某一个视角来讲解数据分析，给我一种 10 个人有 10 种数据分析方式的感觉。这对我这样新手来说，有些摸不着头脑。于是我将我最近阅读的一些数据分析的资料和文章进行归纳，输出了这篇文章。这篇文章的内容是我个人对数据分析基础的认知，抛砖引玉，希望能对你有所帮助。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、数据分析是什么\"><a href=\"#一、数据分析是什么\" class=\"headerlink\" title=\"一、数据分析是什么\"></a>一、数据分析是什么</h2><p>引用百度百科的一句话：</p>\n<blockquote>\n<p>数据分析是指用适当的统计分析方法对收集来的大量数据进行分析，将它们加以汇总和理解并消化，以求最大化地开发数据的功能，发挥数据的作用。数据分析是为了提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。   </p>\n</blockquote>\n<p>这句话很专业，也概括了数据分析的作用。通俗一点，数据分析就是从数据中获取信息，再将信息转换为价值。    </p>\n<h3 id=\"1-1-数据分析的作用\"><a href=\"#1-1-数据分析的作用\" class=\"headerlink\" title=\"1.1 数据分析的作用\"></a>1.1 数据分析的作用</h3><p>每一次数据分析都需要带有目的，所以我们可以把数据分析的作用和我们分析的目的结合起来分类。<br>根据我个人的理解，我将其主要分为以下几类：</p>\n<ul>\n<li><p>探索性分析<br>表示着这次数据分析的目的是探索。从已有的数据中找到一些特征点，根据特征点来推断出新的结论。比如：分析用户购物车数据，发现买了电脑的用户大部分都会购买键鼠套装。    </p>\n</li>\n<li><p>诊断性分析<br>表示这次数据分析的目的是诊断。一般用在发生一个事件之后，我们想找到这个事件的原因。这个事件可以是销量增长或下降、日活偶然增加或减少等等。</p>\n</li>\n<li><p>预测性分析<br>表示这次数据分析的目的是预测。一般用在分析一个事件所产生的的影响。比如：分析去年双十一的增长以预测今年的销量增长。   </p>\n</li>\n<li><p>验证性分析<br>表示这次数据分析的目的是验证。一般用在某一个产品功能更新之后，或者运营方案实行之后。对数据进行分析以验证是否和预期相符。</p>\n</li>\n</ul>\n<h2 id=\"二、数据分析流程\"><a href=\"#二、数据分析流程\" class=\"headerlink\" title=\"二、数据分析流程\"></a>二、数据分析流程</h2><p>网络上有许多各领域的数据分析流程，这里不做过多赘述。本节我主要以互联网产品的角度来谈一谈数据分析的基本流程。<br>在数据分析的流程开始之前，请确定本次数据分析的目的。即为：确定数据分析的类型，参考「1.1 数据分析的作用」。</p>\n<h3 id=\"2-1-数据采集\"><a href=\"#2-1-数据采集\" class=\"headerlink\" title=\"2.1 数据采集\"></a>2.1 数据采集</h3><p>顾名思义，数据采集就是从各个渠道获取数据。在当下的互联网产品中，一般数据的采集有三种方式：</p>\n<ol>\n<li>客户端自主研发埋点</li>\n<li>客户端接入第三方数据统计平台</li>\n<li>服务器访问日志/数据库数据</li>\n<li>爬虫采集</li>\n</ol>\n<p><strong>名词解释：</strong><br>埋点：通过在程序中插入代码的方式来实现对用户的行为、操作进行统计和记录。</p>\n<p>让我们来逐一分析每个方式的特点：</p>\n<ol>\n<li><p><strong>客户端自主研发埋点</strong><br>自研埋点是最准确也是定制化程度最高的一种数据采集方式。这种方式一般由产品经理/运营人员在版本发布之前，预先制定出需要埋点的位置。然后将埋点的位置交于开发人员研发后发布。<br>优势：准确，定制化程度很高，保证信息安全。<br>劣势：需要一定研发成本，且每次埋点都需要发布前提前埋点。（当然理论上技术层面也可以做到动态更改埋点，不过会极大程度提高研发成本，且受限于客户端的一些应用规则，效果不理想，具体原因不做详述）</p>\n</li>\n<li><p><strong>客户端接入第三方数据统计平台</strong><br>第三方数据统计平台采集本质也是埋点，只是省去了我们很大一部分的研发成本。接入第三方统计平台是目前对于中小型产品最方便快捷的方式，效果也不差。第三方统计平台一般功能强大，不光在数据采集上，一般会把后面的数据整理、分析步骤都有包含。这里主要介绍我所了解的两款平台：</p>\n</li>\n</ol>\n<ul>\n<li>GrowingIO<br>GrowingIO 在最开始接入的时候并没有什么问题。在传统数据采集都是通过代码埋点实现的情况下，其惊艳的动态配置埋点功能更是如虎添翼。前期在我们的产品中使用并没有什么问题。但好景不长，随着使用时间的增加，我们发现了以下问题：<br>① 其统计的数据并不准确，和我们通过其他方式统计的数据对不上。<br>② 接入 GrowingIO 的免费时间用完。需要收费，且费用不便宜。<br>③ 数据分析功能有一些需要收费，如果想拿到 GrowingIO 采集的数据，我们自己分析，也需要额外收费。<br>综合来说，GrowingIO 如果将数据统计做准确，那么就是除了贵啥都好了。</li>\n<li>友盟<br>友盟的接入就给了我一种不太好的印象，接入和使用并不算方便。不过好在在免费的数据统计产品中，友盟算很棒的了。所以中小产品接入友盟是一个不错的选择。</li>\n</ul>\n<ol start=\"3\">\n<li><p><strong>服务器访问日志/数据库数据</strong><br>通过这种方式的数据采集往往是通过固定的脚本，定期从日志或数据库中采集并计算出想要的信息。比如我们可以编写一个脚本，每天固定的时间计算出一个时段的访问量，活跃度，某些功能的使用频率等等。从信息安全的角度来说，一般的企业是不会允许生产数据被随意访问。即使访问也有很严格监控和审批流程。抛开安全性来说，服务器上的数据能满足的场景是有限的。有些数据需要在用户设备上才能采集。</p>\n</li>\n<li><p><strong>爬虫采集</strong><br>爬虫采集是一个数据采集的大类。市面上流行使用 Python 代码编写爬虫程序。它一般用于采集不受我们控制的数据，比如竞品的商品列表、竞品同期销售量等等。这些数据不在我们的系统中，也是我们正常手段无法统计到的。所以这个时候，「爬虫」出场了，这里不具体介绍爬虫的采集方式和技术手段，因为其细节很复杂，想了解的可以自行查阅相关资料。<br>爬虫采集对技术的要求较高，现在网络上大部分有自己数据的网站都有反爬虫策略，而爬虫就需要更加厉害的技术手段来实现数据爬取。这是一场技术的战争，将会随着时间的推移不断螺旋式的演进。</p>\n</li>\n</ol>\n<blockquote>\n<p>注：数据的采集方式可以多种混用，在分析之前，根据我们之前确定的数据分析目的而去选择所需的数据即可。</p>\n</blockquote>\n<hr>\n<p>上述内容只是从互联网产品的角度触发讨论数据采集。数据采集的方式多种多样，我们不必局限于此，如果我们的产品和新媒体运营有关，那么一些新媒体的阅读量、转化率等等也可以作为数据采集的一部分。如果我们的产品包含社群运营，那么用户活跃度、黏性等等也是同理。总而言之，只要是对我们数据分析目的有帮助的数据，都需要尽可能的设计方式去采集。</p>\n<h3 id=\"2-2-数据整理\"><a href=\"#2-2-数据整理\" class=\"headerlink\" title=\"2.2 数据整理\"></a>2.2 数据整理</h3><p>数据整理的过程，就像是对数据进行了一次净化。通过「2.1 数据采集」得到的数据往往是混杂的。数据来源于不同渠道，形式也是多种多样。这些数据往往多于我们做分析所需要的。<br>比如，我们需要分析的内容是本月的销量走势相比上个月怎么样。那么我们只需要本月的销量总额以及上月和本月每一天的销量数据即可。通过这些数据绘制出两张走势图，结果就会很明了。但往往我们所拿到的数据有很多，这些数据来源于不同的渠道，可能对于分析我们刚才的问题并没有什么作用，甚至还有一些脏数据。数据整理的过程就是将这些脏数据和无意义的数据都去掉。只留下对分析有帮助的数据。并将其汇总，方便下一步的分析工作。<br>整理过后的数据可以是一个文本文件、二进制文件、各种数据库资源、Excel 表格等等。</p>\n<h3 id=\"2-3-数据分析\"><a href=\"#2-3-数据分析\" class=\"headerlink\" title=\"2.3 数据分析\"></a>2.3 数据分析</h3><p>从上一步，我们已经拿到了对我们很关心的数据。那么数据分析这一步也是整个过程的核心。结合我们最开始数据分析的目的，通过这些数据计算出我们想要的指标，这些一个又一个的指标是我们得出结论的重要因素之一。<br>数据分析的形式同样也是多种多样，这里列举几类：</p>\n<ol>\n<li><strong>Excel 表格分析</strong><br>如果上一步的数据汇总是在一个 Excel 表格中进行的。那么也许直接用 Excel 表格进行分析会更加高效。Excel 有很强大的计算功能，可以根据你的指标计算需求写出公式，来达到你想要的结果。同时，Excel 的统计功能也很强大，只要你能将 Excel 玩的很溜，那么对于中小型的数据分析，Excel 也许是最适合的工具。</li>\n<li><strong>图表绘制分析</strong><br>图表分析的方式一般对分析者的代码和逻辑能力需要一定要求。图表的生成，需要将上一步的数据按照图表的维度进行处理，处理完成后再以图表形式输出。那么不会写代码就不能绘制图表了吗？其实也不是。网络上有一些可视化的数据分析工具，支持无代码自定义图表维度，设置好后输出。不过这样的方式还是会有一些局限性。自定义程度不高。如果要做一名高级数据分析师，算法和代码能力是必备的。</li>\n<li><strong>高阶数据分析</strong><br>高阶数据分析将会在下文「四、高阶数据分析」中进行介绍。这里列出来作为数据分析方式的一类。这一类往往定制化程度更高，难度也越大。</li>\n</ol>\n<h3 id=\"2-4-得出结论\"><a href=\"#2-4-得出结论\" class=\"headerlink\" title=\"2.4 得出结论\"></a>2.4 得出结论</h3><p>有了数据分析的结果之后，得出结论的过程就很简单了。结论的形式也有很多，可以是文档、可以是报表、可以是一篇总结等等。总之，结论就是将数据分析得出的结果归纳、推导和总结。</p>\n<h2 id=\"三、完整的案例\"><a href=\"#三、完整的案例\" class=\"headerlink\" title=\"三、完整的案例\"></a>三、完整的案例</h2><p>由于我只是一名初识数据分析的程序员，所以如果我来做一个完整的案例难免会有很多遗漏之处以及不准确的地方，于是我找了一些文章来做参考。</p>\n<ul>\n<li>产品经理角度的数据分析：<a href=\"https://36kr.com/p/5171146\">https://36kr.com/p/5171146</a>   </li>\n<li>代码（R 语言）数据分析简单案例：<a href=\"https://zhuanlan.zhihu.com/p/25428774\">https://zhuanlan.zhihu.com/p/25428774</a></li>\n<li>Excel 数据分析案例：<a href=\"https://zhuanlan.zhihu.com/p/39520206\">https://zhuanlan.zhihu.com/p/39520206</a></li>\n</ul>\n<h2 id=\"四、高阶数据分析\"><a href=\"#四、高阶数据分析\" class=\"headerlink\" title=\"四、高阶数据分析\"></a>四、高阶数据分析</h2><p>这里，我请教了我一位做数据分析的同学。从同学那里了解了一些高阶数据分析的流程和其所需要的能力。接下来我挨个介绍：</p>\n<ul>\n<li>高阶数据分析介绍<br>高阶数据分析和大数据分析有一定的相似性。一般需要去做高阶数据分析的企业都会有专业的数据分析师/建模师来做这件事情。其实说的通俗一点，高阶数据分析就是将普通数据分析的流程每一步都复杂化，主流程不变。</li>\n<li>高阶数据分析的应用场景<br>高阶数据分析一般应用在大型数据量、高度定制化、复杂的分析需求的场景。例如：美团接单优化、滴滴出行订单分配优化、大流量平台日志分析。<br>总之，就是很牛逼的数据分析就对了。</li>\n<li>高阶数据分析流程<br>这里用一张图来描述更加易懂。</li>\n</ul>\n<p><img src=\"/img/first-understanding-data-analysis/1.png\" alt=\"image\"></p>\n<p>这个流程是高阶数据分析里面较为简单的流程了。不过基本概括了高阶数据分析的流程。这里我主要把「数据分析」一步展开了，采集和整理都没有展开说明，其实真实的场景，大型数据的采集和整理还有很多讲究，这里就不做过多赘述了。数据建模、模型研发、数据模型化这些名词的解释我放在了下文。</p>\n<ul>\n<li>数据建模<br>我们都听说过数学建模，数据建模和数学建模有着一些相似性。根据我们数据分析的目的，普通的维度划分已经难以满足我们的需求了。所以需要建立数据模型，将多个维度以一种关联的形式混合在一起。一般专业的数据建模师会采用伪代码或者 R 语言来对模型进行描述，建模对算法能力的要求较高。</li>\n<li>模型研发<br>这一步比较容易理解，就是将上一步建好的数学模型用编程语言研发出来。一般用于研发模型的语言有：Python、R 语言。</li>\n<li>数据模型化<br>这一步是将前面整理之后的数据，按照模型的要求，输入给模型。让数据模型化。这里可能有些抽象，类比一下，就像我们将橡皮泥放进模具，出来之后，就可以得到模具样子的橡皮泥了。</li>\n<li>数据分析<br>这里的数据分析流程和「2.3 数据分析」类似。不同的是，这里分析的是经过数据模型化之后，输出的数据。</li>\n</ul>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>数据分析是一门复杂的学问。在不了解的时候，一直以为这只是一个行业。随着了解的深入。发现每个行业的数据分析虽然流程相似，但是分析的模式和内容天差地别。并且随着分析的深入所需要专业知识就越丰富。一个行业的专业数据分析师不光需要具备数据分析的这些能力，还需要对其行业的认知非常深入。<br>当然，不是每个人都会成为专业的数据分析师。所以根据自己的情况，学习到相应的程度就可以了。</p>\n","categories":["数据分析"],"tags":["数据分析"]},{"title":"聊聊如何读书","url":"/2021/06/28/how-to-reading/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我读的书虽然不多，但也避免不了去思考三个问题：   </p>\n<ol>\n<li>我应该读什么样的书？</li>\n<li>我怎么判断这本书要粗读还是精读？</li>\n<li>我应该如何去粗度或者精读一本书？</li>\n</ol>\n<p>这是从选书开始到读书读完的三个问题，串联了阅读的流程，大多数人都会去思考 1 ，部分人会去思考 3 ，少数人会去思考 2。<br>有一本书专门讨论第 3 个问题，名叫《如何阅读一本书》，这本书写的很全面很详细，讲述了阅读中 4 个层次\b，每个层次分别对应不同的阅读需求，值得参考和学习。\b所以本文不讨论第 3 个问题，重点聊聊第 1，2 个问题，因为\b对于一个阅读者来说，我认为思考清楚读什么书和判断一本书的价值比了解如何阅读一本书更重要。    </p>\n<span id=\"more\"></span>\n\n<h2 id=\"我应该读什么样的书\"><a href=\"#我应该读什么样的书\" class=\"headerlink\" title=\"我应该读什么样的书\"></a>我应该读什么样的书</h2><p>我本人从小到大，并不是一个喜欢阅读的人，小时候也只看过一点小说，阅读量不大。后来，越来越多的经历告诉我读书的重要性，我开始意识到读书的价值，尝试突破不喜欢阅读的习惯，从书中获取我想要的东西。那么，当我决定迈出第一步时，“我应该读什么书” 就是第一个面临的问题，当时我的选择很保守，我选择了网络上一些我信任的大 V 推荐的书单，事实上这些书籍确实给我带来了不错的阅读体验和思维上的开拓。现在，我们回过头来看看这个问题 - 我应该读什么样的书？<br>不同的人群读的书一定是不一样的，但里面一定有共同之处，所以我给出的方法是我从实践的经验中抽取出来的，面向那些和我一样还在职场酣战的年轻人。<br>\b读书是为了获取价值，那么什么样的价值是我们当下最需要的呢？我将书中的价值分为 4 类：</p>\n<ol>\n<li>通识类 - 社会、人文、心理、思考、解决问题、沟通等</li>\n<li>技能类 - 专业技能、教程等</li>\n<li>工具类 - 某个工具或方法论的全面的详细的内容</li>\n<li>其他类 - 不属于上述三类，例如小说、杂志等</li>\n</ol>\n<p>通识类的书籍启迪我们的人生，以人为圆心，涵盖每个人都会涉猎的各个方面。这部分的书籍量大内容多，对于阅读者来说，通识类的书籍看懂不算困难，也不会很枯燥，且每个人看后会有不同的看法和认知。在选择自己应该读什么书时，通识类的书籍一定不能少。<br>技能类的书籍强化我们的某项技能，可以提升我们使用该技能的水平，对于大部分在职场工作或是靠一门「手艺」吃饭的人来说，技能类的书籍总有那么几本经典是必读的。<br>工具类的书籍记录了工具最全面的信息，在需要这个工具时，它能为我们提供很好的支持，是我们最好的帮手。这类书籍一般用于查阅，不会通读。<br>其他类的书籍涉猎最广，内容更多更杂，阅读的情况更是因人而异，有的人喜欢，有的人不喜欢，所以在思考“应该读什么样的书”时，其他类的书籍先不做考虑。   </p>\n<p><strong>读什么样的书，我建议在以上几类书籍的配比是 6:3:1 ，分别代表：</strong></p>\n<blockquote>\n<p>通识类:技能类:工具类 = 6:3:1</p>\n</blockquote>\n<p>为什么这样建议呢？这里引入一个概念，叫「知识的半衰期」，就如放射性元素的半衰期一样，代指知识的价值发光发热的时间。在五彩缤纷的世界中，充斥的各种各样的知识，知识客观存在，不分好坏。但对于每个人来说知识的价值都不一样，有的知识价值转瞬即逝，就像时代的风口，处在风口之上时，风口的知识价值千金，可随着风口消逝，相应的知识也就一文不值。反之，有的知识不会为你的直接带来可量化的价值，甚至你都不知道学了之后有什么变化，但这类知识往往长期积累起来能够产生「聚变式」的价值。<br>知识半衰期的核心是将知识发挥价值的周期量化，根据知识半衰期的长短，判断我们应该读哪些书籍。结合上文中对书籍的分类，半衰期一般是这样的：</p>\n<ul>\n<li>通识类 - 半衰期往往至少数十年，部分人性类、哲学类、思想类可以在未来成百上千年依然适用。</li>\n<li>技能类 - 科技的快速发展往往会让技能类的知识半衰期偏短，以互联网行业最突出，产品、运营、研发等技术往往半衰期不超过 10 年。就算是以经验至上的医学相关行业举例，半衰期一般也仅有几十年，50 年前和医疗技术水平和医药情况和当下已经完全天差地别了。</li>\n<li>工具类 - 工具类的书籍知识半衰期不固定，随着其工具的适用时期而定。从近代来看，哪怕是像《新华字典》这样的文字类工具书籍，也在逐渐被科技的发展所颠覆替代，显得没那么必要了。</li>\n</ul>\n<p>说到这里，就要提一下个人的人生规划了，我坚信一个人的人生规划需要秉承「长期主义」\b，做时间的朋友，长期主义告诉我们要去选择长期积累会给我们带来丰富价值的方向，而不应该只选择做当下会产生价值的事情，如果只看当下的价值，往往伴随着博弈和投机，这样的价值是不稳定的。所以，既不能完全不顾专业技能，选择半衰期超长的通识类书籍，也不能完全不看通识类书籍，只顾专业技能的学习。通识与技能相辅而成，为人生规划的短中长期持续发挥价值。<br><strong>如果你认可我的理念，那么，上文的书籍配比一定适合你。</strong>    </p>\n<p>如果把技能书籍比作我们的「武器」，那么通识书籍就是使用武器的「心法」。阅读通识类的书籍都能为我们带来「心法」上的提升，有的人喜欢读哲学、历史类，有的人喜欢读政治、经济类。我个人喜欢阅读思考、沟通、成长类。类别没有好坏，每个人根据自己的喜好选择即可，核心是获取这些书籍中的知识，为未来的工作和生活带来的价值。技能类和工具类的书籍，更看重它们在短期内带来的直接价值，能够帮助我们解决当下的问题，所以这部分书籍每个人根据自己的行业选择即可，例如摄影相关行业会频繁长期使用到 Ps（PhotoShop），那么买一本 Ps 的工具书籍阅读也是很有必要的。    </p>\n<h2 id=\"我怎么判断这本书要粗读还是精读\"><a href=\"#我怎么判断这本书要粗读还是精读\" class=\"headerlink\" title=\"我怎么判断这本书要粗读还是精读\"></a>我怎么判断这本书要粗读还是精读</h2><p>在选择阅读一本书后，往往就会按照自己所熟悉的方式开始阅读了，有的同学像看小说一样，一目 10 行，一本 600 页的书一周搞定。有的同学则逐字逐句的看，看完了还要思考一会儿，往往一本书要读几个月。<br>那么怎么判断应该怎么读呢？这里引入两个概念：「知识的层级」和「知识的需求度」。    </p>\n<p><strong>知识的层级</strong><br>知识的层级是这个知识在相关知识领域所处的位置，举个例子来说，《C 语言程序设计》这门课程的知识在整个计算机研发领域\b处于偏底层，如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-7-14/1626237433476-image.png\"><br>层级越深入的知识越接近事物的原理，能推导出层级浅知识，所以往往层级深的知识更需要精读和思考。判断知识的层级需要对该知识领域具备一定的了解，不需要构建出完整的知识图谱，但至少应该知道处于哪个层级。    </p>\n<p><strong>知识的需求度</strong><br>知识的需求度需要结合自身的情况，\u001d判断对这知识有多少需求。举个例子，对于大部分人来说，计算机的知识需求都是不多的，仅需要掌握基本的计算机操作，会使用 Office 办公软件就足够了。所以知识的需求度就在计算机的使用层面，并不需要去了解如何写代码，如何装机，如何修电脑。但如果你是计算机专业的从业者，那么需求度就会深入好几个层级。     </p>\n<p>知识的需求度和层级共同决定了这本书应该粗读还是精读，往往层级越深入越需要精读，需求度越高越需要精读，就像一个坐标系：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-7-14/1626238422448-image.png\"></p>\n<p>所以根据这个坐标系，往往以下几类书籍是需要精读的：</p>\n<ul>\n<li>事物原理类</li>\n<li>领域经典类</li>\n<li>哲学、人性类</li>\n<li>分析思考类</li>\n</ul>\n<p>反之，以下几类书籍往往是需要粗读的：</p>\n<ul>\n<li>方法论类</li>\n<li>操作手册类</li>\n<li>字典、工具类</li>\n</ul>\n<p>以上，就是判断书籍应该怎么读的方法了，确定好粗读还是精读之后，接下来就是怎么去粗读，怎么去精读了。这就是《如何阅读一本书》这本书解决的问题了，粗读和精读只是我对读书方法两个极端的概括，在这本书中，将会讲述更多的读书方法和读书的 4 个层级，每个层级阅读方式写的都很详细，如果有兴趣也可以读一下。里面也涵盖了一点「读什么书」，「怎么读」的内容。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然读书并不是我的强项，但我还是写了这篇文章来描述我对如何读书的理解和看法，文中提到的读书配比和理念虽然不能做到适合每一个人，但至少从一名互联网从业者的视角来说，这样的思路是适合大部分年轻人的。万变不离其宗，无论是什么样的阅读者，或是选择什么样的书籍，读书的目标都是一致的：「让书中的价值服务于我们」，在这样的目标下，本文的读书思路则是一个方法论，为那些不怎么会读书的人提供一个可选的读书思路。</p>\n","categories":["读书"],"tags":["思考"]},{"title":"Jcr's 2021","url":"/2022/01/01/jcr-2021/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>又过了一年，打开屏幕，日期上的 2021 已经变成了 2022，这种时间流逝的感知比生日、过年都来的更加直接，每天都能看到，都在告诉你已经来到了 2022，2021 已经无了。<br>想想看去年一年干了些啥，发现其实还折腾了挺多东西的，如果要为 2021 总结一个关键词的话，就叫「启迪」吧。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"复盘\"><a href=\"#复盘\" class=\"headerlink\" title=\"复盘\"></a>复盘</h2><p>复盘 2021，自己对自己的表现还挺满意的吧。</p>\n<p><strong>先从工作上说吧：</strong></p>\n<ol>\n<li>做了半年的架构师，一直到项目结束。从结果来看做的中规中矩，虽然把领导安排的事情都做好了，但还有很大的提升空间，这其中主要的问题是自己的架构视角不足，解决的问题多浮于表面，无法从更高的层次来思考和解决问题。不过这是第一次做架构师，综合来说还不错吧。</li>\n<li>7 月份开始做技术平台，负责平台前端研发相关工作，这对于我这么一个非专业前端来说，还是挺有挑战的，从结果来看，算是做的很不错。这几个月真的是学习了超级多的前端知识和技能。如果这项工作给自己打分的话，我给打 100，我想了半天，确实想不到还有什么可以提升的地方。</li>\n<li>还是技术平台，第一次以具备话语权的「产品经理」角色参与到平台的功能设计中，这可真是刺激，自己做产品设计，自己写代码，当然并不会因为是自己写代码就把功能设计的简单。相反，在这种模式下，更需要剥离程序员的思维来设计产品，从真实用户的需求出发。要想做到还挺不容易的，需要保持头脑开放，更多时候自己处于「做到但没完全做到」的程度，还可以再提升提升。</li>\n</ol>\n<p><strong>再从个人成长上来聊聊：</strong></p>\n<p>今年个人成长上收获颇丰，读了 3 本书，刷了 100 多道算法题，学完了 5 门极客时间课程，还输出了 11 篇文章，当然，还对未来做了很多思考。数了数就这些，似乎看起来也不算很多，但做到这些确实花了我很多时间和精力，和 2021 年初定的目标相比，已经达标了。</p>\n<p><strong>最后聊聊生活：</strong></p>\n<p>今年达到一个人生中的里程碑节点，那就是：我买房啦！<br>虽然很开心，但房贷压力巨大，过了几个月还贷生活后，突然就不开心了，说一夜回到大学生活真的是毫不夸张，以前经常吐槽公司食堂怎么怎么样，去外面开小灶，现在不得不顿顿都往公司食堂跑，真香，是真的香，公司的食堂既好吃又便宜。<br>今年也没怎么出去玩，仅有国庆出去露营了一次，拍到了美丽的星空，还不错。<br>其他的应该还有，但我这会儿想不起来了。</p>\n<p>纵观 2021，做了一堆以前没做过事儿，对我还是有挺多启发的，所以我给 2021 的关键词叫「启迪」。<br>说说 2022，也没啥很大的目标和计划，保持这种状态挺好的。定的目标就不写出来了，这样万一我不能达成，也可以写达成了 😈。</p>\n<h2 id=\"一些吐槽\"><a href=\"#一些吐槽\" class=\"headerlink\" title=\"一些吐槽\"></a>一些吐槽</h2><p>在做架构师那段时间，一直没有写代码，天天就是给别人排查问题、解决问题、制定规范以及与各板块之间的协调，那段时间还挺焦虑的，因为作为一个程序员一旦脱离了代码，很担心自己变菜，怕自己和别人讨论技术时，被别人忽悠，这个问题我的领导「豪温」给了我一个满意的解答。做了一段时间之后，发现写代码真的是最简单的事情，很纯粹，事儿很纯粹，人也很纯粹，专注于技术，简单的快乐。不写代码的工作才是最恼火的，那段时间遇到协调的问题、板块割裂的问题、沟通的问题，说实话这些是真的让我头大，每个人都会站在自己的利益方思考，要想统一、规范、推进一些事儿的时候就会变得很困难，甚至还能见证一些险恶的事情。这种时候需要双管齐下，一个是方案层面要权衡，不能仅从合理和最大化效率上考虑，另一个是得从「人」这个角度权衡。这一点上，我挺佩服我的领导们的，把这事儿给办的明明白白。</p>\n<p>另外，再吐槽一个，我的运气是真的差，真的差，哎，真的差。虽然一直都差，但今年在买房这事儿上也差，就让我特别的难过。我买房买在了房价的最高点，真的是至高点，就像珠穆朗玛峰顶上的那块冰，就像 <code>y=sin(x),x=π/2</code> 时的那个点。我也没想到我刚买房，国家就出政策限制房价，我也没想到，我刚买那一拨儿没优惠，后面 2 个月买还有打折送东西的。当时微信加了一些中介，刷朋友圈时候每看到一次房价下降，每看到一次打折活动，都会想：我靠，又亏了，然后选择性屏蔽，但我又没删中介，因为我好奇能降到多少。那怎么办呢？我就只能多看看同事小区的二手房价格，那个降得更明显，根据「社会学相对论」，也就不会觉得那么亏了 😑。说到底，运气差，菜是原罪，但凡没那么菜，运气哪儿能这么差 🤪。</p>\n","categories":["思考"],"tags":["成长","总结","吐槽"]},{"title":"浅析 Javascript 对象和 Map 的数据结构","url":"/2021/10/21/js-collection-data-stuct/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>事情的起因是这样的，在一次算法的单元测试时，我使用 ES6 的 <code>Map</code> 存放 KeyValue，想要一个哈希表的效果，发现 <code>Map</code> 的存取效率比想象中低很多。从以前 Java 的开发经验来说，<code>HashMap</code> 的存取复杂度是 O(1)，ES6 的 <code>Map</code> 虽然不是 <code>HashMap</code>，但也应该差不多。意外的是，实际测试下来性能竟然差很多，问题究竟出在哪里呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Map-的实现\"><a href=\"#Map-的实现\" class=\"headerlink\" title=\"Map 的实现\"></a>Map 的实现</h2><p>遇到问题我的第一反应是去查文档，于是我找到了最新 ES 的规范（<a href=\"https://tc39.es/ecma262/#sec-map-objects\">TC39:Map</a>），看到 <code>Map</code> 相关的定义。<br>其中 <code>Map.prototype.get</code> 函数的定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">The following steps are taken:</span><br><span class=\"line\"></span><br><span class=\"line\">1. Let M be the this value.</span><br><span class=\"line\">2. Perform ? RequireInternalSlot(M, [[MapData]]).</span><br><span class=\"line\">3. Let entries be the List that is M.[[MapData]].</span><br><span class=\"line\">4. For each Record &#123; [[Key]], [[Value]] &#125; p of entries, do</span><br><span class=\"line\">    a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].</span><br><span class=\"line\">5. Return undefined.</span><br></pre></td></tr></table></figure>\n\n<p>好家伙，结果从 Map 里面获取元素是 for 循环去做的，并且会逐一对比 <code>Key</code>，难怪是要比 <code>HashMap</code> 慢很多，这就相当于从 <code>Map</code> 中查询一个值的复杂度是 O(n)。</p>\n<p>我们再看看插入是怎么做的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">The following steps are taken:</span><br><span class=\"line\"></span><br><span class=\"line\">1. Let M be the this value.</span><br><span class=\"line\">2. Perform ? RequireInternalSlot(M, [[MapData]]).</span><br><span class=\"line\">3. Let entries be the List that is M.[[MapData]].</span><br><span class=\"line\">4. For each Record &#123; [[Key]], [[Value]] &#125; p of entries, do</span><br><span class=\"line\">    a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then</span><br><span class=\"line\">        i. Set p.[[Value]] to value.</span><br><span class=\"line\">        ii. Return M.</span><br><span class=\"line\">5. If key is -0𝔽, set key to +0𝔽.</span><br><span class=\"line\">6. Let p be the Record &#123; [[Key]]: key, [[Value]]: value &#125;.</span><br><span class=\"line\">7. Append p as the last element of entries.</span><br><span class=\"line\">8. Return M.</span><br></pre></td></tr></table></figure>\n\n<p>不出所料，先遍历是否存在，如果存在则覆盖 <code>Value</code>，否则添加到 <code>entries</code> 的末尾。那么插入元素的时间复杂度也是 O(n)。<br>这也就解释了前言中的问题，ES Map 用来做哈希表还是不太行。<br><strong>那么，既然 <code>Map</code> 是增查复杂度是 O(n)，那原生对象的复杂度会不会低一点呢？</strong></p>\n<h2 id=\"原生对象（数组）的实现\"><a href=\"#原生对象（数组）的实现\" class=\"headerlink\" title=\"原生对象（数组）的实现\"></a>原生对象（数组）的实现</h2><h3 id=\"和-Map-做性能比较\"><a href=\"#和-Map-做性能比较\" class=\"headerlink\" title=\"和 Map 做性能比较\"></a>和 Map 做性能比较</h3><p>先贴一段原生对象替代 Map 实现的代码：（替代部分场景）</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"number\">1</span>, value = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// map curd</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">map.<span class=\"title function_\">has</span>(key);</span><br><span class=\"line\">map.<span class=\"title function_\">set</span>(key, value);</span><br><span class=\"line\">map.<span class=\"title function_\">get</span>(key);</span><br><span class=\"line\">map.<span class=\"title function_\">delete</span>(key);</span><br><span class=\"line\"><span class=\"comment\">// obj curd</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj[key] !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">obj[key] = value;</span><br><span class=\"line\">obj[key]</span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj[key]</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，使用方式非常近似。我使用一个循环在我本地电脑测试了 <code>Map</code> 和 <code>Object</code> 的增查效率，大致代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> len = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">&quot;k&quot;</span> + i;</span><br><span class=\"line\">    obj[key] = <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> vc = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">&quot;k&quot;</span> + i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj[key]) &#123;</span><br><span class=\"line\">        vc++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// map</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> len = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">&quot;k&quot;</span> + i;</span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(key, <span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> vc = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">&quot;k&quot;</span> + i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.<span class=\"title function_\">has</span>(key)) &#123;</span><br><span class=\"line\">        vc++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Map</code> 消耗时间：1470 ms</li>\n<li><code>Object</code> 消耗时间：1987 ms</li>\n</ul>\n<p><strong>从结果可以看到，原生 <code>Object</code> 并没有比 Map 的效率更高，反而 <code>Object</code> 还要更慢一点，那这又是为什么呢？</strong></p>\n<h3 id=\"为什么原生对象比-Map-效率更低\"><a href=\"#为什么原生对象比-Map-效率更低\" class=\"headerlink\" title=\"为什么原生对象比 Map 效率更低\"></a>为什么原生对象比 Map 效率更低</h3><p>于是我继续查阅文档（<a href=\"https://tc39.es/ecma262/multipage/abstract-operations.html#sec-makebasicobject\">TC39:Objects</a>），找到了原始对象的相关定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. Let obj be a newly created object with an internal slot for each name in internalSlotsList.</span><br><span class=\"line\">2. Set obj&#x27;s essential internal methods to the default ordinary object definitions specified in 10.1.</span><br><span class=\"line\">3. Assert: If the caller will not be overriding both obj&#x27;s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then internalSlotsList contains [[Prototype]].</span><br><span class=\"line\">4. Assert: If the caller will not be overriding all of obj&#x27;s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then internalSlotsList contains [[Extensible]].</span><br><span class=\"line\">5. If internalSlotsList contains [[Extensible]], set obj.[[Extensible]] to true.</span><br><span class=\"line\">6. Return obj.</span><br></pre></td></tr></table></figure>\n\n<p>这里只提到了原始对象的定义，并没有说具体是怎么实现的，我们可以从文中提到的 <code>internalSlotsList</code> 猜想，难道对象的属性也是一个 <code>slotsList</code> ？，每次查询也是遍历一次拿到，况且因为原生对象的属性还有很多内置属性，所以遍历时会遍历更多的元素，导致对比 <code>Map</code> 还要更低效一点。<br>这个解释很说得通，我自己都差点信了。直到我把苗头转向了数组，我把 <code>Key</code> 变成了纯数字，然后用数组、Map 和原生对象跑了一次，代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> len = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = i;</span><br><span class=\"line\">    obj[key] = <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = i;</span><br><span class=\"line\">    arr[key] = <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = i;</span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(key, <span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组消耗时间：42 ms</li>\n<li><code>Map</code> 消耗时间：450 ms</li>\n<li>原始对象消耗时间：54 ms</li>\n</ul>\n<p><strong>仅仅是 <code>Key</code> 是字符串还是数字索引的区别，和之前的结果就大相径庭，<code>Map</code> 基本被吊打。所以原生对象并不是比 <code>Map</code> 效率更低，只是在非数组索引时 \b\b\b <code>Map</code> 更适合一些。</strong><br>同时也说明，Javascript 引擎应该对原始对象和数组的数据结构有特殊处理。</p>\n<h3 id=\"Chrome-V8-是如何处理原始对象和数组数据结构的\"><a href=\"#Chrome-V8-是如何处理原始对象和数组数据结构的\" class=\"headerlink\" title=\"Chrome V8 是如何处理原始对象和数组数据结构的\"></a>Chrome V8 是如何处理原始对象和数组数据结构的</h3><p>继续看文档，于是找到了 Chrome V8 引擎相关描述的博文（<a href=\"https://v8.dev/blog/fast-properties\">Fast properties in V8</a>）<br><strong>原文很长，这里只列出重点：</strong></p>\n<ol>\n<li>对于可被顺序索引的属性，使用数组作为数据结构。例如：0,1,2 （速度最快）</li>\n<li>对于不可顺序被索引的属性，分两种情况：<br>a. 如果是在对象定义时就有的属性，数据结构依然使用数组，但会生成一个属性名到数组索引的映射表，例如：<code>name -&gt; 0</code>，<code>age -&gt; 1</code>。（速度也很快）<br>b. 如果是在运行时动态添加的属性，数据结构使用 <code>Dictionary</code>，引擎会将动态添加的 <code>Key</code> 和 <code>Value</code> 添加到一个字典表中，（速度较慢）</li>\n<li>每一次为原生对象动态添加不可被顺序索引的属性，都会为他生成一个 <code>HiddenClass</code> 用于存储这个对象的元信息。添加顺序索引的属性则不会。</li>\n<li>数组和原生对象的结构差不多，如果数组使用顺序索引，那么参考第 1 条，如果是非顺序索引，则参考第 2.b 条。例如：<br>a. 顺序索引：<code>a[0] = 1;a[1] = 2;</code> 使用数组存储。<br>b. 非顺序索引：<code>a[9999] = 999;a[&#39;abc&#39;] = 123;</code> 使用 <code>Dictionary</code> 存储。</li>\n</ol>\n<p><strong>由这些内容就可以解释上文的案例了：</strong><br>之所以原生对象的效率更低，是因为每一次新增字符串属性（非顺序索引），都会额外创建 <code>HiddenClass</code>，导致开销增大很多，而新增数字索引就不会。所以才导致了上文「仅仅是 Key 类型不同，结果却大相径庭」。</p>\n<p>到这里，也算是对原生对象的数据结构有了更清晰的认识。当然，其实 <a href=\"https://v8.dev/blog/fast-properties\">Fast properties in V8</a> 这篇博文还说了很多其他关于对象数据结构的细节，讲的更加深入，这里就不多讨论了，有兴趣的小伙伴可自行阅读。</p>\n<h2 id=\"总结-amp-思考\"><a href=\"#总结-amp-思考\" class=\"headerlink\" title=\"总结 &amp; 思考\"></a>总结 &amp; 思考</h2><p>通过这一波儿折腾，感觉对 <code>Chrome V8</code> 引擎的实现细节又多了一些了解。从一开始的猜想到最后找出真相，一步一步挖掘探索，还是很有意思的，有一种解密的感觉，特别是在自己认为已经猜到它的实现时，然后又去写测试代码验证，结果被啪啪打脸的时候，又会更加好奇这 <code>Chrome V8</code> 到底是咋玩儿的。<br>事实证明，还是要多实践多思考，Js 引擎开发者的每一个实现都有很多细节在里面，同时也做足了思考，经过了这么多年的打磨，力求做到更优，并不是我等菜鸟随随便便就能猜到的。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://tc39.es/ecma262/#sec-map.prototype.get\">TC39:sec-map-objects.get</a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-map.prototype.set\">TC39:sec-map-objects-set</a></li>\n<li><a href=\"https://tc39.es/ecma262/multipage/abstract-operations.html#sec-makebasicobject\">TC39:sec-makebasicobject</a></li>\n<li><a href=\"https://v8.dev/blog/fast-properties\">Blog:Fast properties in V8</a></li>\n</ol>\n","categories":["Web前端"],"tags":["算法","数据结构"]},{"title":"记一次在 Kotlin 中使用 Gson 序列化 List 带泛型的问题","url":"/2021/07/02/kotlin-gson-list-rawtype-problem/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个问题花了我 3 个小时，在 Kotlin 中使用 Gson 序列化 List，原本看起来再普通不过的需求，里面却隐藏着一些坑。在 Gson 中，序列化 <code>List&lt;Pojo&gt;</code> 这类实体是没有任何问题的，不用做任何特殊处理即可完成。但如果你序列化的是 <code>List&lt;Pojo&lt;out BasePojo&gt;&gt;</code>，那么问题就出现了，Pojo 对象本身是有属性和值的，但序列化出来的内容就成这样了 <code>[&#123;&#125;,&#123;&#125;]</code>，对象里面的属性都没了。\b 仅仅是定义的差别，List 中元素都是完全一样的，为啥一个可以一个不行呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"怎么解决\"><a href=\"#怎么解决\" class=\"headerlink\" title=\"怎么解决\"></a>怎么解决</h2><p>网上查阅资料较少，基本没有文章说这个问题。</p>\n<p>我试了一下，如果把定义从 <code>List&lt;Pojo&lt;out BasePojo&gt;&gt;</code> 换成 <code>List&lt;Any&gt;</code> 后，还是往 <code>List</code> 里面 add <code>Pojo&lt;BasePojoImpl&gt;</code>，序列化就是正常的，那么可以排除是 List 本身的问题。</p>\n<p>有没有可能是对象定义的问题呢？</p>\n<blockquote>\n<p>Pojo 定义类似如下：<code>Pojo&lt;T : BasePojo&gt;</code></p>\n</blockquote>\n<p>于是我又尝试，干脆把 Pojo 的泛型去掉，序列化 <code>List&lt;Pojo&gt;</code>，序列化也是正常的。单独序列化 <code>Pojo&lt;BasePojoImpl&gt;</code> 也是正常的，排除 Pojo 对象的问题。<br>唯独序列化 <code>List&lt;Pojo&lt;out BasePojo&gt;&gt;</code> 不行，就是闹幺蛾子。</p>\n<p>那咋办呢，我查看了编译后的字节码，想了想 Gson 的工作机制可能是什么样，JVM 又会怎么处理。\b\b\b 泛型是语法糖，编译之后都是会消失的，再结合上文尝试的情况，问题应该是出在序列化泛型对象上。从常规思路来说，序列化 List 时，如果判断到类型是 List，只需要取出 List 中的元素，\u001d 对每一个元素做序列化就可以了，序列化 <code>List&lt;Any&gt;</code> 应该就是这么做的，但序列化 <code>List&lt;Pojo&lt;out BasePojo&gt;&gt;</code> 为什么就不这么做了呢？我也尝试过使用 fastjson，fastjson 能够正常序列化。因为时间原因，我没时间去细看 Gson 源码，但能猜到 Gson 并不是我想的这么处理的，假设 Gson 真不是这么处理的话，是不是我重写一下序列化元素 \b 的代码让 Gson 按照我想的方式去处理就可以了？</p>\n<p>于是我自己实现了一个 <code>JsonSerializer</code> 并注册到了 Gson 中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private val gson: Gson = GsonBuilder()</span><br><span class=\"line\">        .registerTypeAdapter(Pojo::class.java,PojoAdapter())</span><br><span class=\"line\">        .create()</span><br><span class=\"line\"></span><br><span class=\"line\">class PojoAdapter : JsonSerializer&lt;Pojo&lt;out BasePojo&gt;&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private val gsonInternal = Gson()</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun serialize(src: Pojo&lt;out BasePojo&gt;?, typeOfSrc: Type?, context: JsonSerializationContext?): JsonElement &#123;</span><br><span class=\"line\">        return gsonInternal.toJsonTree(src)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，问题解决了。可以看到，这个 <code>JsonSerializer</code> 的实现我并没有做什么操作，只用了 Gson 原生的 toGsonTree 对单个元素做了转换。<br>由此可以得出，Gson 内部处理 List 序列化时，应该不是一个元素一个元素这么处理的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这种问题虽然对大部分的场景来说可能都不会遇到，但遇到一次也够折腾一会儿了，作为解决问题的一个小记录吧~</p>\n","categories":["Kotlin"],"tags":["Kotlin","序列化"]},{"title":"Kotlin 跨平台实践经验分享","url":"/2020/10/20/kotlin-multiplatform-exp-share/","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>随着研发技术的发展，跨平台混合开发越来越流行，Flutter、React Native（以下简称 RN） 这样的框架有越来越多的公司和项目开始使用，Flutter 近两年的迭代速度逐步加快，Google 官方的开发工具 Android Studio 也对其做了许多优化。Flutter 和 RN 专注于多平台构建同一套 UI，已经接受过许多项目的检验，表现还不错。但在面对一些数据处理、后台任务、原生调用的场景时，它们的表现都不尽人意。而这时 Kotlin Multiplatform（以下简称 KMP） 的出现，似乎可以来解决这个问题，如果能够解决，理论上 KMP 是否可以做到不仅 UI 跨平台，全项目都跨平台呢？为了解答这个问题，我开始在项目中实验是否可行。与此同时(2020.9)，KMP 也从 Experimental（实验性的）功能升级到了 Alpha（内测的）功能（Kotlin 1.4.0），KMP 的功能、性能和稳定性都改进了许多，表现出了良好的潜力。<br>参与实践的项目一共有 4 个，类型分为两种，一种是利用 KMP 来构建独立的多端项目。一种是使用 KMP 来构建公共库以供现有的项目使用。我将分享这两种类型的项目中的实践经验。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、使用-KMP-构建独立的多端项目\"><a href=\"#一、使用-KMP-构建独立的多端项目\" class=\"headerlink\" title=\"一、使用 KMP 构建独立的多端项目\"></a>一、使用 KMP 构建独立的多端项目</h2><h3 id=\"1-1-项目背景\"><a href=\"#1-1-项目背景\" class=\"headerlink\" title=\"1.1 项目背景\"></a>1.1 项目背景</h3><p>这是第一次使用 KMP 研发独立的项目，主要功能是做数据采集的 SDK，虽然项目并不直接生成应用程序（apk、html），但拥有独立的逻辑闭环和生命周期控制。<br>项目包含 Android、iOS、Web 三端，没有 UI 界面。Android 部分生成 <code>.aar</code>，iOS 部分生成 <code>.framework</code>，Web 部分生成 <code>js、ts</code> 可上传到 npm 仓库。   </p>\n<h3 id=\"1-2-项目架构\"><a href=\"#1-2-项目架构\" class=\"headerlink\" title=\"1.2 项目架构\"></a>1.2 项目架构</h3><p>项目主要结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2020-10-12/1602502553687-image.png\" alt=\"image\"></p>\n<ul>\n<li><p>公共模块<br>公共模块是三端一样的代码，我将能抽离出去的代码都写到了公共模块，包括主要的业务逻辑、数据处理、网络请求等代码。将存储和 IO 的具体实现放到了原生模块，公共模块只需要调用其统一的接口。网络请求框架使用的官方提供的 Ktor Client，可以直接在公共模块使用。</p>\n</li>\n<li><p>Android 模块<br>Android 模块包括在 Android 设备上的存储和、IO 以及 SDK 接入入口的相关代码，并抽象成相应的接口给公共模块调用，存储使用的是 SharedPerference 和 File。Ktor Http 引擎使用的是 OKHttp。</p>\n</li>\n<li><p>iOS 模块<br>与 Android 模块的内容大致相同。</p>\n</li>\n<li><p>Web 模块<br>与 Android 模块的内容大致相同，存储采用的 localStorage。</p>\n</li>\n</ul>\n<p>项目配置的是 1.4.0 版本的 Kotlin，并使用了 1.4.0 的新特性「IR 编译器」，可以将 Web 模块的代码生成 Typescript 定义文件，方便接入方使用。<br><a href=\"https://kotlinlang.org/docs/reference/whatsnew14.html#new-js-ir-backend\">参考链接</a></p>\n<p>这样做的优势在于可以实现一套代码多端使用，并且可以保证主业务逻辑的一致性，从代码层面上提升研发效率。</p>\n<h3 id=\"1-3-踩坑\"><a href=\"#1-3-踩坑\" class=\"headerlink\" title=\"1.3 踩坑\"></a>1.3 踩坑</h3><ol>\n<li><p>IR 编译器不稳定<br>IR 编译器在发布的第一个版本存在诸多问题，例如和 kotlinx.serialization 一起使用时，会出现编译不通过的情况，这将导致在项目中使用 kotlinx.serialization 后，无法正常 IR 编译器的 <code>@JsExport</code> 功能。</p>\n</li>\n<li><p>iOS framework 编译时间过长<br>KMP 工程生成 framework 文件需要使用 Xcode command line，这期间需要耗费很长的时间，在这个项目中，Android 和 Web 构建的时间加起来仅有两分钟不到，而构建 iOS framework 需要接近 10 分钟。</p>\n</li>\n<li><p>Ktor Client 使用不方便<br>项目使用 Kotlin 官方提供的网络请求库 Ktor Client 发送业务的网络请求，但其功能有限，不支持统一拦截器，实际使用体验并不好。<br>其中还有一个小插曲，项目中使用 Ktor Client 往 Aliyun OSS 传文件，采用 postObject 的方式，但 Ktor Client 上传文件的报文始终通不过 Aliyun 的校验，提客服工单检查之后，问题竟然是 Ktor Client 会自动的去补充一些 post formData 请求的报文，导致无法通过 postObject 上传文件。</p>\n</li>\n<li><p>Kotlin coroutines 协程在集成进 iOS 项目后崩溃<br>项目使用协程进行统一的后台任务管理，同一套代码在 Android 上可以正常使用，打包成 iOS framework 使用时会产生崩溃。</p>\n</li>\n</ol>\n<h3 id=\"1-4-小结\"><a href=\"#1-4-小结\" class=\"headerlink\" title=\"1.4 小结\"></a>1.4 小结</h3><p>KMP 在独立的项目研发场景表现一般，虽然结果是可以使用起来，但在一路上踩坑许多，暴露出了 KMP 目前在独立项目的研发场景下稳定性不够、生态不够好，导致研发效率反而降低同时还拥有新技术的不确定性风险。</p>\n<h2 id=\"二、使用-KMP-构建公共库\"><a href=\"#二、使用-KMP-构建公共库\" class=\"headerlink\" title=\"二、使用 KMP 构建公共库\"></a>二、使用 KMP 构建公共库</h2><h3 id=\"2-1-背景\"><a href=\"#2-1-背景\" class=\"headerlink\" title=\"2.1 背景\"></a>2.1 背景</h3><p>我们想在现有的项目中尝试 KMP，将一部分新功能的业务逻辑和数据模型抽离至的 KMP 项目，不包含网络请求、IO、数据库等原生操作，再用原生项目引用 KMP 项目生成的包，达到一套代码多端使用的目的。尝试这种方式的项目有 3 个。</p>\n<h3 id=\"2-2-架构思路\"><a href=\"#2-2-架构思路\" class=\"headerlink\" title=\"2.2 架构思路\"></a>2.2 架构思路</h3><p>项目主要结构如下：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2020-10-21/1603263111969-image.png\" alt=\"image\"></p>\n<ul>\n<li><p>公共模块<br>我们将一些新功能的纯业务逻辑、常量定义和数据模型写到了公共模块，可以供服务端和客户端一并使用，达到全端的统一。</p>\n</li>\n<li><p>各个端的模块<br>在这个架构中，各个端的模块中不会包含过多的代码，一般会包含对模型的处理以及对业务逻辑的封装，以供接入方更好的使用。</p>\n</li>\n</ul>\n<p>这样做的优势在于可以对现有的项目影响较小，仅仅只是一小部分新功能的业务抽离出去使用 KMP，即使发现无法解决的阻塞性问题，也可以及时更换为原生代码。如果能够稳固运行，后续也很好扩展。</p>\n<h3 id=\"2-3-踩坑\"><a href=\"#2-3-踩坑\" class=\"headerlink\" title=\"2.3 踩坑\"></a>2.3 踩坑</h3><ol>\n<li><p>能抽离出去的逻辑有限<br>新功能能抽离出去的公用纯业务逻辑很少。在实践的时候，许多看似可以抽离出去的业务逻辑实际上都会带有一些与现有项目的耦合，并且多端统一的逻辑往往是有限的。</p>\n</li>\n<li><p>调试阶段，编译打包跨平台库消耗时间过长。<br>在研发和调试阶段，需要频改动公共库，有的时候甚至只是改动一行代码都需要重新编译项目，导出对应平台的包再让原生项目依赖，整个流程比较消耗时间，影响研发效率。</p>\n</li>\n<li><p>使用时相比原生代码体验有一定差距<br>在使用这种架构的项目中，尝试过导出 framework（iOS）、js（Web）、js + ts（Web Kotlin 1.4.0）、dll（win）。其中：</p>\n</li>\n</ol>\n<ul>\n<li>iOS framework 包在 iOS 中的使用体验一般，能够正常使用，但会繁琐一点，和原生代码还有差距的。</li>\n<li>js 在现有 React Web 项目中使用体验较差，由于缺少 ts 定义文件，所以使用的时候只能记住对应的函数和变量。</li>\n<li>js + ts 在现有 React Web 项目中体验不错。</li>\n<li>dll 在 Windows 开发中（C#）体验很差，虽然可以使用，但加载 Kotlin 生成的动态（和静态）链接库都很繁琐，使用的成本增加了不少。</li>\n</ul>\n<h3 id=\"2-4-小结\"><a href=\"#2-4-小结\" class=\"headerlink\" title=\"2.4 小结\"></a>2.4 小结</h3><p>使用 KMP 构建公共库的形态总体来说使用体验一般，虽然可以做到多平台兼容，但是在 3 个项目实施后并没有达到很理想的效果，主要体现在两点，分别是：</p>\n<ul>\n<li>开发效率提升不明显</li>\n<li>由于抽离的代码较少，所以代码统一所带来的稳定性提升、易维护的价值较少。</li>\n<li>部分端因使用体验较差用原生代码重写。</li>\n</ul>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><h3 id=\"3-1-目前不适合在生产项目中使用\"><a href=\"#3-1-目前不适合在生产项目中使用\" class=\"headerlink\" title=\"3.1 目前不适合在生产项目中使用\"></a>3.1 目前不适合在生产项目中使用</h3><p>本次 KMP 项目的实践虽然最终都能够成功运行，但在过程中遇到了较多的坑，结合目前官方 KMP 依然处于测试（Alpha）阶段，社区资料和轮子较少，所以得出的结论是目前不适合在生产项目中使用。</p>\n<p>主要问题如下：</p>\n<ul>\n<li>使用期间的不确定坑较多，遇到疑难的坑一般只能向社区求助（官方社区 YouTrack 或 Github）。</li>\n<li>社区资料和轮子较少。</li>\n<li>与原生代码的契合度还需要提高。</li>\n<li>开发效率提高不明显。在实际开发中，虽然各端一起使用 KMP，但依然需要足够多的原生开发知识作为支撑才能进行开发，且需要最好每位参与开发的人员都会 Kotlin。</li>\n<li>KMP 生成的包依赖较多，会增加最终应用体积。例如在 KMP 研发业务库的场景，原生项目本身没有 kotlin 相关的依赖，但使用就必须得依赖 kotlin 基础库以及使用到的 kotlinx 库</li>\n<li>性能问题。我们发现在一个 iOS 原生项目使用多个 KMP 生成的 framework 时，会依赖多份 kotlin 基础库，并且这些库在应用启动时就会加载，对应用的性能产生一定影响。</li>\n</ul>\n<h3 id=\"3-2-KMP-的未来\"><a href=\"#3-2-KMP-的未来\" class=\"headerlink\" title=\"3.2 KMP 的未来\"></a>3.2 KMP 的未来</h3><p>虽然当下 KMP 的表现在生产项目中不尽人意，但作为技术的探索，KMP 目标做到在所有平台下都能轻松的使用 Kotlin 开发，纵观 Kotlin 的发展史，KMP 的发展越来越迅速，目前已经到测试阶段，且所应用的场景确实为混合开发的痛点之一。所以我认为 KMP 的未来是很有前景的，一起期待吧。</p>\n<h3 id=\"3-3-新技术在团队推行的考虑\"><a href=\"#3-3-新技术在团队推行的考虑\" class=\"headerlink\" title=\"3.3 新技术在团队推行的考虑\"></a>3.3 新技术在团队推行的考虑</h3><p>本次 KMP 的实践，也是一项新技术在团队推行的尝试，我认为这其中还有许多可以优化的地方和值得考虑的问题。这里聊一聊我的看法，未来其他新技术实践时可以参考。<br>团队内新技术的推行，我觉得需要考虑以下问题：   </p>\n<ol>\n<li>新技术是否成熟、稳定性、社区资料、生态怎么样，是否具备接入生产项目的条件，对新技术的原理掌控如何。</li>\n<li>与当前团队的技术栈该如何结合，有哪些风险和价值，价值是否大于风险，如何最小化验证。</li>\n<li>最小化验证的结果如何，是否可以支撑与当前的团队技术栈结合。</li>\n<li>如何设计落地方案，评估风险与容错机制，保证稳定优先。</li>\n<li>如何执行落地方案，如何保证顺利执行、预防事故以及事故解决方案。</li>\n<li>无论是成功落地还是放弃，如何储备技术能力。</li>\n</ol>\n<p>以上的推行方式采用循序渐进的模式，虽然标准很严苛，但是让新技术在团队内落地得到很好的把控，避免因为实际尝试后发现致命性问题而造成返工。即使新技术在中间阶段验证之后发现无法落地，也可以作为技术储备，提升团队的技术能力。</p>\n","categories":["Kotlin"],"tags":["Kotlin","跨平台"]},{"title":"Kotlin 跨平台项目上传至 Maven 中央仓库","url":"/2020/07/23/kotlin-multiplatform-upload-maven-central/","content":"<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>将一个普通的 Java 上传至 Maven 中央仓库\b并不是一件很困难的事情。按照官方提供的配置即可。但如果想上传一个 Kotlin 多平台项目，就没那么方便了。网上关于 Kotlin 多平台项目的资料很少，如何上传至中央仓库更是几乎没有。<br>本篇文章将介绍将 Kotlin 多平台项目上传至 Maven 中央仓库的方法、流程、配置、坑和其处理方式。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h2><blockquote>\n<p>先了解一下概念，OSSRH - Sonatype OSSRH 是为开源软件提供 Maven 仓库托管的服务。要在 Maven 中央仓库（ Maven Central ）中发布，需要先注册账号。</p>\n</blockquote>\n<h3 id=\"1-1-注册-Sonatype-JIRA-账号\"><a href=\"#1-1-注册-Sonatype-JIRA-账号\" class=\"headerlink\" title=\"1.1 注册 Sonatype JIRA 账号\"></a>1.1 注册 Sonatype JIRA 账号</h3><p>注册链接：<a href=\"https://issues.sonatype.org/secure/Signup!default.jspa\">https://issues.sonatype.org/secure/Signup!default.jspa</a></p>\n<p>注册成功后会进入如下界面：<br><img src=\"/img/kotlin-mumc/1.png\" alt=\"WX20200725-111323@2x\"></p>\n<p>英语不够好的请选择「中文（中国）」</p>\n<p><img src=\"/img/kotlin-mumc/2.png\" alt=\"WX20200725-111444@2x\"></p>\n<p>选择「下一步」</p>\n<h3 id=\"1-2-提交发布项目申请\"><a href=\"#1-2-提交发布项目申请\" class=\"headerlink\" title=\"1.2 提交发布项目申请\"></a>1.2 提交发布项目申请</h3><p><img src=\"/img/kotlin-mumc/3.png\" alt=\"WX20200725-111519@2x\"></p>\n<p>选择「创建一个问题」</p>\n<blockquote>\n<p>注：如果已经注册，则在主页上点击「新建」也可以进入到创建 issue 的页面。</p>\n</blockquote>\n<p><img src=\"/img/kotlin-mumc/4.png\" alt=\"WX20200725-111557@2x\"></p>\n<p>「项目」一栏选择 <code>Community Support - Open Source Project Repository Hosting (OSSRH)</code> ，选择这一项代表我们是要发布一个开源项目。   </p>\n<p>「问题类型」一栏选择 <code>New Project</code>，然后「下一步」</p>\n<p><img src=\"/img/kotlin-mumc/5.png\" alt=\"WX20200725-112517@2x\"></p>\n<p>「概要」和「描述」填写关于项目的简单概要和详细介绍，如果不知道填啥可以填项目名和简介。</p>\n<p><img src=\"/img/kotlin-mumc/6.png\" alt=\"WX20200725-112528@2x\"></p>\n<p>「GroupId」为 Maven 坐标的 GroupId，不能随便填写。需要持有该域名才能使用该 GroupId。<br>例如我的域名为 <code>jcr.pub</code> 那么我的 GroupId 可以填写 <code>pub.jcr.*</code> 这种格式。<br>如果没有自己的域名，那么可以使用 Github 的其用户名作为 GroupId 。我的 Github 用户名为 <code>csgajcr</code> 那么我可以填写 <code>com.github.csgajcr</code> 作为我的 GroupId。</p>\n<p>「Project URL」填写项目的链接地址。<br><a href=\"https://github.com/csgajcr/unity-bridge-android\">https://github.com/csgajcr/unity-bridge-android</a></p>\n<p>「SCM URL」填写项目的版本管理地址。<br><a href=\"https://github.com/csgajcr/unity-bridge-android.git\">https://github.com/csgajcr/unity-bridge-android.git</a></p>\n<p>填写完成后，点击「新建」</p>\n<p>至此，就已经成功提交一个申请了。</p>\n<blockquote>\n<p>注：提交之后需要等待 10 分钟左右，工作人员会给我们提交的 issue 一个回复，让你验证域名。（因为我之前选择的域名作为 GroupId）   </p>\n</blockquote>\n<h3 id=\"1-3-配置域名通过认证\"><a href=\"#1-3-配置域名通过认证\" class=\"headerlink\" title=\"1.3 配置域名通过认证\"></a>1.3 配置域名通过认证</h3><p>大约 10 分钟后，工作人员会给你一个回复，并且会把 issue 的状态修改为 「wait for response」</p>\n<p><img src=\"/img/kotlin-mumc/7.png\" alt=\"image\"></p>\n<p>根据回复的内容，可以通过两种方式证明你拥有这个域名：</p>\n<ol>\n<li>为域名添加 TXT 记录</li>\n<li>为域名设置重定向到 Github page</li>\n</ol>\n<p>我选择的「为域名添加 TXT 记录」</p>\n<blockquote>\n<p>注：我的域名在阿里云购买，所以进入阿里云控制台配置即可，其他域名服务商也有对应的设置位置。</p>\n</blockquote>\n<p><img src=\"/img/kotlin-mumc/8.png\" alt=\"image\"></p>\n<p>添加之后，点击前面 issue 页面上方的按钮「Response」，问题会变成 「open」状态。继续等待 10 分钟左右。如果验证成功就会看到成功的评论，如果失败，请参考在 issue 中的回复内容，进行修改即可。</p>\n<p><img src=\"/img/kotlin-mumc/9.png\" alt=\"image\"></p>\n<p>上图为认证成功的评论。</p>\n<h2 id=\"二、项目配置\"><a href=\"#二、项目配置\" class=\"headerlink\" title=\"二、项目配置\"></a>二、项目配置</h2><p>本节主要介绍在跨平台项目中 Gradle 脚本应该如何配置上传功能。</p>\n<h3 id=\"2-1-引入插件\"><a href=\"#2-1-引入插件\" class=\"headerlink\" title=\"2.1 引入插件\"></a>2.1 引入插件</h3><p>在项目根目录的 <code>build.gradle</code> 中加入如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;maven-publish&#x27;</span><br><span class=\"line\">apply plugin: &#x27;signing&#x27;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>maven-publish 是将项目发布到 Maven 仓库的插件。</li>\n<li>signing 是签名插件，为发布生成的文件进行签名。</li>\n</ul>\n<h3 id=\"2-2-GPG-密钥设置\"><a href=\"#2-2-GPG-密钥设置\" class=\"headerlink\" title=\"2.2 GPG 密钥设置\"></a>2.2 GPG 密钥设置</h3><p>Maven Central 会对我们上传的包进行签名。这里使用的签名采用的是公私钥（RSA）的模式，即私钥签名，公钥验证。所以我们需要先为项目生成一份公私钥对，并将公钥上传至公钥中心，再把私钥配置到项目中，为生成的包签名。   </p>\n<blockquote>\n<p>这里涉及的概念 「公钥」、「私钥」、「签名」如果不太清楚可以自行查阅相关资料。</p>\n</blockquote>\n<ol>\n<li><p>GPG 安装<br>GPG 在 Max OSX 环境下可以直接通过命令行安装。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install -v gpg</span><br></pre></td></tr></table></figure>\n<p>Windows 下可以使用 <a href=\"https://www.gpg4win.org/download.html\">gpg4win</a></p>\n<blockquote>\n<p>以下将以 Mac OSX 为基准演示操作流程。Windows 用户可以使用可视化 GPG 管理工具，或者 Windows 下的 bash ，具体请自行查阅相关资料，这里不做太多详述。</p>\n</blockquote>\n</li>\n<li><p>新建密钥<br>执行如下命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --generate-key</span><br></pre></td></tr></table></figure>\n<p>执行后会让你输入密钥的相关信息，根据你的信息输入即可。执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pub   rsa2048 2020-07-27 [SC] [有效至：2022-07-27]</span><br><span class=\"line\">      BB53A3118459F41C4E355D31E90A28513D397F2F</span><br><span class=\"line\">uid                      Jcr &lt;i@jcr.pub&gt;</span><br><span class=\"line\">sub   rsa2048 2020-07-27 [E] [有效至：2022-07-27]</span><br></pre></td></tr></table></figure>\n<p>查看已经生成的密钥，可以看到刚才生成的密钥。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg -k</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中 BB53A3118459F41C4E355D31E90A28513D397F2F 为密钥指纹，指纹的后 8 位 「3D397F2F」为密钥的 KeyId，后续在 Gradle 配置中将会使用到。 </p>\n</blockquote>\n</li>\n<li><p>导出刚创建的私钥<br>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --export-secret-keys [密钥指纹] &gt; private-key.gpg</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将导出之后的 <code>private-key.gpg</code> 放置到项目目录，方便下一步的配置使用。</p>\n</blockquote>\n</li>\n<li><p>上传公钥到公钥服务器<br>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --keyserver keyserver.ubuntu.com --send-keys [密钥指纹]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：keyserver.ubuntu.com 为公钥服务器的地址，\bMaven Central 在校验签名是会从公钥服务器拉取。Maven Central 支持的公钥服务器地址\b有三个 <code>pool.sks-keyservers.net\b\u001c</code>、<code>keyserver.ubuntu.com</code> 、<code>keys.gnupg.net</code>。如果一个地址访问失败，替换成换成其中任意一个都是可以的。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"2-3-配置发布参数\"><a href=\"#2-3-配置发布参数\" class=\"headerlink\" title=\"2.3 配置发布参数\"></a>2.3 配置发布参数</h3><p>在 <code>build.gradle</code> 中设置项目的 groupId 和 version，actifactId 会自动获取你的项目名称。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">group &#x27;pub.jcr.android&#x27; //这里的 groupId 需要和 OSSRH 中申请的保持一致</span><br><span class=\"line\">version &#x27;0.0.0.9&#x27;</span><br></pre></td></tr></table></figure>\n<p>添加 Maven 发布相关代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">def javadocTask = task javadocJar(type: Jar) &#123;</span><br><span class=\"line\">    archiveClassifier.set(&quot;javadoc&quot;)</span><br><span class=\"line\">    classifier = &quot;javadoc&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">publishing &#123;</span><br><span class=\"line\">    publications.configureEach &#123;</span><br><span class=\"line\">        // 添加生成 javadoc 的任务</span><br><span class=\"line\">        artifact javadocTask</span><br><span class=\"line\"></span><br><span class=\"line\">        setArtifactId(&quot;card-message-core&quot;) //设置 artifactId</span><br><span class=\"line\"></span><br><span class=\"line\">        //配置上传源码</span><br><span class=\"line\">        pom &#123;</span><br><span class=\"line\">            // 构件名称</span><br><span class=\"line\">            // 区别于artifactId，可以理解为artifactName</span><br><span class=\"line\">            name = &#x27;card-message-core&#x27;</span><br><span class=\"line\">            // 构件描述</span><br><span class=\"line\">            description = &#x27;A qingtui card message component&#x27;</span><br><span class=\"line\">            // 构件主页</span><br><span class=\"line\">            url = &#x27;https://github.com/im-qingtui/card-message-core&#x27;</span><br><span class=\"line\">            // 许可证名称和地址</span><br><span class=\"line\">            licenses &#123;</span><br><span class=\"line\">                license &#123;</span><br><span class=\"line\">                    name = &#x27;The Apache License, Version 2.0&#x27;</span><br><span class=\"line\">                    url = &#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 开发者信息</span><br><span class=\"line\">            developers &#123;</span><br><span class=\"line\">                developer &#123;</span><br><span class=\"line\">                    name = &#x27;Jcr&#x27;</span><br><span class=\"line\">                    email = &#x27;i@jcr.pub&#x27;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 版本控制仓库地址</span><br><span class=\"line\">            scm &#123;</span><br><span class=\"line\">                url = &#x27;https://github.com/im-qingtui/card-message-core&#x27;</span><br><span class=\"line\">                connection = &#x27;scm:git:git://github.com/im-qingtui/card-message-core.git&#x27;</span><br><span class=\"line\">                developerConnection = &#x27;scm:git:ssh://git@github.com:im-qingtui/card-message-core.git&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            //指定要上传的maven私服仓库，这里只设置了 release 仓库地址。</span><br><span class=\"line\">            url = &quot;https://oss.sonatype.org/service/local/staging/deploy/maven2&quot;</span><br><span class=\"line\">            //认证用户和密码，配置到 gradle.properties 中</span><br><span class=\"line\">            credentials &#123;</span><br><span class=\"line\">                username sonatypeUsername</span><br><span class=\"line\">                password sonatypePassword</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    signing &#123;</span><br><span class=\"line\">        // 设置对生成文件进行签名</span><br><span class=\"line\">        sign publishing.publications</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>gradle.properties</code> 中添加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">signing.keyId=[签名 keyId]</span><br><span class=\"line\">signing.password=[签名 password]</span><br><span class=\"line\">signing.secretKeyRingFile=[签名的相对路径 例：publish/secret.gpg]</span><br><span class=\"line\"></span><br><span class=\"line\">sonatypeUsername=[OSSRH 用户名]</span><br><span class=\"line\">sonatypePassword=[OSSRH 密码]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>keyId 为上一步 GPG 密钥所包含的。</li>\n<li>secretKeyRingFile 为上一步导出的签名路径，</li>\n</ul>\n<h2 id=\"三、发布\"><a href=\"#三、发布\" class=\"headerlink\" title=\"三、发布\"></a>三、发布</h2><p>完成以上步骤后，执行 <code>Gradle Task - Publishing -&gt; publish</code> 或者 <code>Gradle Task - Publishing -&gt; publishJvmPublicationToMavenRepository</code>，前者是发布整个跨平台项目，后者是发布其中的 JVM 部分。<br>如果前面配置没有出错，那么这里执行完成之后就上传成功了。但这并没有结束，本地上传成功之后实际会在 Nexus 中生成一个申请，Nexus 会根据校验规则校验我们上传的包，校验通过后，才可以正式发布。所以我们需要登录 Nexus 去查看我们生成的申请。步骤如下：</p>\n<h3 id=\"3-1-登录-Nexus\"><a href=\"#3-1-登录-Nexus\" class=\"headerlink\" title=\"3.1 登录 Nexus\"></a>3.1 登录 Nexus</h3><p>使用 OSSRH 的账号登录 <a href=\"https://oss.sonatype.org/\">https://oss.sonatype.org/</a></p>\n<h3 id=\"3-2-处理申请\"><a href=\"#3-2-处理申请\" class=\"headerlink\" title=\"3.2 处理申请\"></a>3.2 处理申请</h3><p>点击 「Staging Repositories」<br><img src=\"/img/kotlin-mumc/10.png\" alt=\"image\"><br>这条记录就是我们刚才创建的申请，当前状态是「Open」，我们需要选择该条申请，点击「Close」。<br><img src=\"/img/kotlin-mumc/11.png\" alt=\"image\"><br>等待 1 min 后，刷新页面，选择该申请，点击「Activity」-&gt; 「close」 查看审核结果。<br><img src=\"/img/kotlin-mumc/12.png\" alt=\"image\"><br>如果没有报错，就说明审核通过了。<br>点击 「Release」<br><img src=\"/img/kotlin-mumc/13.png\" alt=\"image\"><br><strong>如果是首次发布，请跳到「四、首次发布后续」继续操作，如果不是首次发布，那么到这里，就已经完成发布了，就可以通过你配置的 Maven 坐标下载到对应的包了。</strong></p>\n<blockquote>\n<p>注：项目生成的文件可以 「Activity」右边的「Content」 查看，如果出错可以检查上传的文件是否完整。</p>\n</blockquote>\n<h3 id=\"3-3-审核步骤详解和排错\"><a href=\"#3-3-审核步骤详解和排错\" class=\"headerlink\" title=\"3.3 审核步骤详解和排错\"></a>3.3 审核步骤详解和排错</h3><p>在上图中，列出了每一条审核的信息。如果审核失败，会在这里具体标出那一条失败。下面开始说明每一条检验规则。</p>\n<ol>\n<li><p>Javadoc Validation<br>上传的文件之中必须包含 javadoc，如果没有则报错</p>\n</li>\n<li><p>Archives must not contain insecure paths<br>上传的文件包中不能包含不安全的路径。只要我们没有违规配置，这一点一般都没问题</p>\n</li>\n<li><p>Signature Validation<br>上传的文件中需要包含 <code>.asc</code> 签名文件，并且会对其进行校验。要和之前密钥配置中匹配</p>\n</li>\n<li><p>POM Validation<br>校验 POM 文件中的信息是否完整，除了基本配置之外，还需要包含 「SCM」信息、项目基本信息（名称、详情、URL）、licenses、developers</p>\n</li>\n<li><p>Profile target matcher<br>配置是否匹配</p>\n</li>\n<li><p>Checksum Validation<br>文件 hash 校验</p>\n</li>\n<li><p>Sources Validation<br>上传的文件中必须包含 sources</p>\n</li>\n</ol>\n<h2 id=\"四、首次发布后续\"><a href=\"#四、首次发布后续\" class=\"headerlink\" title=\"四、首次发布后续\"></a>四、首次发布后续</h2><p>还记得在前面 OSSRH 认证成功之后工作人员的回复吗？其中有一句「please comment on this ticket when you promoted your first release, thanks」<br>「三、发布」完成之后，我们需要回到 OSSRH 中对最开始申请的 issue 进行回复。告诉工作人员，我们完成了第一次发布。<br><img src=\"/img/kotlin-mumc/14.png\" alt=\"image\"><br>「I have success to promoted my first release.」</p>\n<p>稍等一会儿，管理员回复之后，Maven Central 会开始进行同步，大约 2 小时之后就可以通过 Maven 坐标检索到你的包了。<br><img src=\"/img/kotlin-mumc/15.png\" alt=\"image\"></p>\n<p>至此，首次发布完成。</p>\n","categories":["Kotlin"],"tags":["Kotlin","Maven Central","Kotlin multiplatform"]},{"title":"LeetCode 训练 - Array","url":"/2020/06/13/leetcode-traning-array/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>数组 - 最基础的数据结构之一。</p>\n<span id=\"more\"></span>\n<h2 id=\"刷题列表\"><a href=\"#刷题列表\" class=\"headerlink\" title=\"刷题列表\"></a>刷题列表</h2><table>\n<thead>\n<tr>\n<th>题目名称</th>\n<th>难度</th>\n<th>题目链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>寻找数组的中心索引</td>\n<td>简单</td>\n<td><a href=\"https://leetcode-cn.com/problems/find-pivot-index/\">https://leetcode-cn.com/problems/find-pivot-index/</a></td>\n</tr>\n<tr>\n<td>搜索插入位置</td>\n<td>简单</td>\n<td><a href=\"https://leetcode-cn.com/problems/search-insert-position/\">https://leetcode-cn.com/problems/search-insert-position/</a></td>\n</tr>\n<tr>\n<td>合并区间</td>\n<td>中等</td>\n<td><a href=\"https://leetcode-cn.com/problems/merge-intervals/\">https://leetcode-cn.com/problems/merge-intervals/</a></td>\n</tr>\n<tr>\n<td>旋转矩阵</td>\n<td>中等</td>\n<td><a href=\"https://leetcode-cn.com/problems/rotate-matrix-lcci/\">https://leetcode-cn.com/problems/rotate-matrix-lcci/</a></td>\n</tr>\n<tr>\n<td>零矩阵</td>\n<td>中等</td>\n<td><a href=\"https://leetcode-cn.com/problems/zero-matrix-lcci/\">https://leetcode-cn.com/problems/zero-matrix-lcci/</a></td>\n</tr>\n<tr>\n<td>对角线遍历</td>\n<td>中等</td>\n<td><a href=\"https://leetcode-cn.com/problems/diagonal-traverse/\">https://leetcode-cn.com/problems/diagonal-traverse/</a></td>\n</tr>\n<tr>\n<td>最长公共前缀</td>\n<td>简单</td>\n<td><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\">https://leetcode-cn.com/problems/longest-common-prefix/</a></td>\n</tr>\n<tr>\n<td>最长回文子串</td>\n<td>中等</td>\n<td><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></td>\n</tr>\n</tbody></table>\n"},{"title":"实现了一个查看代码 Diff 的组件","url":"/2021/09/19/make-a-code-diff-viewer/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近需求上想用一个查看代码 Diff 的组件（inline diff 模式），试了 <code>Monaco Editor</code>、<code>CodeMirror</code>、<code>Diff2Html</code> 效果都一般，虽然各有各的优点，但总那么一些不太符合我想要的地方。</p>\n<ul>\n<li>MonacoEditor： 不能折叠，看长文本的情况下不太方便一眼看出那里有更改，而且有点重。</li>\n<li>Diff2Html：有折叠有高亮，看似不错，但折叠不能展开，且样式上看起来不够精致。</li>\n</ul>\n<p>咋办呢？我调研了一下 <code>Diff2Html</code> 这个库，其实它是提供了一些 API，可以自定义样式、规则等能力。但如果要基于 <code>Diff2Html</code> 修改成我想要的样子，改动成本很高。<br>所以，干脆还是自己实现一个吧，看起来也不算很复杂。<br>那么，开搞！话不多说，先看效果！<br><img src=\"/img/diff-viewer/1.png\"></p>\n<span id=\"more\"></span>\n\n<p>这是基于 Gitlab 的样式和折叠机制写的一个 <code>Vue</code> 的组件，支持行内 Diff，未改动代码折叠和展开，方便更直观的一下看到整个文件的改动。</p>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>整体的实现思路来说主要分为以下几步：</p>\n<blockquote>\n<p>Diff 原文本和现文本 -&gt; 处理两份文本的变化 -&gt; 高亮关键字 -&gt; 渲染结果</p>\n</blockquote>\n<p>如果这一整个流程完全都自己做，还是很复杂的，所以就找了 <code>jsdiff</code> 和 <code>highlight.js</code> 分别来实现「Diff」和「高亮」这两个部分。</p>\n<ul>\n<li>jsdiff - <a href=\"https://github.com/kpdecker/jsdiff\">https://github.com/kpdecker/jsdiff</a></li>\n<li>highlight.js - <a href=\"https://github.com/highlightjs/highlight.js\">https://github.com/highlightjs/highlight.js</a></li>\n</ul>\n<p>基于这个思路，完整流程如下：</p>\n<blockquote>\n<p>jsdiff 处理原文本和现文本 -&gt; 解析 Diff 结果 -&gt; 生成多行视图数据 -&gt; 根据 Diff 结果高亮行内文本 -&gt; 折叠未变化的文本 -&gt; 高亮关键字 -&gt; 渲染结果</p>\n</blockquote>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>首先，我把每行的视图渲染数据结构定义为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ILineModel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CodeLineModel</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ILineModel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;add&quot;</span> | <span class=\"string\">&quot;delete&quot;</span> | <span class=\"string\">&quot;normal&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">oldLineNumber</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">nowLineNumber</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  highlightStartIndex?: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">  highlightLength?: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">CollapsedLineModel</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ILineModel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;collapsed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">lines</span>: <span class=\"title class_\">CodeLineModel</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">lineCount</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 是否已经展开</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">isCollapsed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CodeLineModel: 一行内容，<code>type</code> 为那一行的变更类型，可以是「新增」(add)、「移除」(delete)或「未变更」(normal)，其余字段可顾名思义。</li>\n<li>CollapsedLineModel: 一行可折叠的内容，<code>lines</code> 代表这个折叠行所折叠的内容。在展开的时候，就把 lines 中的内容渲染至视图。</li>\n</ul>\n<h3 id=\"jsdiff-处理原文本和现文本\"><a href=\"#jsdiff-处理原文本和现文本\" class=\"headerlink\" title=\"jsdiff 处理原文本和现文本\"></a>jsdiff 处理原文本和现文本</h3><p>在 Diff 操作上，<code>jsdiff</code> 提供了很多接口以供使用，这里使用和 git diff 同样的策略 <code>line diff</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"title class_\">Diff</span>.<span class=\"title function_\">diffLines</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">lastContent</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">content</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解析-Diff-结果并生成视图数据\"><a href=\"#解析-Diff-结果并生成视图数据\" class=\"headerlink\" title=\"解析 Diff 结果并生成视图数据\"></a>解析 Diff 结果并生成视图数据</h3><p>上文 <code>result</code> 就是 Diff 的结果了，结果是一个 <code>Change[]</code> 类型，接下来，就要一条一条的解析结果了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">parseLineChanges</span>(<span class=\"params\">diffChanges: Change[]</span>): <span class=\"title class_\">CodeLineModel</span>[] &#123;</span><br><span class=\"line\">  <span class=\"title function_\">init</span>();</span><br><span class=\"line\">  diffChanges.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">change</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">processNext</span>(change);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"title function_\">attachInlineHighlight</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...lineModels];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我会将变更信息全部转为 <code>CodeLineModel</code>，代表一行一行的内容。（折叠在最后处理）<br>核心实现如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processNext</span>(<span class=\"params\">change: Change</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (change.<span class=\"property\">added</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//新增</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; change.<span class=\"property\">count</span>!; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> content = change.<span class=\"property\">value</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>)[i]; <span class=\"comment\">// 按行分割</span></span><br><span class=\"line\">      currentNowNumber++;</span><br><span class=\"line\">      <span class=\"title function_\">setLineMapping</span>(<span class=\"string\">&quot;now&quot;</span>, currentNowNumber, content); <span class=\"comment\">// 将老内容的行数与新内容的行数映射起来</span></span><br><span class=\"line\">      currentLine = <span class=\"title function_\">createLine</span>(<span class=\"string\">&quot;add&quot;</span>, <span class=\"string\">&quot;&quot;</span>, currentNowNumber.<span class=\"title function_\">toString</span>(), content);</span><br><span class=\"line\">      <span class=\"title function_\">emitCodeModel</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (change.<span class=\"property\">removed</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//移除</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; change.<span class=\"property\">count</span>!; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> content = change.<span class=\"property\">value</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>)[i];</span><br><span class=\"line\">      currentOldNumber++;</span><br><span class=\"line\">      <span class=\"title function_\">setLineMapping</span>(<span class=\"string\">&quot;old&quot;</span>, currentOldNumber, content);</span><br><span class=\"line\">      currentLine = <span class=\"title function_\">createLine</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;delete&quot;</span>,</span><br><span class=\"line\">        currentOldNumber.<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        content</span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"title function_\">emitCodeModel</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没变</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; change.<span class=\"property\">count</span>!; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> content = change.<span class=\"property\">value</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;\\n&quot;</span>)[i];</span><br><span class=\"line\">      currentNowNumber++;</span><br><span class=\"line\">      currentOldNumber++;</span><br><span class=\"line\">      <span class=\"title function_\">setLineMapping</span>(<span class=\"string\">&quot;old&quot;</span>, currentOldNumber, content);</span><br><span class=\"line\">      <span class=\"title function_\">setLineMapping</span>(<span class=\"string\">&quot;now&quot;</span>, currentNowNumber, content);</span><br><span class=\"line\">      currentLine = <span class=\"title function_\">createLine</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;normal&quot;</span>,</span><br><span class=\"line\">        currentOldNumber.<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">        currentNowNumber.<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">        content</span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"title function_\">emitCodeModel</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这一步处理之后，就会生成 <code>CodeLineModel[]</code> 视图数据了，现在的 <code>CodeLineModel</code> 已经可以直接拿去渲染了。但还没有行内高亮和折叠的功能，所以接下来就基于 <code>CodeLineModel[]</code> 做进一步的处理。</p>\n<h3 id=\"根据-Diff-结果高亮行内文本\"><a href=\"#根据-Diff-结果高亮行内文本\" class=\"headerlink\" title=\"根据 Diff 结果高亮行内文本\"></a>根据 Diff 结果高亮行内文本</h3><p>这一步会将每一行的内容做处理，生成行内高亮数据，也就是 <code>highlightStartIndex</code> 和 <code>highlightLength</code> 部分。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">attachInlineHighlight</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  lineModels.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">lineModel: CodeLineModel</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lineModel.<span class=\"property\">type</span> === <span class=\"string\">&quot;add&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> mapping = lineMapping[<span class=\"title class_\">Number</span>(lineModel.<span class=\"property\">nowLineNumber</span>)];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; index, length &#125; = <span class=\"title function_\">diffLine</span>(<span class=\"string\">&quot;add&quot;</span>, mapping.<span class=\"property\">old</span>, mapping.<span class=\"property\">now</span>);</span><br><span class=\"line\">      lineModel.<span class=\"property\">highlightStartIndex</span> = index;</span><br><span class=\"line\">      lineModel.<span class=\"property\">highlightLength</span> = length;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lineModel.<span class=\"property\">type</span> === <span class=\"string\">&quot;delete&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> mapping = lineMapping[<span class=\"title class_\">Number</span>(lineModel.<span class=\"property\">oldLineNumber</span>)];</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; index, length &#125; = <span class=\"title function_\">diffLine</span>(<span class=\"string\">&quot;delete&quot;</span>, mapping.<span class=\"property\">old</span>, mapping.<span class=\"property\">now</span>);</span><br><span class=\"line\">      lineModel.<span class=\"property\">highlightStartIndex</span> = index;</span><br><span class=\"line\">      lineModel.<span class=\"property\">highlightLength</span> = length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折叠未变化的文本\"><a href=\"#折叠未变化的文本\" class=\"headerlink\" title=\"折叠未变化的文本\"></a>折叠未变化的文本</h3><p>上文处理完后，已经完成了 Diff 组件的大半部分了，接下来就要对一些未改变的行进行折叠。<br><strong>那么，如果知道哪些行要折叠呢？</strong><br>经过之前的数据处理，可以得出，<code>CodeLineModel</code> 中，<code>type = normal</code> 的行，即为未变更的行，那么就可以用一个二维数组，将所有连续未变化的行，做一个分组，代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> processCollapsed&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ILineModel</span>&gt;(<span class=\"attr\">lineData</span>: T[]): T[] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastIsNormal = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">arrs</span>: <span class=\"title class_\">Array</span>&lt;T[]&gt; = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">currentArr</span>: T[] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; lineData.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> model = lineData[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (model.<span class=\"property\">type</span> === <span class=\"string\">&quot;add&quot;</span> || model.<span class=\"property\">type</span> === <span class=\"string\">&quot;delete&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastIsNormal) &#123;</span><br><span class=\"line\">          arrs.<span class=\"title function_\">push</span>(currentArr);</span><br><span class=\"line\">          currentArr = [];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentArr.<span class=\"title function_\">push</span>(model);</span><br><span class=\"line\">        lastIsNormal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (model.<span class=\"property\">type</span> === <span class=\"string\">&quot;normal&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!lastIsNormal) &#123;</span><br><span class=\"line\">          arrs.<span class=\"title function_\">push</span>(currentArr);</span><br><span class=\"line\">          currentArr = [];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentArr.<span class=\"title function_\">push</span>(model);</span><br><span class=\"line\">        lastIsNormal = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arrs.<span class=\"title function_\">push</span>(currentArr);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title function_\">collapsedCodeGroup</span>(arrs, <span class=\"variable language_\">this</span>.<span class=\"property\">contextLineCount</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...result];</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>currentArr</code> - 连续未变更行组成的数组</li>\n<li><code>arrs</code> - 多个 <code>currentArr</code> 组成数组</li>\n</ul>\n<p>处理完成后，就要把 <code>arrs</code> 中的分组数据做一个过滤和筛选，例如折叠行数 &gt; 10 (<code>contextLineCount</code>) 的才折叠等，这部分的代码就是 <code>collapsedCodeGroup</code> 中所处理的逻辑。代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 折叠超过最大行数限制的普通代码</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arrs 分组后的代码数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> collapsedCodeGroup&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ILineModel</span>&gt;(</span><br><span class=\"line\">  <span class=\"attr\">arrs</span>: <span class=\"title class_\">Array</span>&lt;T[]&gt;,</span><br><span class=\"line\">  <span class=\"attr\">context</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">): T[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">result</span>: T[] = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> collapseLimit = context * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">  arrs.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">group, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isNormalGroup = group.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; group[<span class=\"number\">0</span>].<span class=\"property\">type</span> === <span class=\"string\">&quot;normal&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isLastGroup = index === arrs.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isFirstGroup = index === <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (group.<span class=\"property\">length</span> &lt; collapseLimit || !isNormalGroup) &#123;</span><br><span class=\"line\">      result.<span class=\"title function_\">push</span>(...group);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">collapsedLineModel</span>: <span class=\"built_in\">any</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">&quot;collapsed&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">lines</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">isCollapsed</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">lineCount</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFirstGroup) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//是开始</span></span><br><span class=\"line\">      deleteCount = group.<span class=\"property\">length</span> - context * <span class=\"number\">1</span>;</span><br><span class=\"line\">      lines = group.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, deleteCount, collapsedLineModel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLastGroup) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//是结束</span></span><br><span class=\"line\">      deleteCount = group.<span class=\"property\">length</span> - context * <span class=\"number\">1</span>;</span><br><span class=\"line\">      lines = group.<span class=\"title function_\">splice</span>(context, deleteCount, collapsedLineModel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//是中间</span></span><br><span class=\"line\">      deleteCount = group.<span class=\"property\">length</span> - context * <span class=\"number\">2</span>;</span><br><span class=\"line\">      lines = group.<span class=\"title function_\">splice</span>(context, deleteCount, collapsedLineModel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    collapsedLineModel.<span class=\"property\">lines</span> = lines;</span><br><span class=\"line\">    collapsedLineModel.<span class=\"property\">lineCount</span> = lines.<span class=\"property\">length</span>;</span><br><span class=\"line\">    result.<span class=\"title function_\">push</span>(...group);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>context</code> 为折叠代码的上下文，由外部传入。例如 <code>context = 3</code>，那么至少有 <code>3*2 + 1 = 7</code> 行代码时才折叠，少于 7 行就不折叠。且在文本首尾要做特殊处理。</li>\n</ul>\n<h3 id=\"高亮关键字并渲染结果\"><a href=\"#高亮关键字并渲染结果\" class=\"headerlink\" title=\"高亮关键字并渲染结果\"></a>高亮关键字并渲染结果</h3><p>高亮关键字由于使用的是 <code>highlight.js</code> 库，它需要我们在结果渲染之后再高亮，所以仅需如下代码即可：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">root</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">&quot;code&quot;</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">el</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    hljs.<span class=\"title function_\">highlightElement</span>(el <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里将我们每一行的 <code>&lt;code&gt;</code> 标签找到后交给 <code>highlight.js</code> 处理即可。<br><strong>结果渲染：</strong><br>template 模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;line&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;line-number&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;&#123; add: code.type === &#x27;add&#x27;, delete: code.type === &#x27;delete&#x27; &#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      &#123;&#123; code.oldLineNumber &#125;&#125;&lt;/span</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;line-number&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;&#123; add: code.type === &#x27;add&#x27;, delete: code.type === &#x27;delete&#x27; &#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      &#123;&#123; code.nowLineNumber &#125;&#125;&lt;/span</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">code-content</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;line-content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;&#123; add: code.type === &#x27;add&#x27;, delete: code.type === &#x27;delete&#x27; &#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:code</span>=<span class=\"string\">&quot;code&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>CodeContent</code> 组件代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CodeContent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Vue</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Prop</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">    <span class=\"attr\">required</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  code!: <span class=\"title class_\">CodeLineModel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">type</span> === <span class=\"string\">&quot;add&quot;</span> || <span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">type</span> === <span class=\"string\">&quot;delete&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">segmentCodeByIndex</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">getCodeTemplate</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">content</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">getCodeTemplate</span>(<span class=\"params\">content: <span class=\"built_in\">string</span>, className?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">code</span> <span class=\"attr\">class</span>=<span class=\"string\">&#123;className</span> ?? &quot;&quot;&#125;&gt;</span>&#123;content&#125;<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">segmentCodeByIndex</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> content = <span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">content</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">items</span>: <span class=\"built_in\">any</span>[] = [];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">highlightStartIndex</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">getCodeTemplate</span>(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastStartIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">highlightStartIndex</span>!.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">startIndex, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> length = <span class=\"variable language_\">this</span>.<span class=\"property\">code</span>.<span class=\"property\">highlightLength</span>![index];</span><br><span class=\"line\">      items.<span class=\"title function_\">push</span>(content.<span class=\"title function_\">substring</span>(lastStartIndex, startIndex));</span><br><span class=\"line\">      items.<span class=\"title function_\">push</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">getCodeTemplate</span>(content.<span class=\"title function_\">substr</span>(startIndex, length), <span class=\"string\">&quot;hl&quot;</span>)</span><br><span class=\"line\">      );</span><br><span class=\"line\">      lastStartIndex = startIndex + length;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    items.<span class=\"title function_\">push</span>(content.<span class=\"title function_\">substring</span>(lastStartIndex, content.<span class=\"property\">length</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>&#123;items&#125;<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CodeContent</code> 部分主要对 <code>add</code> 和 <code>delete</code> 类型的行内 Diff 做了高亮处理。<br>整体来说，渲染结果这块并不复杂，主要是根据类型调整样式，还有高亮操作。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>….</p>\n","categories":["Web前端"],"tags":["组件","UI"]},{"title":"《沟通的方法》读书笔记","url":"/2022/05/22/method-of-communication/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><span id=\"more\"></span>\n\n<h2 id=\"精华语录\"><a href=\"#精华语录\" class=\"headerlink\" title=\"精华语录\"></a>精华语录</h2><h3 id=\"把对方的信息按照事实、情绪和期待分类处理。\"><a href=\"#把对方的信息按照事实、情绪和期待分类处理。\" class=\"headerlink\" title=\"把对方的信息按照事实、情绪和期待分类处理。\"></a>把对方的信息按照事实、情绪和期待分类处理。</h3><h3 id=\"反馈的逻辑：响应情绪-确认事实-明确行动。要让对方明白我们确实听懂了。\"><a href=\"#反馈的逻辑：响应情绪-确认事实-明确行动。要让对方明白我们确实听懂了。\" class=\"headerlink\" title=\"反馈的逻辑：响应情绪-确认事实-明确行动。要让对方明白我们确实听懂了。\"></a>反馈的逻辑：响应情绪-确认事实-明确行动。要让对方明白我们确实听懂了。</h3><h3 id=\"不同沟通风格的人的特点\"><a href=\"#不同沟通风格的人的特点\" class=\"headerlink\" title=\"不同沟通风格的人的特点\"></a>不同沟通风格的人的特点</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>老虎</th>\n<th>孔雀</th>\n<th>猫头鹰</th>\n<th>考拉</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特征</td>\n<td>控制</td>\n<td>取悦</td>\n<td>谨慎</td>\n<td>温和</td>\n</tr>\n<tr>\n<td>害怕</td>\n<td>失控</td>\n<td>被忽略</td>\n<td>混乱</td>\n<td>变化</td>\n</tr>\n<tr>\n<td>非正常状态</td>\n<td>没目标</td>\n<td>没表现自己</td>\n<td>率先表态</td>\n<td>欣然接受变化</td>\n</tr>\n<tr>\n<td>有效的沟通方式</td>\n<td>目标导向</td>\n<td>肯定他</td>\n<td>有序</td>\n<td>主动维护</td>\n</tr>\n</tbody></table>\n<h3 id=\"肯定反射\"><a href=\"#肯定反射\" class=\"headerlink\" title=\"肯定反射\"></a>肯定反射</h3><p>例如：<br>有价值：</p>\n<ul>\n<li>您的意见一直对我都很重要</li>\n<li>您刚刚说的这些对我太有启发了<br>没有价值：<br>我没想到，您花了这么多时间跟我聊这事儿</li>\n</ul>\n<h3 id=\"目标感的本质是方案力，具有目标感的沟通，不是抱着自己最初的立场不变，而是要把目标实现。\"><a href=\"#目标感的本质是方案力，具有目标感的沟通，不是抱着自己最初的立场不变，而是要把目标实现。\" class=\"headerlink\" title=\"目标感的本质是方案力，具有目标感的沟通，不是抱着自己最初的立场不变，而是要把目标实现。\"></a>目标感的本质是方案力，具有目标感的沟通，不是抱着自己最初的立场不变，而是要把目标实现。</h3><h3 id=\"“我们有一个目标要达成，对此，我有一个方案”\"><a href=\"#“我们有一个目标要达成，对此，我有一个方案”\" class=\"headerlink\" title=\"“我们有一个目标要达成，对此，我有一个方案”\"></a>“我们有一个目标要达成，对此，我有一个方案”</h3><h3 id=\"怎么找到真正的目标？判断马上要做的事和最终要做的事\"><a href=\"#怎么找到真正的目标？判断马上要做的事和最终要做的事\" class=\"headerlink\" title=\"怎么找到真正的目标？判断马上要做的事和最终要做的事\"></a>怎么找到真正的目标？判断马上要做的事和最终要做的事</h3><h3 id=\"6-个月之后法：通过-6-个月后的愿景来倒推当下要做什么。\"><a href=\"#6-个月之后法：通过-6-个月后的愿景来倒推当下要做什么。\" class=\"headerlink\" title=\"6 个月之后法：通过 6 个月后的愿景来倒推当下要做什么。\"></a>6 个月之后法：通过 6 个月后的愿景来倒推当下要做什么。</h3><h3 id=\"找到立即可以执行的最小化行动，是我们把沟通导向行动的起点。\"><a href=\"#找到立即可以执行的最小化行动，是我们把沟通导向行动的起点。\" class=\"headerlink\" title=\"找到立即可以执行的最小化行动，是我们把沟通导向行动的起点。\"></a>找到立即可以执行的最小化行动，是我们把沟通导向行动的起点。</h3><h3 id=\"建设性-可执行的最小化行动-可持续的行动阶梯-每个时间节点的即时反馈\"><a href=\"#建设性-可执行的最小化行动-可持续的行动阶梯-每个时间节点的即时反馈\" class=\"headerlink\" title=\"建设性=可执行的最小化行动+可持续的行动阶梯+每个时间节点的即时反馈\"></a>建设性=可执行的最小化行动+可持续的行动阶梯+每个时间节点的即时反馈</h3><h3 id=\"破冰-双线卡位-展现关切-营造掌控\"><a href=\"#破冰-双线卡位-展现关切-营造掌控\" class=\"headerlink\" title=\"破冰=双线卡位+展现关切+营造掌控\"></a>破冰=双线卡位+展现关切+营造掌控</h3><h3 id=\"和沟通对象破冰，本质上不是展现自己，而是通过给对方营造掌控感，让自己更快的赢得信任，消除彼此的距离感。\"><a href=\"#和沟通对象破冰，本质上不是展现自己，而是通过给对方营造掌控感，让自己更快的赢得信任，消除彼此的距离感。\" class=\"headerlink\" title=\"和沟通对象破冰，本质上不是展现自己，而是通过给对方营造掌控感，让自己更快的赢得信任，消除彼此的距离感。\"></a>和沟通对象破冰，本质上不是展现自己，而是通过给对方营造掌控感，让自己更快的赢得信任，消除彼此的距离感。</h3><h3 id=\"找到他与与所在群体之间差异，才是精准的赞美。赞美行为，而不是赞美禀赋。\"><a href=\"#找到他与与所在群体之间差异，才是精准的赞美。赞美行为，而不是赞美禀赋。\" class=\"headerlink\" title=\"找到他与与所在群体之间差异，才是精准的赞美。赞美行为，而不是赞美禀赋。\"></a>找到他与与所在群体之间差异，才是精准的赞美。赞美行为，而不是赞美禀赋。</h3><h3 id=\"“每个人毕生都在追求的是被看见”\"><a href=\"#“每个人毕生都在追求的是被看见”\" class=\"headerlink\" title=\"“每个人毕生都在追求的是被看见”\"></a>“每个人毕生都在追求的是被看见”</h3><h3 id=\"激励-即时赞美-行为建模-反馈闭环\"><a href=\"#激励-即时赞美-行为建模-反馈闭环\" class=\"headerlink\" title=\"激励=即时赞美+行为建模+反馈闭环\"></a>激励=即时赞美+行为建模+反馈闭环</h3><h3 id=\"说服-说话有分量-凿穿心理防线\"><a href=\"#说服-说话有分量-凿穿心理防线\" class=\"headerlink\" title=\"说服=说话有分量+凿穿心理防线\"></a>说服=说话有分量+凿穿心理防线</h3><ol>\n<li>有分量 = 强准别</li>\n<li>凿穿心理防线 = 吹风+慢熬</li>\n</ol>\n<h3 id=\"每一个抵抗的情绪背后都有尚未满足的需要\"><a href=\"#每一个抵抗的情绪背后都有尚未满足的需要\" class=\"headerlink\" title=\"每一个抵抗的情绪背后都有尚未满足的需要\"></a>每一个抵抗的情绪背后都有尚未满足的需要</h3><h3 id=\"教行动方法，不教价值观，是辅导的基本准则\"><a href=\"#教行动方法，不教价值观，是辅导的基本准则\" class=\"headerlink\" title=\"教行动方法，不教价值观，是辅导的基本准则\"></a>教行动方法，不教价值观，是辅导的基本准则</h3><h3 id=\"辅导-植入目标-发现盲区-实战演习\"><a href=\"#辅导-植入目标-发现盲区-实战演习\" class=\"headerlink\" title=\"辅导 = 植入目标 + 发现盲区 + 实战演习\"></a>辅导 = 植入目标 + 发现盲区 + 实战演习</h3><h3 id=\"复盘的操作，不应局限于分析哪里做得好，哪里做的不好，还应该更关注思考的过程。\"><a href=\"#复盘的操作，不应局限于分析哪里做得好，哪里做的不好，还应该更关注思考的过程。\" class=\"headerlink\" title=\"复盘的操作，不应局限于分析哪里做得好，哪里做的不好，还应该更关注思考的过程。\"></a>复盘的操作，不应局限于分析哪里做得好，哪里做的不好，还应该更关注思考的过程。</h3><h3 id=\"选择与淘汰员工，都比辅导来的更重要。\"><a href=\"#选择与淘汰员工，都比辅导来的更重要。\" class=\"headerlink\" title=\"选择与淘汰员工，都比辅导来的更重要。\"></a>选择与淘汰员工，都比辅导来的更重要。</h3><h3 id=\"安慰的前提是能感受他人的安慰\"><a href=\"#安慰的前提是能感受他人的安慰\" class=\"headerlink\" title=\"安慰的前提是能感受他人的安慰\"></a>安慰的前提是能感受他人的安慰</h3><h3 id=\"安慰-轻度介入-提供支持\"><a href=\"#安慰-轻度介入-提供支持\" class=\"headerlink\" title=\"安慰 = 轻度介入 + 提供支持\"></a>安慰 = 轻度介入 + 提供支持</h3><h3 id=\"批评-控制环境-定义问题-刷新动作-设定反馈点-完成重启\"><a href=\"#批评-控制环境-定义问题-刷新动作-设定反馈点-完成重启\" class=\"headerlink\" title=\"批评 = 控制环境 + 定义问题 + 刷新动作 + 设定反馈点 + 完成重启\"></a>批评 = 控制环境 + 定义问题 + 刷新动作 + 设定反馈点 + 完成重启</h3><h3 id=\"提意见-事前征求同意-定义双方关系-提供具体建议\"><a href=\"#提意见-事前征求同意-定义双方关系-提供具体建议\" class=\"headerlink\" title=\"提意见 = 事前征求同意 + 定义双方关系 + 提供具体建议\"></a>提意见 = 事前征求同意 + 定义双方关系 + 提供具体建议</h3><h3 id=\"绩效面谈的目的不是盖棺论定，而是开启未来。\"><a href=\"#绩效面谈的目的不是盖棺论定，而是开启未来。\" class=\"headerlink\" title=\"绩效面谈的目的不是盖棺论定，而是开启未来。\"></a>绩效面谈的目的不是盖棺论定，而是开启未来。</h3><h3 id=\"绩效面谈-营造正式感-换框架\"><a href=\"#绩效面谈-营造正式感-换框架\" class=\"headerlink\" title=\"绩效面谈 = 营造正式感 + 换框架\"></a>绩效面谈 = 营造正式感 + 换框架</h3><ul>\n<li>营造正式感：时间、空间、话语</li>\n<li>换框架：让员工在更加全局的视角看待自己的工作</li>\n</ul>\n<p>换框架示例：</p>\n<ol>\n<li>你知道明年公司最重要的目标是什么吗？</li>\n<li>你知道公司的目标对咱们部门意味着什么吗？</li>\n<li>你知道这对你意味着什么吗？</li>\n</ol>\n<h3 id=\"对绩效结果评价需要非常标准和清晰，且针对性行动也需要足够清晰。\"><a href=\"#对绩效结果评价需要非常标准和清晰，且针对性行动也需要足够清晰。\" class=\"headerlink\" title=\"对绩效结果评价需要非常标准和清晰，且针对性行动也需要足够清晰。\"></a>对绩效结果评价需要非常标准和清晰，且针对性行动也需要足够清晰。</h3><h3 id=\"主持会议-行为设计-全程控场\"><a href=\"#主持会议-行为设计-全程控场\" class=\"headerlink\" title=\"主持会议 = 行为设计 + 全程控场\"></a>主持会议 = 行为设计 + 全程控场</h3><p>行为设计：</p>\n<ol>\n<li>设计场地</li>\n<li>设计时间</li>\n<li>设计环境</li>\n<li>设计规则</li>\n</ol>\n<p>全程控场：（主持）</p>\n<ol>\n<li>会前积极跑动</li>\n<li>开场自我赋能（简洁、直白，不宜太刷存在感）</li>\n<li>会中敢于干预</li>\n<li>结束出口成章（把每个人的意见都纳入进来）</li>\n</ol>\n<h3 id=\"会议纪要的核心要素是决议\"><a href=\"#会议纪要的核心要素是决议\" class=\"headerlink\" title=\"会议纪要的核心要素是决议\"></a>会议纪要的核心要素是决议</h3><h3 id=\"会前寒暄：请教周围同事最近发生的事情或问题。\"><a href=\"#会前寒暄：请教周围同事最近发生的事情或问题。\" class=\"headerlink\" title=\"会前寒暄：请教周围同事最近发生的事情或问题。\"></a>会前寒暄：请教周围同事最近发生的事情或问题。</h3><h3 id=\"道歉-关闭过去-承诺未来\"><a href=\"#道歉-关闭过去-承诺未来\" class=\"headerlink\" title=\"道歉 = 关闭过去 + 承诺未来\"></a>道歉 = 关闭过去 + 承诺未来</h3><p>关闭过去：</p>\n<ol>\n<li>道歉越早，代价越小</li>\n<li>分开处理道歉和弥补损失</li>\n<li>态度诚恳</li>\n<li>接纳对方的情绪</li>\n</ol>\n<p>承诺未来：</p>\n<ol>\n<li>带着新方案</li>\n<li>上个请教</li>\n<li>上个小礼物</li>\n</ol>\n<h3 id=\"道歉的终极奥义不是承认我错了，而是承认你是对的\"><a href=\"#道歉的终极奥义不是承认我错了，而是承认你是对的\" class=\"headerlink\" title=\"道歉的终极奥义不是承认我错了，而是承认你是对的\"></a>道歉的终极奥义不是承认我错了，而是承认你是对的</h3><h3 id=\"调解矛盾-处理情绪-重建目标-最小改善\"><a href=\"#调解矛盾-处理情绪-重建目标-最小改善\" class=\"headerlink\" title=\"调解矛盾 = 处理情绪 + 重建目标 + 最小改善\"></a>调解矛盾 = 处理情绪 + 重建目标 + 最小改善</h3><p>处理情绪：接纳对方情绪<br>重建目标：清晰冲突者的目标<br>最小改善：设定一个和目标相关最小化、可立即执行的动作，且不和矛盾相关。</p>\n<h3 id=\"求助-别人帮得了-自己值得帮\"><a href=\"#求助-别人帮得了-自己值得帮\" class=\"headerlink\" title=\"求助 = 别人帮得了 + 自己值得帮\"></a>求助 = 别人帮得了 + 自己值得帮</h3><p>别人帮得了：</p>\n<ol>\n<li>时间和精力上可以启动</li>\n<li>在职责边界内科启动</li>\n<li>在关系程度内可启动</li>\n</ol>\n<p>自己值得帮：</p>\n<ol>\n<li>先干为敬</li>\n<li>真诚领情</li>\n</ol>\n<h3 id=\"求助的本质是发起一次协作\"><a href=\"#求助的本质是发起一次协作\" class=\"headerlink\" title=\"求助的本质是发起一次协作\"></a>求助的本质是发起一次协作</h3><h3 id=\"拒绝-开门见山-移花接木\"><a href=\"#拒绝-开门见山-移花接木\" class=\"headerlink\" title=\"拒绝 = 开门见山 + 移花接木\"></a>拒绝 = 开门见山 + 移花接木</h3><p>开门见山：直接拒绝，找到真实存在的理由。<br>移花接木：表明态度，给出替代方案</p>\n<h3 id=\"即兴发言-万能开头-谈感受-谈行动\"><a href=\"#即兴发言-万能开头-谈感受-谈行动\" class=\"headerlink\" title=\"即兴发言 = 万能开头 + 谈感受 / 谈行动\"></a>即兴发言 = 万能开头 + 谈感受 / 谈行动</h3><p>万能开头：不贴负面标签，不增加冗余信息<br>谈感受 / 谈行动：素材来源于现场，烘托氛围，给别人捧场。</p>\n<h3 id=\"即兴发言不是毫无准备的讲话，它不能准备稿子，但一定要“准备意识”\"><a href=\"#即兴发言不是毫无准备的讲话，它不能准备稿子，但一定要“准备意识”\" class=\"headerlink\" title=\"即兴发言不是毫无准备的讲话，它不能准备稿子，但一定要“准备意识”\"></a>即兴发言不是毫无准备的讲话，它不能准备稿子，但一定要“准备意识”</h3><h3 id=\"闲谈-传递尊重-传递价值\"><a href=\"#闲谈-传递尊重-传递价值\" class=\"headerlink\" title=\"闲谈 = 传递尊重 + 传递价值\"></a>闲谈 = 传递尊重 + 传递价值</h3><p>传递尊重：</p>\n<ol>\n<li>上个请教 - 对方擅长的领域，明确的场景性问题、粒度不宜太大</li>\n<li>多给一点 - 提出开放性问题</li>\n<li>深度破冰 - 寻找与这些人有特殊关系的事件和故事，可以强准备</li>\n<li>管理人设 - 聊一些符合自己人设的话题，不符合人设的话题，即时懂也少聊。注意边界，三观类话题不适合闲谈。</li>\n</ol>\n<p>传递价值：让对方感受好，有收获感。</p>\n<h3 id=\"提案-汇报-融目标-抢进度-提诉求\"><a href=\"#提案-汇报-融目标-抢进度-提诉求\" class=\"headerlink\" title=\"提案/汇报 = 融目标 + 抢进度 + 提诉求\"></a>提案/汇报 = 融目标 + 抢进度 + 提诉求</h3><p>融目标：将提案的目标和客户的目标融合起来<br>抢进度：增强说服力和责任担当</p>\n<ul>\n<li>抢影响实质性结果的工作（帮助决策的工作）</li>\n<li>把展现自己决心的工作往前做</li>\n</ul>\n<h3 id=\"竞聘不是为了输赢，而是表现未来长远的信心\"><a href=\"#竞聘不是为了输赢，而是表现未来长远的信心\" class=\"headerlink\" title=\"竞聘不是为了输赢，而是表现未来长远的信心\"></a>竞聘不是为了输赢，而是表现未来长远的信心</h3><h3 id=\"我们可以不看重当时当下那场“有限游戏”的输赢，但要努力争取在无限游戏中向前迈进一大步。\"><a href=\"#我们可以不看重当时当下那场“有限游戏”的输赢，但要努力争取在无限游戏中向前迈进一大步。\" class=\"headerlink\" title=\"我们可以不看重当时当下那场“有限游戏”的输赢，但要努力争取在无限游戏中向前迈进一大步。\"></a>我们可以不看重当时当下那场“有限游戏”的输赢，但要努力争取在无限游戏中向前迈进一大步。</h3><h3 id=\"竞聘-请战\"><a href=\"#竞聘-请战\" class=\"headerlink\" title=\"竞聘 = 请战\"></a>竞聘 = 请战</h3><ol>\n<li>肯定现状</li>\n<li>详述接下来的具体事项</li>\n</ol>\n<h3 id=\"竞聘-肯定现有战场-我的独特打发-我的充分准备\"><a href=\"#竞聘-肯定现有战场-我的独特打发-我的充分准备\" class=\"headerlink\" title=\"竞聘 = 肯定现有战场 + 我的独特打发 + 我的充分准备\"></a>竞聘 = 肯定现有战场 + 我的独特打发 + 我的充分准备</h3><p>注意事项：</p>\n<ol>\n<li>不要说前任的坏处，要肯定现有战场</li>\n<li>不要摆过去的功劳，要讲未来的打算</li>\n<li>不要说对未来的畅想，要说对未来的抓手</li>\n<li>不要光讲准备，还要突出个人特质</li>\n<li>不要因为落选闹情绪，要备好败选方案</li>\n</ol>\n"},{"title":"《非暴力沟通》读后感","url":"/2020/06/10/nonviolent-communication-after-reading/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>《非暴力沟通》一书的阅读，源于网络的推荐。一些公众号的博主和一些鸡汤文章都在推荐这本书，再结合自己的表达能力和沟通能力还有很大提高的空间，所以我决定在阅读《深度思维》之后，立刻开始了这本书的阅读。<br>这本书并不像工具类书籍提供了很多方法论和直接实用的技巧，而是通过很多故事和诗，来讲述非暴力沟通的核心与价值。本书深入的讲解了如何倾听、倾诉，以及在倾听和倾诉之后的收获。<br>我认为这不仅在人与人的沟通中很有价值。同时，在医学中精神病学的相关治疗上，也有很大的价值。本书的作者也是一名心理医生，在相关领域以非暴力沟通的方式做出过卓越的贡献。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>本书有十三章，从浅入深的讲述非暴力沟通。前言和第 1、2 章描述的是「爱」，非暴力沟通的目的便是让爱融入生活。第 3 到第 6 章讲述了非暴力沟通的表达，第 7，8 章讲述的是「倾听」，第 9 到第 13 章讲述的是以自我情绪控制的角度，如何对自己应用非暴力沟通。</p>\n<h2 id=\"1-2-爱\"><a href=\"#1-2-爱\" class=\"headerlink\" title=\"1 - 2 爱\"></a>1 - 2 爱</h2><p>非暴力沟通的四个要素：观察，感受，需要，请求。它鼓励倾听，培育尊重与爱。作者以多个例子，以及作者个人的亲身经历来告诉我们，使用非暴力沟通，会让语言暴力减少，让沟通变得更有爱。<br>前两章的阅读，让我意识到语言的暴力性。对于我自己来说，很多时候说话，本能的会带有很多评论性的词汇和语句，这样的语言可能会对对方造成困扰。更好的表达方式是客观的描述事实，尽量避免带有评论性的词语。</p>\n<h2 id=\"3-6-表达\"><a href=\"#3-6-表达\" class=\"headerlink\" title=\"3 - 6 表达\"></a>3 - 6 表达</h2><p>非暴力沟通的表达方式需要考虑四要素：观察，感受，需要，请求。按照这个顺序表达有益于他人了解我们想要给他们的信息，且不会造成伤害。这里要区分的是观察、感受和评论和想法。评论和想法往往会带有主观性，表达评论和想法时，会让对方认为因为某种事实而引起了我主观的想法。而真正主观的想法并不是源于事实，而是源于自身。</p>\n<h2 id=\"7-8-倾听\"><a href=\"#7-8-倾听\" class=\"headerlink\" title=\"7 - 8 倾听\"></a>7 - 8 倾听</h2><p>本章的内容主要讲述了以暴力沟通的方式倾听时，需要全身心的投入到对方的言语当中，提取对方言语中的四要素，并作出反馈。<br>这些案例和方法给了我极大的震撼，他讲述了什么时候需要倾听，区分对方需要的是倾听还是安慰，如何在倾听的时候给出合适的反馈以及反馈的误区。这一章的案例和内容解决了我心中的困惑。有些时候，在面对倾诉时，我会显得有些不自然，不知道怎么回复，也不知道说什么。有的时候，错误的沟通的方式，反而会让自己的好心得不到表现，甚至可能造成伤害。</p>\n<h2 id=\"9-13-情绪控制\"><a href=\"#9-13-情绪控制\" class=\"headerlink\" title=\"9 - 13 情绪控制\"></a>9 - 13 情绪控制</h2><p>这一部分包含的章节有「爱自己」、「充分表达愤怒」、「运用强制力避免伤害」、「重获生活的热情」、「表达感激」。这些章节专注于解决自身的问题。每一章都在强调自我的需要。无论是愤怒还是感激，抑郁还是困扰，都可以围绕自我的需要来做出解决方案。我们的情绪产生归根于自我的需要，在表达愤怒时，命令式口吻往往更容易在短期内产生你想要效果。但相应的也会有负面效果产恒，那就是会让被命令认为是因为你的命令而这么做。而不是去思考，这么做本身的意义和价值。在教育的场景，常常也会伴生着抵触情绪。<br>「爱自己」和「重获生活的热情」两章中讲述了如何解决自我的困扰。这些内容也给了我极大的冲击，我生活中总是有各种各样的困扰伴随着我。这些困扰有的会让我深陷其中，难以自拔。这些内容给了我启发，从非暴力沟通的角度，去解决这些困扰。</p>\n","categories":["读书"]},{"title":"《原则》读书笔记","url":"/2021/01/17/principles-after-reading/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《原则》、《价值》、《影响力》是我接下来将会读的 3 本书，《原则》是第一本。这三本书同样是经人推荐很适合互联网行业的从业者阅读。虽然现在还不知道书中到底讲了些啥，但从书名上已经能感受出牛逼的气息。希望阅读之后，我也能越来越牛逼！</p>\n<span id=\"more\"></span>\n\n<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>《原则》一书的内容主要分为三个部分：</p>\n<ol>\n<li>作者的经历</li>\n<li>生活原则</li>\n<li>工作原则</li>\n</ol>\n<p>本书的核心思想是将我们自身的价值观、为人出事方式、对事物的总结和反思等思考方向的内容总结成一条一条的原则，并写出来，通过阅历的提升，将这些原则不断优化，并在生活和工作中，通过这些原则指引着我们决策。<br>在导言中，作者不止一次的强调，通过原则做决策的准确性和高效性。以及在人与人之间，不同的人不同的原则所造成的影响。<br>在我的视角中，“原则”是高度抽象化的，可以应对多个场景且具备指导意义的内容。我认可“原则”的存在，以及原则的重要性。<br><strong>自己思考：你想要什么？事实是什么？如何行动？</strong></p>\n<h2 id=\"我的历程\"><a href=\"#我的历程\" class=\"headerlink\" title=\"我的历程\"></a>我的历程</h2><p>时间就像一条河流，载着我们顺流而下，遇到现实，需要决策，但我们无法停留，也无法回避，只能以最好的方式应对。<br>作者在「我的历程」一章中讲述了自己传奇般一生，从学生时期的「初探」，到「入门」、「进阶」，再到「低谷」，再从低谷中爬起，继续到「试炼」，而后走向「巅峰」，最后回报「恩惠」。这让我想起了小时候看过的电视剧和小说，那些带有主角光环的人的经历。比起那些，作者的历程更加真实，看着他一步一步走到最后，看着他信奉的「原则」理论，并一直坚持到现在，不由得让我感叹他对「原则」上的付出和执着。与其他许多成功者不同的是，机遇在他的历程中显得不那么耀眼，这一路上，他一直以极度求真的态度来对待投资、工作和生活，将自己的想法与实践结合，最终让他在投资领域独树一帜，被誉为「投资界的乔布斯」。<br>在阅读的过程当中，作者给我的感触可以总结为二字：坚韧。对待真实而残酷的金融行业，他以「坚」为剑，一次又一次的与风云变化的投资市场博弈，时而一败涂地，时而一飞冲天，最终形成了以稳为最重要的投资决策理念。在作者的「投资机器」准确度预测超过 80% 的情况下，对于每一项决策，依然会有足够的思考来应对这 20% 失败的可能性，而最终的决策，往往会为了对冲这 20% 的失败可能性，而导致放弃一倍以上的利润。这一点值得我们思考，在我们日常生活中，特别是在做我们很有把握的事情时，往往容易因为自信导致忽视缺陷，虽然大部分情况下，我们能把事情做好。但如果遇到意外，我们就会失败。如何去权衡自己在生活和工作的每一项决策，如何应对那些高概率事件和低概率事件，也是我们需要去思考和权衡的。他以「韧」为盾，应对着自己的生活和家庭。他以一种极度开放的态度对待身边的同事和朋友，希望大家都追求事实真相，有什么说什么，互利共赢。在家庭中，他也扮演了一位很好的角色。给我印象最深刻的是，他的儿子保罗患有精神疾病，时而出现极度的躁狂，时而陷入深度的抑郁，在痛苦的悬崖边摇摇欲坠时，他也一直尽自己所能帮助和陪伴着儿子共渡难关。最终他的儿子完成了涅槃重生，突破自我战胜疾病，过上了幸福的生活，事业上也小有成就，同时也一直在帮助和他一样处在被精神疾病困扰的人们。<br>聊聊对这一章节的思考吧，这一章节的核心内容是作者结合自己的经历，讲述「原则」对自己经历的影响，以及「原则」的进化历程。「原则」的作用是用来决策，作者相信那些未来没有发生的事情都是历史重演，在历史的某个时刻，一定发生过类似的事情，而类似的事情也一定产生过相似的结果。所以可以通过历史发生的事情，总结出一条一条的原则，再通过这些原则，去决策当下的事情，通过当下的结果反馈和历史的事件反馈，总结原因，不断优化和精进这些原则，最终保证通过「原则」来决策的准确性。这一思路的理念我是非常赞同的，以我们程序员的话来说，「原则」就是高度抽象的代码，可以代表其抽象程度下的任何内容。通过不断对历史发生的事件进行抽象，建立起一套完善的决策模型。这一思路看起来很完美，作者应用的效果也不错，使用这一思路打造的投资机器，能达到 80% 的准确性。但如果要真正在我们的工作和生活中应用这一思路是很困难的，且不是说作者花费了多大的人力物力和 30 多年的时间来优化这一算法模型。对我们普通的个人来说，往往不可能做到这样的程度，但这并不代表作者的思路是没有用的。对于我们普通个人来说，总结出「原则」这一步是很有必要的，这一步倡导我们去思考和抽象过去发生的事和当下发生的事情，对于未来没有发生的事情，我们并不是只能束手无策，虽然我们无法预知未来，但可以通过这样的「原则」思路，不断抽象和总结，从而提高对未来决策的准确性，这样做，总比什么都不做会好一些。没有做过的事情对于每个人一样都有很多很多，而能在第一次做就把事情做好，是一个很重要的潜质，而「原则」思想就是拥有这一潜质的途径之一。</p>\n<h2 id=\"生活原则\"><a href=\"#生活原则\" class=\"headerlink\" title=\"生活原则\"></a>生活原则</h2><p>「考察影响你的那些事物的规律，从而理解背后的因果关系，并有效应对这些事物的原则」。<br>思考并决定：   </p>\n<ol>\n<li>你想要什么</li>\n<li>事实是什么</li>\n<li>面对事实，如何实现自己的愿望，而且保持谦逊和心胸开阔，以便能动用自己的最佳思维   </li>\n</ol>\n<p>生活原则一章讲了 5 个主题，分别是「拥抱现实，应对现实」、「用五步流程实现你的人生愿望」、「做到头脑极度开放」、「理解人与人大不相同」和「学习如何有效决策」。这 5 个主题涵盖了生活中的决策、社交、情绪、应变、思考和理想。我认为这一章节的内容是本书的核心，这些原则在生活中随处可见，也随处可用，同时亦可用于工作、学习中的各类情况。<br>「拥抱现实，应对现实」一节突出了进化在人类历史长河中的作用，并结合我们日常的各类事情，得出结论：我们进步的本质其实是在进化。开始看这一节的时候，有些似懂非懂，我心里想作者给我讲进化论干嘛。看完后才明白，我们每一次微小的学习和进步，都会为进化做贡献，而学习与进步的原则，同样来源于进化。<br>「用五步流程实现你的人生愿望」一节讲述的是一个非常经典的成长模型，对于我们这类程序员来说并不陌生。“目标 -&gt; 问题 -&gt; 诊断 -&gt; 方案 -&gt; 践行” 5 步走，无论是用在产品的迭代、运营的增长、研发的性能提升还是其他各个领域，这 5 步都很好理解，也是我们每个人的必经之路。<br>「做到头脑极度开放」一节从人体大脑个构造开始，生活中各种各样的思考和想法，都是因为大脑的构造而引起的，头脑开放可以帮助我们的思考和想法达到更优的效果，而要做到头脑极度开放，是一件并不容易的事情。这一节给了我很大的启发，首先，什么是「头脑极度开放」呢？作者给出的定义是使用头脑的「上层」（理性）思考，而不受到「下层」（情绪与本能）的影响。结合我个人在生活中的理解，我认为「头脑极度开放」也可以理解为极致的“就事论事”，以更优的结论为唯一目标，不受到情绪和本能的影响，所谓能做最好决策的人不会认为自己的决策是最正确的。正是这样的心态和思考方式，可以让自己不断的优化和接纳其他思考者的意见，从而弥补自己的思维盲点和认知障碍，得到更好的答案。<br>「理解人与人大不相同」一节，同样是从人类的发展与人体的构造为起点，告诉我们人与人之间思想上的区别。左脑思考，右脑思考、宏观规划，探究细节等都是每个人所具备的能力，每个人始终擅长其一，而不会都擅长。基于这个理论，就不难得出，两种人相互配合，相互做到头脑极度开放，同时解决一个问题时，能发挥出巨大的优势，这也是「三个臭皮匠赛过诸葛亮」的原因了。<br>「学习如何有效决策」一节讲述了决策原则和一些常见误区，这一节我认为是《金字塔原理》的抽象模型和一些数学理论结合，告诉我们正确的决策应该符合哪些原则。决策最大的威胁是情绪，保持一个稳定而理性的情绪下做决策是最基本也是最重要的。<br>纵观整个「生活原则」一章，有一块内容给了我非常深刻的印象。作者有一次去医院体检，体检出食管有新生组织的情况，第一位专家诊断后得出可能是食管癌的前兆，并要求动手术，轻则进食残疾，重则会有生命危险。起初作者很相信专家，决定做手术，并交代好了后事，做好了自己就快要凉了的准备。但后来作者意识到人的思维盲点和认知障碍可能存在于这件事情之后，同时将这个检查报告交予了其他几位专家，这几位专家分别给出了不同的建议，其中并不是非要动手术。随后，作者将这些专家召集起来，一起讨论，一开始，专家们为了互相不丢颜面，都肯定对方的观点是合理的，可接受的。但在作者的不断引导下，大家最后得出了更优的结论，处理方式是持续观察，每 3 个月拍一次片，检查组织生长情况，如果异常，及时遏制。直至 3 年之后，也没有演变为癌症。通过这个事情，很多人可能会说，专家可能是「砖家」，瞎忽悠，骗人等等词语。但我认为，专家是真的专家，但之所以没有做出最优解的原因也很好理解，在第一位专家的生涯中，无数诊断过的病人已经让他形成了这样的认知，有 A 症状，就用 B 方式处理。这种方式并不能算错，只是不是最优解而已。但由于有这样的认知，让他忽略的了从其他角度寻找最优解的视角，而每个专家，都有这样的问题，从而每个专家得出的结论都不一致。当他们坐在一起，互相交换观点，仔细理解其他人的思考之后，便可以得出更好的结论。在我们的日常生活中这样的事情随处可见，试想，连权威的专家都有这样的情况，更何况我们平日里去的医院，做的决策等等。而我们又很容易 100% 信任医院里的医生，也很容易认为自己已经很了解某件事，认为自己很对，而对这件事的其他观点置之不理。而这些，正是头脑还不足够开放表现。   </p>\n<h2 id=\"工作原则\"><a href=\"#工作原则\" class=\"headerlink\" title=\"工作原则\"></a>工作原则</h2><blockquote>\n<p>任何组织或机构，若想正常运转，其工作原则必须与其成员的生活原则相契合。</p>\n</blockquote>\n<p>工作原则是生活原则在工作场景的应用，作者主要站在企业管理者的视角讲述一个遵守「极度求真」、「极度透明」、「创意择优」的企业应该是什么样的。我将会从企业、决策、效率、用人 4 个层面来说说我对工作原则一章的理解和思考。</p>\n<h3 id=\"企业-文化-人\"><a href=\"#企业-文化-人\" class=\"headerlink\" title=\"企业 = 文化 + 人\"></a>企业 = 文化 + 人</h3><p>作者将一个企业比喻成一部机器，其中最重要的两个部分是「文化」和「人」。其中文化部分要求企业做到不掩盖问题，公开妥善解决，一切以企业和人向好的方向出发为基础的公司文化。人的部分要求每个人都具备上文「生活原则」中提到的能力。<br>企业 = 文化 + 人，这个等式本身我认为是很合理的，无论是一个大型企业还是小团队，文化和人决定了这个群体的能力。作者提出的观点很理想也很开放，希望文化和人都达到本身全篇所论证的那几点。但其实看看我们中国当下的情况，哪怕是群体素质很高的顶级互联网公司，也并没有完全采取作者的那一套理论和思路。也许是中国国情和文化的影响，在我阅读了作者公司的情况和我们现有公司的情况做对比时，我感受到了巨大的差异，这种差异让我觉得作者的理论虽然很正确，很客观。但几乎不可能在一个中国式公司或团队中得到很好的应用，大家都会受到环境的影响，而在中国，这个环境带来一些观点和作者的观点有巨大冲突。例如我们人尽皆知的需要企业「高情商」或「政治正确」的行为，在作者的观点中，是需要避免的。</p>\n<h3 id=\"决策\"><a href=\"#决策\" class=\"headerlink\" title=\"决策\"></a>决策</h3><p>决策部分的内容是我认为对像我一样的基层员工非常有价值的部分，我非常认可作者的观点。作者提出一个良好的决策应该由一个主要决策人和其他人一起形成的「基于可信度加权的创意择优」机制。这个机制是怎么玩的呢？首先每个人都有自己在该领域的得分，这个得分的来源于你在该领域的可信度（经验、影响力、能力等综合评估）。然后每个人提出的观点都会基于这个人的可信度计算，最终形成的决策里，获得可信度最高的决策被认为是更好的决策。<br>你可能会问，这样的决策方式也有风险，也有可能是错误的。当然，任何决策都有错误的风险，而这种决策方式相比传统决策的模式，可以将风险降低。这套机制也允许主要决策人推翻机制产生的结论，但必须给出非常充分和更加可信的理由让他人信服。在桥水几十年的决策中，这样的决策方式从未被推翻过，也少有失手过。<br>其实，在我看来，这个机制的核心依然是「人」，要求企业内需要有具备高可信度的人，而这套机制适用于具备可信度的人较多时，如何产出决策。</p>\n<h3 id=\"协作效率\"><a href=\"#协作效率\" class=\"headerlink\" title=\"协作效率\"></a>协作效率</h3><p>「群体智商小于个人智商」，这个观点我在很多地方都看到过，作者也是这么认为的。作者提出的观点是：3 - 5 个具备高可信度的人可形成最佳的群体智商。<br>参与的人一旦多起来，观点就会趋近于大众所能接受的方向转化，更像是群体意见的「交集」，而这个方向往往不是最好的。真正能提出建设性意见的人并不多，所以作者认为 3 - 5 个大佬一起讨论是一个最佳人数，这个观点要求这些人每个人都具备高可信度，能提出建设性意见，并且能看到别人所看不到的地方，再把这些地方加以优化，真正的做到最终意见是每个人产出的「并集」。<br>这一点在我们开会时常有体现，很多会议有一个误区，为了达到所谓的「民主」和「共同认可」，有些核心决策的制定会让所有人都参与进来，而所有人里面有很大一部分人不具备决策这个事情的能力，他们更多的是想当然的怎么样，没有进行过深入的思考，也谈不上有经验，所以他们的意见往往参考价值不。所谓专业的人做专业的事，想要更好的决策和意见，一定需要一些专业的人来制定和讨论。当然，这也是为什么公司战略级问题需要公司高层讨论，而不会让每一位员工来投票表决公司战略了。</p>\n<h3 id=\"用人\"><a href=\"#用人\" class=\"headerlink\" title=\"用人\"></a>用人</h3><p>本章中给我印象最深刻的就是用人部分的内容了，用人部分的内容将「极度求真、透明」贯彻到了极致，在大多数人眼里，也许带有一丝「无情」在里面。这里的无情不是说企业是逐利的，兔死狗烹这样类型的。而是在用人时，对人的要求和判断上，公司只用符合「生活原则」的人。公司的一切岗位晋升、岗位调整、薪资福利等制度都是围绕「生活原则」展开。对于符合「生活原则」的人，会喜欢这样公司的制度，并全身心的投入进去，从而获得公司利益和自己利益的双赢。而对于不符合「生活原则」的人，会讨厌公司这样的制度，因为他们在这个制度下不会受益，甚至会被开除。<br>结合我的认知来讲，这也是和中国文化有着巨大差异的地方。兴趣和工作相结合，是我们每个人都希望达到的，在桥水，公司希望员工都是兴趣和工作相结合的，希望员工能够站在公司的角度工作，而不只是个人。员工不光需要具备「主人翁意识」，还需要拥有极度开放的心态和合格的专业能力，能同时达到这三点的人被作者称为企业最需要的人，当然对于这样的人，作者非常愿意投入资金去留住他们，确保他们能有足够的经济基础。回看我知道的公司，对于这样的人，同样每家公司都会非常喜欢得到，但许多公司只是想要这样的人，却没有一套针对这类人的制度体系和生态。「主人翁意识」、「极度求真和透明」、「极度开放的心态」都是需要企业文化和人的支撑的，以当下的行业情况来看，能支撑这样的企业屈指可数。互联网行业的情况稍好，传统行业的情况更糟，这导致许多拥有这些特质的人被埋没，甚至会因为公司的环境而被迫改变。<br>当然，并不是说作者的这一套用人体系就很完美，没有缺点。每种方案和体系都具备两面性，\b\b这里我不去论证谁的优点是什么，谁的缺点是什么。作者想带给我们的，是一个极度求真、透明、开放的价值观的企业会如何管理一个公司的，这些观点也许不完全适合我们，但一定会给我们带来启发。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本章给我最大的感受是：很惊叹桥水做到了这些，并且成功了。<br>除了桥水之外，我所了解的没有其他公司能够做到桥水这样的程度，当然，做到上文这些标准，也不是一家公司想改就能改的。本章给我带来的信息里，我认为实用性不如「生活原则」一章来的实在，「工作原则」更多给的是一个案例，而这个案例能有什么样的启发，就因人而异了，就像给了你一份大餐，不同的人品尝会得出不同的味道。\b</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，本书已经接近看完了。本书的内容让我想起了另外一本书《深度思维》，《原则》像是比《深度思维》更加底层的书籍，从科学的理论和实践的经验出发来指导生活和工作。<br>头脑极度开放、极度求真、极度透明、创意择优等词贯穿了全文。就如书名一样，这些抽象出来的一条一条的原则，是指引工作和生活的基础理论。结合自身的收获，如果让我评价这本书的价值，我认为本书是一本非常值得去阅读的一本书，无论是对于学生、求职者、管理者来说，原则的通用性让其可以对任何视角都有启发。</p>\n","categories":["读书"]},{"title":"《金字塔原理》读书笔记","url":"/2020/06/27/pyramid-principle-after-reading/","content":"<h2 id=\"读书之前\"><a href=\"#读书之前\" class=\"headerlink\" title=\"读书之前\"></a>读书之前</h2><p>《金字塔原理》 - 麦肯锡经典培训教材，一听就觉得这本书相当的牛逼。\b我读书有看前言和序言的习惯，这一段往往是说这本书的主要内容和多么多么牛逼。看完之后，成功的勾起了我的阅读兴趣，有一种我看完就能智力 +10 的感觉。好了，开始阅读吧。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、表达的逻辑\"><a href=\"#一、表达的逻辑\" class=\"headerlink\" title=\"一、表达的逻辑\"></a>一、表达的逻辑</h2><h3 id=\"第-1-章-为什么要用金字塔结构\"><a href=\"#第-1-章-为什么要用金字塔结构\" class=\"headerlink\" title=\"第 1 章 为什么要用金字塔结构\"></a>第 1 章 为什么要用金字塔结构</h3><p>归类分组，自上而下，结论先行。<br>条理清晰的文章需要不断自上而下的输出，而不只是一开始的自上而下。<br>组织文章的时候，应该按照金字塔结构，中心思想 -&gt; 章节思想 -&gt; 段落思想 -&gt; 句子思想。且每一个思想需要满足四种模式中的一种：   </p>\n<ol>\n<li>演绎顺序：大前提、小前提、结论</li>\n<li>时间（步骤）顺序：第一、第二、第三</li>\n<li>结构（空间）顺序：重庆、上海、北京</li>\n<li>程度（重要性）顺序：最重要、次重要、不重要</li>\n</ol>\n<h3 id=\"第-2-章-金字塔内部的结构\"><a href=\"#第-2-章-金字塔内部的结构\" class=\"headerlink\" title=\"第 2 章 金字塔内部的结构\"></a>第 2 章 金字塔内部的结构</h3><p>三种子结构：   </p>\n<ol>\n<li>疑问 - 回答式的对话</li>\n<li>横向的演绎或归纳推理</li>\n<li>讲故事的序言</li>\n</ol>\n<ul>\n<li><p>演绎推理：<br>第一个思想对现象做表述，第二个思想对第一个轮数据的主语或者谓语做表述，第三个思想从第一、第二个思想中得出表述。</p>\n</li>\n<li><p>归纳推理：<br>从一组归纳性论述中得出共同点，并加以推理得出一个推论。</p>\n</li>\n<li><p>序言的结构<br>背景、冲突、问题、回答 四个要素。</p>\n</li>\n</ul>\n<h3 id=\"第-3-章-如何构建金字塔结构\"><a href=\"#第-3-章-如何构建金字塔结构\" class=\"headerlink\" title=\"第 3 章 如何构建金字塔结构\"></a>第 3 章 如何构建金字塔结构</h3><h4 id=\"3-1-自上而下法\"><a href=\"#3-1-自上而下法\" class=\"headerlink\" title=\"3.1 自上而下法\"></a>3.1 自上而下法</h4><ol>\n<li>画出主题方框</li>\n<li>设想主要疑问</li>\n<li>写出对该疑问的回答</li>\n<li>说明“背景”</li>\n<li>指出冲突</li>\n<li>检查主要疑问和答案</li>\n</ol>\n<blockquote>\n<p>提示：</p>\n<ol>\n<li>提出主题思想</li>\n<li>设想受众的主要疑问</li>\n<li>写序言：背景 - 冲突 - 疑问 - 回答</li>\n<li>与受众进行疑问 - 回答式的对话</li>\n<li>对受众的新疑问，重复进行疑问 - 回答式的对话</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-自下而上法\"><a href=\"#3-2-自下而上法\" class=\"headerlink\" title=\"3.2 自下而上法\"></a>3.2 自下而上法</h3><ol>\n<li>列出想要表达的点</li>\n<li>找出各点之间的联系</li>\n<li>得出结论</li>\n<li>倒推出序言</li>\n</ol>\n<h3 id=\"第-4-章-序言的具体写法\"><a href=\"#第-4-章-序言的具体写法\" class=\"headerlink\" title=\"第 4 章 序言的具体写法\"></a>第 4 章 序言的具体写法</h3><p>标准顺序：<br>背景 -&gt; 冲突 -&gt; 疑问 -&gt; 解决方案   </p>\n<p>序言需要和主题相关，提出的疑问和解决方案需要和主题箱匹配。<br>序言里描述主题思想的部分最好列出关键句，关键句的作用不光可以对主题进行描述，也是整篇文章的框架结构。   </p>\n<p>每一个关键句下的内容最好也采用：背景 -&gt; 冲突 -&gt; 疑问 -&gt; 解答的方式，但比序言简单很多。其主要目的是提示读者已知的信息和衔接下面要说的信息。</p>\n<p>序言的常见模式：</p>\n<ol>\n<li>发出指示式 - 我们应该做什么、如何做</li>\n<li>请求支持式 - 我们是否应该这么做</li>\n<li>解释做法式 - 我们应该如何做</li>\n<li>比较选择式 - 我们应该做什么</li>\n</ol>\n<h3 id=\"第-5-章-演绎推理和归纳推理\"><a href=\"#第-5-章-演绎推理和归纳推理\" class=\"headerlink\" title=\"第 5 章 演绎推理和归纳推理\"></a>第 5 章 演绎推理和归纳推理</h3><ol>\n<li>演绎推理<br>演绎推理需要具有逻辑性。即为，条件 A ，条件 B，因此结论 C。条件 A 和 B 需要有关联，A 和 B 同时出现时，得出结论 C。<br>优点：更符合思想思考的顺序<br>缺点：如果演绎推理超过三步，就会变得繁琐复杂，且读者理解起来不够清晰。   </li>\n</ol>\n<p>演绎推理可以分为以下三步：</p>\n<ul>\n<li>出现的问题或存在的现象</li>\n<li>产生问题的根源、原因</li>\n<li>解决问题的方案</li>\n</ul>\n<ol start=\"2\">\n<li>归纳推理   <ul>\n<li>正确定义一组思想。找到一个能够表示改组思想共性的名词。</li>\n<li>识别并提出改组思想中与其他思想的不对称的思想。</li>\n</ul>\n</li>\n</ol>\n<p>总结：演绎关系的建立，要求推理过程中第二部对第一步做出评述，并推导出一个结论。归纳关系则基于句子结构，必须找出各句主语或谓语之间的共同点，并根据这一共同点得出结论。</p>\n<h2 id=\"二、思考的逻辑\"><a href=\"#二、思考的逻辑\" class=\"headerlink\" title=\"二、思考的逻辑\"></a>二、思考的逻辑</h2><h3 id=\"第-6-章-应用逻辑顺序\"><a href=\"#第-6-章-应用逻辑顺序\" class=\"headerlink\" title=\"第 6 章 应用逻辑顺序\"></a>第 6 章 应用逻辑顺序</h3><p>逻辑顺序主要有三种：</p>\n<ol>\n<li>时间（步骤）顺序 - 确定前因后果关系</li>\n<li>结构（空间）顺序 - 将整体分割为部分</li>\n<li>程度（重要性）顺序 - 将类似失误归为一组</li>\n</ol>\n<p>时间顺序：<br>每一个步骤应当属于同一逻辑层次，并且有强烈了联系，上一步完成之后必须是下一步。   </p>\n<p>在按照时间顺序组织的思想组中，主题句是要达到的效果，表述思想的顺序与采取行动的顺序（第一步、第二部、第三步）一致。   </p>\n<p>结构顺序：   </p>\n<p>MECE 原则：</p>\n<ol>\n<li>各部分之前相互独立，相互排斥，没有重叠。</li>\n<li>所有部分完全穷尽，没有遗漏。</li>\n</ol>\n<p>结构顺序适合用于逻辑拆分时，每个点之间没有明显的重要性区别，和时间顺序时，则可以按照读者想象的顺序进行描述。例如示意图、地图、图画、照片。</p>\n<p>程度顺序(重要性顺序)：<br>指明每组中的项目（思想、观点、问题等）具有共同特性，确保将所有具有该特性的项目列入一组。在每组中，根据各个问题具有该特性的程度高低顺序–该特性表现最鲜明的问题排在第一位，即先强后弱，先重要后次要。</p>\n<h3 id=\"第-7-章-概括各组思想\"><a href=\"#第-7-章-概括各组思想\" class=\"headerlink\" title=\"第 7 章 概括各组思想\"></a>第 7 章 概括各组思想</h3><p>概括各组思想：确保划分好的思想属于同一组，应抽象、提炼、概括其中的精华。<br>思想的表达方式可以是行动性语句，即告诉读者做什么事，也可以是描述性语句，即告诉读者关于读者某些事的情况。   </p>\n<ul>\n<li>概括行动性思想（介绍采取的行动、行为、步骤、流程）时，应说明采取行动后的“结果”（效果、达到的目标）。   </li>\n<li>概括描述性思想（介绍背景、信息）时，应说明这些思想所具有的“共同点的含义”   </li>\n</ul>\n<p>说明采取行动的结果/目标</p>\n<ul>\n<li>在讲各项行动（步骤、流程等）联系起来之前，先用明确的语句描述各项行动（步骤、流程等）</li>\n<li>找出明显的因果关系组合，尽量将每一组的行动、步骤控制在 5 个以下</li>\n<li>直接从这些行动、步骤、流程来总结、概括行动的结果及目标。</li>\n</ul>\n<p>总结句要用明确的语言概括   </p>\n<ul>\n<li>先用明确的语句描述各项行动、步骤、流程等</li>\n<li>找出明显的因果关系，将每一组行动、步骤控制在 5 个以内。</li>\n<li>直接从这些行动、步骤、流程来总结、概括行动的结果、目标。</li>\n</ul>\n<p>区分行动、步骤、层次<br>将行动、步骤进行层次划分，如果都按照时间顺序进行描述，那么对于读者来说，无法很好的对各个行动所产生的结果产生立体感。这时就需要对最终的结果，进行层次划分，然后再将每个层次的行动和步骤进行归类。</p>\n<p>概括行动结果<br>总结行动产生的结果：   </p>\n<ul>\n<li>该组行动、步骤之间必须相互独立不重叠、完全穷尽无遗漏。</li>\n<li>总结概括性语句必须说明各项行动、步骤导致的直接结果，且措辞必须明确、具体。</li>\n<li>先用明确的语句表述各项行动、步骤、流程等，然后区分不通过的抽象层次，再从各行动、步骤、流程等总结概括出行动的结果。</li>\n</ul>\n<p>找出各结论之间的共性<br>有时，我们在对一个得出主题的结论进行划分的时候，往往是缺乏思想的。例如没有找出结论之间的共性，使得主题思想论证的不够充分。这时，我们需要将结论之间的共性找出来，并对结论进行归纳总结，得出更加详细和准确的描述。   </p>\n<p>进行归纳跃进<br>对得出的结论和思想进行进一步的思考和整理，从而得出更加精炼的结论，归纳跃进可以让我们找出主题思想是否清晰，以及结论是否可以支持我们归纳跃进出主题思想，避免我们在得出的结论中无法得出主题思想。</p>\n<h2 id=\"三、解决问题的逻辑\"><a href=\"#三、解决问题的逻辑\" class=\"headerlink\" title=\"三、解决问题的逻辑\"></a>三、解决问题的逻辑</h2><p>商务文章通常需要回答：</p>\n<ol>\n<li>我们应该做什么？（如果不知道解决方案）</li>\n<li>我们应该做吗？（如果已经给出了解决方案）</li>\n<li>我们应该怎么做？你会怎么做？（如果已经知道且接受解决方案）</li>\n</ol>\n<p>流程示意：<br>界定问题 -&gt; 构建分析框架 -&gt; 分析/找到解决方案 -&gt; 构建金字塔与他人交流</p>\n<h3 id=\"第-8-章-界定问题\"><a href=\"#第-8-章-界定问题\" class=\"headerlink\" title=\"第 8 章 界定问题\"></a>第 8 章 界定问题</h3><p>界定问题的 4 个要素：   </p>\n<ol>\n<li>切入点/序幕 - 设想或描述特定的时刻，特点的点。</li>\n<li>困扰/困惑 - 影响了流程的正常运行，可能是内部、外部或其他原因。</li>\n<li>现状（R1，非期望结果） - 面临的问题，或是有可能抓住的机会。</li>\n<li>目标（R2，期望结果） - 期望所产生的结果，可以是具体的数字或结果。</li>\n</ol>\n<p>发掘读者的疑问：   </p>\n<ol>\n<li>不知道如何将 R1 转化为 R2</li>\n<li>知道如何将 R1 转化为 R2 ，但不确定是否正确。</li>\n<li>知道将 R1 转化为 R2 的正确方案，但不知道如何实施。</li>\n<li>知道将 R1 转化为 R2 的方案，并且已经实施，但在实施过程中发现方案行不通。</li>\n<li>制定了好几个解决方案，但不知道选择哪一个。</li>\n<li>知道 R1，但不能具体描述 R2，所以无法找到解决方案。</li>\n<li>知道 R2，但不清楚现在是否处于 R1（这是典型的标杆对比），无法确定是否存在问题。</li>\n</ol>\n<h3 id=\"第-9-章-结构化分析问题\"><a href=\"#第-9-章-结构化分析问题\" class=\"headerlink\" title=\"第 9 章 结构化分析问题\"></a>第 9 章 结构化分析问题</h3><p>分析问题的标准流程是：<br>收集信息 -&gt; 描述发现 -&gt; 得出结论 -&gt; 提出方案   </p>\n<p>从信息资料入手：<br>如果是收集大量资料之后再开始分析，会造成大量资料无效，且许多分析和问题无关的问题。所以正确的方式应该是先对问题进行分析，设计诊断框架，再收集资料。</p>\n<p><strong>设计诊断框架：</strong>   </p>\n<ol>\n<li>呈现有型的结构 - 将问题的企业/领域下的系统示意图画出来。</li>\n<li>寻找因果关系 - 寻找具有因果关系的要素、行为或任务。</li>\n</ol>\n<ul>\n<li>财务结构 - 根据财务划分</li>\n<li>任务结构 - 根据任务划分</li>\n<li>行动结构 - 根据行动划分</li>\n</ul>\n<ol start=\"3\">\n<li>对引发问题的可能原因进行分类   </li>\n</ol>\n<ul>\n<li>相似性分类 - 根据可能原因的相似性进行分类</li>\n<li>选择结构 - 根据整体的系统结构，从问题出发的位置进行逐级深入选择，直至找到问题为止。<blockquote>\n<p>诊断框架用来提出问题，逻辑树、PERT 图（项目评估检查技术图）用来阐述采取某种行动的必要性。   </p>\n</blockquote>\n</li>\n</ul>\n<p><strong>使用诊断框架：</strong>   </p>\n<ul>\n<li><p>收集资料 - 根据诊断框架的问题点列出需要收集的资料，而不是大而全的收集。</p>\n</li>\n<li><p>分析的方法 - 根据诊断框架，设想出出问题的原因，再根据原因去收集资料验证问题。有了需要收集的资料之后，就需要确定资料的来源、任务分配以及时间表和估算消耗的资源了。   </p>\n</li>\n</ul>\n<p><strong>建立逻辑树</strong>   </p>\n<ol>\n<li>是否有问题？</li>\n<li>问题在哪里？</li>\n<li>为什么会存在？</li>\n<li>我们能做什么？</li>\n<li>我们应该做什么？</li>\n</ol>\n<p><strong>寻找解决方案</strong><br>根据逻辑树上造成问题的原因进行分析，遵循 MECE 法则，将一个解决问题的方案进行细化。例如：对于开支过大这一问题，有一个引起原因是餐饮消费较高，那么针对餐饮消费部分就可以有一系列的环节可以列出来，在根据这些环节的情况去评估是否值得优化。</p>\n<p><strong>寻找各组思想的缺陷</strong><br>对于一个问题，我们往往能想出很多组思想，对于这些思想来说，比较散乱，且没有联系，我们要做的就是将这些一组一组的思想结合起来，根据分组思路结合，再对这些问题查漏补缺，以分析解决问题的过程为核心。</p>\n<p><strong>是非问题分析</strong><br>是非问题往往是分析过程中最重要的部分，他将直接影响决策，例如：“如何减少晚餐的开支”和“我们是否应该减少晚餐的开支”，后者为是非问题，答案只有是和否，需要收集充分的资料来决策。</p>\n<p><strong>总结</strong><br>「诊断框架」和「逻辑树」可以让解决问题更加具有系统性，同时，它们不光是在分析问题和解决问题的过程中提供重要的作用，还可以在最终的文字报告中减少很多的工作量。因为它们能够快速方便的转换成金字塔结构。</p>\n<h2 id=\"四、演示的逻辑\"><a href=\"#四、演示的逻辑\" class=\"headerlink\" title=\"四、演示的逻辑\"></a>四、演示的逻辑</h2><h3 id=\"第-10-章-在书面上呈现金字塔\"><a href=\"#第-10-章-在书面上呈现金字塔\" class=\"headerlink\" title=\"第 10 章 在书面上呈现金字塔\"></a>第 10 章 在书面上呈现金字塔</h3><p><strong>突出文章的结构</strong>   </p>\n<ol>\n<li>多级标题法</li>\n</ol>\n<ul>\n<li>每一层及的标题不可能只有一个</li>\n<li>相同的思想应使用相同的句型。例如同一组思想中，都以动词或名词开始。</li>\n<li>标题用词应表达思想精髓</li>\n<li>标题与正文应分开考虑，标题是为了抓眼球。</li>\n<li>每组标题应提前介绍，不要一个标题紧接着另一个标题。</li>\n<li>不要滥用标题，标题需要有意义，类似序言，背景这类带有重合意义的标题不应该同时出现。</li>\n</ul>\n<ol start=\"2\">\n<li>下划线法<br>将关键句词和支持性论点用下划线标出，下划线法需要保证排版美观。<br>注意点：</li>\n</ol>\n<ul>\n<li>必须严格使用疑问 - 回答结构。</li>\n<li>必须注意论点的措辞，说明论点的句子越短越好。</li>\n</ul>\n<ol start=\"3\">\n<li><p>数字编号法<br>优点在于方便检索，配合多级标题法有良好的效果，缺点为如果使用不当，会造成读者不易理解文中的思想。</p>\n</li>\n<li><p>行首缩进法<br>行首缩进法一般要用相同的句型表达观点，通过格式区分不同组的思想方便理解。</p>\n</li>\n<li><p>项目符号法<br>项目符号法是首行缩进的变形，与多级标题一样，层次越低的观点，首行缩进越多。</p>\n</li>\n</ol>\n<p><strong>上下文之间要有过度</strong></p>\n<ol>\n<li>讲故事<br>按照背景 - 冲突 - 疑问的方式讲故事。</li>\n<li>承上启下<br>将前一部分挑选一个词、短语或主要思想，用在下一部分的起始句即可。</li>\n<li>总结各部分内容<br>复述前文主要论点和几点即可。</li>\n<li>得出完整的结论<br>在读完文章后，还需要让读者去做什么或者思考什么。</li>\n<li>说明下一步已经行动<br>如果希望读者在不久的将来采取行动，那么总结性的段落是有必要的。</li>\n</ol>\n<h3 id=\"第-11-章-在-PPT-演示文稿中呈现金字塔\"><a href=\"#第-11-章-在-PPT-演示文稿中呈现金字塔\" class=\"headerlink\" title=\"第 11 章 在 PPT 演示文稿中呈现金字塔\"></a>第 11 章 在 PPT 演示文稿中呈现金字塔</h3>","categories":["读书"]},{"title":"解决 PHP 方法执行时间过长导致 502 Bad Gateway","url":"/2020/06/22/resolve-php-method-timeout/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近遇到一个问题，有一段 PHP 代码需要涉及到长时间的 IO 操作，而这一段会阻塞请求所在的线程，导致请求超时。<br>你可能会说，这有啥难的，开个线程异步去做，做好了更新状态就 OK 了。这真是一个不错的方案，可惜这一整套代码都是别人的。如果要修改代码，业务上会牵一发而动全身，所以我的解决办法是尽量不修改代码的情况下，通过配置超时时间来解决这个问题。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>从以上问题来看，超时主要受到两个因素的影响：</p>\n<ol>\n<li>Nginx 网关请求超时设置</li>\n<li>PHP 脚本执行时间上限设置</li>\n</ol>\n<p>我们依次进行设置。</p>\n<h3 id=\"Nginx-网关请求超时设置\"><a href=\"#Nginx-网关请求超时设置\" class=\"headerlink\" title=\"Nginx 网关请求超时设置\"></a>Nginx 网关请求超时设置</h3><p>Nginx 支持超时的设置粒度很细。主要使用的几个如下：</p>\n<ul>\n<li>keepalive_timeout<br>Nginx 使用 keepalive_timeout 来指定 KeepAlive 的超时时间。指定每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以可以设定为 60 秒。</li>\n<li>fastcgi_connect_timeout<br>与FastCGI服务器建立连接的超时。</li>\n<li>fastcgi_send_timeout<br>设置将请求传输到FastCGI服务器的超时。 仅在两次连续写入操作之间设置超时，而不是为整个请求的传输。 如果FastCGI服务器在此时间内未收到任何内容，则关闭连接。</li>\n<li>fastcgi_read_timeout<br>从FastCGI服务器读取响应的超时。 仅在两个连续的读操作之间设置超时，而不是为整个响应的传输。 如果FastCGI服务器在此时间内未传输任何内容，则关闭连接。   </li>\n</ul>\n<p>考虑到一次请求 PHP 脚本的执行和后三个设置比较相关。所以在对应网站的 Nginx 配置文件中添加设置即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastcgi_connect_timeout 600s;</span><br><span class=\"line\">fastcgi_send_timeout 600s;</span><br><span class=\"line\">fastcgi_read_timeout 600s;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PHP-脚本执行时间上限设置\"><a href=\"#PHP-脚本执行时间上限设置\" class=\"headerlink\" title=\"PHP 脚本执行时间上限设置\"></a>PHP 脚本执行时间上限设置</h3><p>PHP 脚本的执行时间主要是受两个配置的影响：</p>\n<ol>\n<li><p>php.ini 中 <code>max_execution_time</code> 和 <code>max_input_time</code><br>php.ini 的默认位置在 <code>/usr/local/php/etc/</code><br>将 php.ini 配置文件中的这两个配置项修改为超时时间上限。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">max_execution_time = 600</span><br><span class=\"line\">max_input_time = 600</span><br></pre></td></tr></table></figure></li>\n<li><p>php-fpm.conf 中 <code>request_terminate_timeout</code><br>php-fpm.conf 的默认位置在 <code>/usr/local/php/etc/</code><br>request_terminate_timeout 也设置为超时时间的上限。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">request_terminate_timeout = 600</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>修改完成后重启 Nginx 和 php-fpm 即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service nginx reload</span><br><span class=\"line\">/etc/init.d/php-fpm reload</span><br></pre></td></tr></table></figure>\n\n\n","categories":["运维"],"tags":["PHP","Nginx"]},{"title":"「数据分析基础」课程的学习与思考","url":"/2021/04/15/study-fundamentals-of-data-analysis/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>去年从一位牛逼的同事那搞了一份「数据分析基础」的课程，没想到最近才有空学习。然后打开课程，发现是 19 年的课程，突然就觉得自己拖了几个月学习也不算长，课程应该还没过时。<br>为什么要学数据分析基础呢？因为我认为数据思维和分析的逻辑不光是在相关行业可以得到使用，作为一个程序员学学数据分析，在未来的工作中也能提供一些思路上的帮助。之前写过一篇初始「数据分析」，里面仅仅只是了解了数据分析的操作框架，没有实操的环节，甚至都不算入门。而这次学习数据分析基础，可以让我对数据分析有更深入的了解和认识，而这门课程的内容正好特别适合我这种入门级选手。<br>课程虽然知识很基础，但思考却可以更深入。我从课程的这些基础知识中，做了更深入的总结和思考，本文就是总结和思考的记录。</p>\n<span id=\"more\"></span>\n<h2 id=\"一、课程内容\"><a href=\"#一、课程内容\" class=\"headerlink\" title=\"一、课程内容\"></a>一、课程内容</h2><p>课程的内容整体来说比较基础，没有特别难懂的地方，老师讲的也很通俗，结合实战案例，可以说连小白都能轻松理解。</p>\n<h3 id=\"以互联网运营的视角出发\"><a href=\"#以互联网运营的视角出发\" class=\"headerlink\" title=\"以互联网运营的视角出发\"></a>以互联网运营的视角出发</h3><p>课程面向的学生是互联网运营岗（初学数据分析的那种），所有知识和案例都是以一个运营的视角出发，从发现问题到解决问题，介绍了一些基础概念、市面上常用的工具和一些上手即用的方法论。</p>\n<h3 id=\"课程主题\"><a href=\"#课程主题\" class=\"headerlink\" title=\"课程主题\"></a>课程主题</h3><p>课程的内容主要包含以下部分：</p>\n<ul>\n<li>指标建模 - 数据指标所代表的含义，将业务指标变成具体数据的指标。</li>\n<li>数据工具 - 用于展示和分析的数据工具。</li>\n<li>数据分析基础 - 介绍对比分析、维度拆解、漏斗等基础分析方法。</li>\n<li>数据分析进阶 - 介绍用户画像、归因查找等方法和实战问题的解决。</li>\n<li>数据采集 - 介绍如何埋点，要埋哪些，如何与研发沟通要怎么埋。</li>\n</ul>\n<p>以上就是课程主题的简介，这些主题结合起来构成了从制造数据到具体分析解决问题的整条链路，里面还讲了许多现成的工具和系统（GA、Excel、神策数据等），以及这些工具如何使用。<br>下面开始本文的正文</p>\n<h2 id=\"二、分析的逻辑\"><a href=\"#二、分析的逻辑\" class=\"headerlink\" title=\"二、分析的逻辑\"></a>二、分析的逻辑</h2><p>数据分析中最重要的当然是分析的逻辑，课程站在运营的视角介绍了许多方法论，但我认为这些方法底层都是基于这些分析的逻辑而来的。</p>\n<h3 id=\"自上而下\"><a href=\"#自上而下\" class=\"headerlink\" title=\"自上而下\"></a>自上而下</h3><p>就如金字塔一般，「自上而下」的分析逻辑就像解决问题一样。拿到一个具体的业务问题，通过一级一级的拆分，将其从一个业务问题拆分成多个业务指标，再由多个业务指标转化为数据指标，从而基于数据指标进行分析，如图：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-8/1617894272342-image.png\"><br>自上而下的分析逻辑很容易理解，也是我们经常都会用到的场景。这样的分析方法在有一个具体业务问题的时候适合使用，核心在于拆分。例如业务问题是「这个月的订单量为什么下降了」，那么这个问题的核心就要提出假设，然后根据假设和核心数据指标「订单量」逐级展开，验证假设，根据各项数据指标的表现找出原因。又例如问题是「如何让下个月订单量翻倍」\b，那么就要根据订单的转化流程做拆分，然后结合业务现状\b和对应的数据指标，产出方案。</p>\n<h3 id=\"自下而上\"><a href=\"#自下而上\" class=\"headerlink\" title=\"自下而上\"></a>自下而上</h3><p>「自下而上」的分析逻辑和「自上而下」相反，没有明确顶层的业务问题出发。我们拿到现有的数据指标，通过这些数据指标的表现来找出业务问题，更像是「数据挖掘」。更多用于产品的「健康状况监控」等场景。如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-8/1617896138915-image.png\"><br>数据指标通过组合和计算，可以得出一个又一个的业务指标。通过对这些数据和业务指标的观察和分析，就可以得到很多价值信息。就如我们所用的「数据透视表」，通过把多个数据指标组合并绘制出图形，就可以获得走势、占比等信息。多维度的组合就是抽象的过程，也是金字塔自下而上的过程。<br>自下而上的分析逻辑需要较高的数据量和维度作为基础，越好的数据基础能带来的价值就越多。虽然自下而上的分析并不针对某一个特定的问题，\b但在分析的过程就会不断产出价值，包括业务指标、业务问题和其他的价值信息。    </p>\n<h3 id=\"从数据的层面出发\"><a href=\"#从数据的层面出发\" class=\"headerlink\" title=\"从数据的层面出发\"></a>从数据的层面出发</h3><p>无论是自上而下还是自下而上，更多的是以业务为中心来看，也许你会问怎么区分业务指标和数据指标，他们之间的界线又是什么。<br>如果以数据为中心的角度来看，就可以解释这个问题。在自动化领域，有一种数据分类的方法将数据分为 L1 - L4 四个等级。他们分别的定义是这样的：</p>\n<ul>\n<li>L1：最底层的数据，一般是时序数据、过程数据、状态数据等，数据量大，无效数据多，一般需要清洗。例如打开 App 的事件，当前的温度等。</li>\n<li>L2：将底层数据经过初步转换和计算后的数据，带有一点业务性。例如当日是否活跃。</li>\n<li>L3：将 L2 层的数据再次转换和计算，带有一定业务属性和价值。例如用户增长率。</li>\n<li>L4：将 L3 层的数据再次转换和计算，富有业务价值的数据。例如北极星指标。<br>从 L1 - L4，数据量成指数型减少，更像是一个将数据浓缩为价值的过程。这个过程也是分析过程的一种。对一个整体来说，任何一个数据都可以归到 L1 - L4 中的一种，对数据的获取和转换，都可以类比成从 L1 - L4 的转换，每一个数据指标都需要经过这个过程。<br>至此，也可以回答刚才的问题：业务指标和数据指标的界线是什么？这里并没有明确的界线，L1 - L4 是人根据广义上的数据层级分类。我个人认为，能够解释业务问题的数据指标就可以称之为业务指标，按照这个模型分类，从 L3 开始，就和业务强相关，具备直接解释业务问题的特点，也可以称之为业务指标了。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>也许你会问，自上而下、自下而上这样看似简单容易理解的分析逻辑知道了又有什么用呢？<br>其实我也无法定义具体在哪些场景下有什么用，毕竟实战经验很少。但我认为在实际的分析场景中，这些分析的逻辑可以让分析过程更加清晰，知道自己处在哪个层级。所谓「大道至简」，抽象出来的逻辑是简洁易懂的，也是处处适用的。</p>\n<h2 id=\"三、连接\"><a href=\"#三、连接\" class=\"headerlink\" title=\"三、连接\"></a>三、连接</h2><p>无论是做产品还是做技术，大家都在谈连接，一会儿平台连接应用，一会儿平台连接商户等等。我仔细想了一下，按照这个规律，市面上任何一个产品、工具、商品都可以说成是在连接。那「数据」自然也是在连接。</p>\n<h3 id=\"连接的是什么\"><a href=\"#连接的是什么\" class=\"headerlink\" title=\"连接的是什么\"></a>连接的是什么</h3><p>那么数据到底连接的是什么？数据反映的是事实，从而连接业务。所以数据分析的核心就是「业务数据化」和「数据业务化」。通俗一点，就是把数据和业务绑在一起，达到「共创」的目的，理论上连接的最高境界是：「你就是我我就是你」。<br>纵观整个互联网行业，每个领域都在谈数据，小到一行代码，大到大数据平台；\b从运营一侧解决运营问题，到机器学习一侧解决脑子的问题。所以作为数据本身而言，连接的业务越多，解决的问题就越多。    </p>\n<h3 id=\"数据驱动-事实驱动\"><a href=\"#数据驱动-事实驱动\" class=\"headerlink\" title=\"数据驱动 - 事实驱动\"></a>数据驱动 - 事实驱动</h3><p>回到业务的层面，站在公司或产品的视角，聊聊最近比较火的「数据驱动」。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>首先是数据驱动的定义，网上看了一下，对数据驱动的定义很多，大家似乎没有达成一致。再看看百度百科的描述：</p>\n<blockquote>\n<p>一种问题求解方法。从初始的数据或观测值出发，运用启发式规则，寻找和建立内部特征之间的关系，从而发现一些定理或定律。通常也指基于大规模统计数据的自然语言处理方法。   </p>\n</blockquote>\n<p>emmm，很抽象，说说我个人的理解吧，如果用一句通俗的话来描述数据驱动，我称之为：</p>\n<blockquote>\n<p>使用数据直接产出结论。   </p>\n</blockquote>\n<p>数据驱动的输入是数据，输出是结论，中间是将数据转化为结论的模型。数据反映的是事实，所以数据驱动的本质是事实驱动，核心在于两点：</p>\n<ol>\n<li>如何让数据反应的事实更准确</li>\n<li>如何让已有的数据变成结论（决策）   </li>\n</ol>\n<h4 id=\"玩法\"><a href=\"#玩法\" class=\"headerlink\" title=\"玩法\"></a>玩法</h4><p>数据驱动一般是怎么玩的呢？驱动的东西不同有不同的玩法，不过都是以「输入-&gt;模型-&gt;输出」的流程为基础演变的。这里拿驱动产品或运营举例，玩法一般是这样的：</p>\n<ol>\n<li>提出目标</li>\n<li>数据建模</li>\n<li>输入数据</li>\n<li>模型计算</li>\n<li>输出结论</li>\n<li>A/B 测试验证</li>\n<li>再输出结论</li>\n</ol>\n<p>对比一下传统模式的玩法，以人或职责驱动的模式：</p>\n<ol>\n<li>提出目标</li>\n<li>分析目标</li>\n<li>调研/讨论</li>\n<li>输出报告</li>\n<li>再讨论</li>\n<li>输出结论</li>\n</ol>\n<p>传统的以人或职责驱动的模式，主要依靠主观臆断和个人的经验决策，相比数据驱动这样的决策体系不稳定，不易复制。<br>后来流程驱动出现了，流程驱动的模式相比人或职责驱动的模式又更进了一步，虽然解决了可复制，不稳定的问题，但在准确性上还是略显不足。<br>而数据驱动的优势就很明显了：</p>\n<ul>\n<li>结论更加客观准确</li>\n<li>步骤简单，支持快速变化以满足其他场景</li>\n<li>步骤可自动化</li>\n</ul>\n<p>步骤支持快速变化和可自动化这两项是数据驱动的核心竞争力。当然，这些优势也伴随着对企业或产品极高的要求：</p>\n<ul>\n<li>对数据的数量和质量要求较高</li>\n<li>对企业的数字化能力要求较高</li>\n</ul>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>那么面对数据驱动的各种特点，在实际的场景中应该怎么应用呢，毕竟不是每个产品每家公司都具备数据驱动的条件。这里我个人的观点是：「不同时期的产品，应用的方式不同」<br>如果产品还在孵化期或验证期，那么数据量一定很少，而且质量不高。这时数据只能作为参考因素来辅助决策，有的决策甚至没有相应数据的参考，依然只能靠传统的人来驱动。<br>到了增长期，产品有一定的数据基础，但依然离数据驱动的要求差得很远，这时就可以将数据作为辅助决策的一部分，人工数据分析结合现有工具来帮助决策。<br>到了成熟期，产品拥有一定的数据基础，可以开始逐渐尝试依靠丰富的数据基础、数据建模和机器学习的能力来驱动一些业务，形成高响应速度、高决策质量的玩法。     </p>\n<h4 id=\"数据驱动是终点吗\"><a href=\"#数据驱动是终点吗\" class=\"headerlink\" title=\"数据驱动是终点吗\"></a>数据驱动是终点吗</h4><p>上述的应用场景是比较理想的情况。按照这个说法，数据驱动就是企业发展的最终形态吗？<br>我个人的答案是「不一定」。原因有两点：</p>\n<ol>\n<li>数据驱动无法一步到位，更像是锦上添花。达成数据驱动必须经过基于人、职能、流程驱动的业务系统，通过系统产生数据达成，当企业真正达到数据驱动的门槛时，其他驱动的方式必然也很成熟了。</li>\n<li>不是每一个场景都需要高响应速度、高决策质量，需要考虑投入产出。数据驱动的成本和代价是偏高的，相比之下，传统企业或小作坊的玩法不一定不好，适合当下是最重要的。</li>\n</ol>\n<h2 id=\"四、Next…\"><a href=\"#四、Next…\" class=\"headerlink\" title=\"四、Next…\"></a>四、Next…</h2>","categories":["数据分析"],"tags":["思考","数据分析"]},{"title":"微前端架构详解 - 乾坤","url":"/2021/04/28/the-architecture-of-micro-frontends-qiankun/","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>后有「微服务」，前有「微前端」。微前端是一个近几年才火起来的名词，伴随着近年来前端技术的超速发展和 <strong>“js 必将一统天下”</strong> 的口号，JavaScript 现在已经无所不能了。<br>10 年前，网页前端还是以 html + css + js 为主，被程序员们称为最简单的编程语言，最易上手的一个端，甚至部分前端还需要兼职美工。现在，前端领域已经玩出了各种花样，上能写服务端中间件，下能写移动端 App。连最开始的网页前端，也从 jQuery 这样的工具库转化到响应式框架和组件化的时代了。<br>组件化已经基本可以满足大中小型应用的需求了，但面对一些超大体量的应用时，传统组件化\b\b架构就会产生诸多问题。这时，为了解决这些问题，微前端架构诞生了。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、微前端架构\"><a href=\"#一、微前端架构\" class=\"headerlink\" title=\"一、微前端架构\"></a>一、微前端架构</h2><h3 id=\"1-1-微前端是什么\"><a href=\"#1-1-微前端是什么\" class=\"headerlink\" title=\"1.1 微前端是什么\"></a>1.1 微前端是什么</h3><p>在微前端的定义上，定义有很多。<a href=\"https://micro-frontends.org/\">微前端官网</a>（没错，概念也有官网）的定义是：</p>\n<blockquote>\n<p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.</p>\n</blockquote>\n<p>英语好的自行理解，理解不了的看我的解读：</p>\n<blockquote>\n<p>用于解决多团队开发一个超大型应用的技术。</p>\n</blockquote>\n<p>那么微前端应用的架构又是什么样的呢？<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-28/1619619097458-image.png\"></p>\n<p>如上图所示，</p>\n<ul>\n<li>「Shared Stitching Layer」代表微前端基座，用于控制当前应该展示哪个页面、加载和移除页面，就像页面的「中控室」。</li>\n<li>中间的「Ads Team」、「Products Team」、「Users Team」分别代表不同团队所开发的不同的前端项目，这些项目往往是直接给用户使用的。</li>\n<li>下面的 「API Service」代表不同项目的后端，为前端项目提供服务。</li>\n</ul>\n<p>基于这样的架构，研发管理上就可以做到不同团队只关注自己的应用功能，不必关心技术上对其他应用的影响，从而提高效率，如下图：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-4-28/1619619053742-image.png\"></p>\n<p>你可能会问：</p>\n<blockquote>\n<p>不就是多团队开发然后用个壳子揉到一起吗，这真的能提高很多效率吗？</p>\n</blockquote>\n<p>还真能，这就要从微前端的核心理念说起了。</p>\n<h3 id=\"1-2-微前端的核心理念\"><a href=\"#1-2-微前端的核心理念\" class=\"headerlink\" title=\"1.2 微前端的核心理念\"></a>1.2 微前端的核心理念</h3><h4 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h4><p>微前端的核心思想是<strong>让应用之间技术栈无关</strong>，足够的无关，才叫「微前端」。<br>基于这个核心思想，我将微前端的理念总结为 4 个点，基于这 4 个点的技术发展将直接影响微前端架构的成熟度。</p>\n<h4 id=\"理念\"><a href=\"#理念\" class=\"headerlink\" title=\"理念\"></a>理念</h4><ul>\n<li><p>高隔离性<br>隔离性是微前端最重要的特性之一，良好的隔离性可以让子应用与子应用之间、子应用与基座之间互不干扰，子应用只运行在自己的沙箱里。甚至应用各自可以用不同的技术栈。例如基座用 Vuejs，A 应用使用 React，B 应用使用原生 html + jQuery。</p>\n</li>\n<li><p>低耦合度<br>微前端要求各个子应用之间耦合度很低，往往框架的「隔离性」做得越好，子应用间通信的限制就越多，通信成本就越高。如果应用之间耦合度高，则会产生频繁的通信操作，从而增加使用成本\b。所以微前端架构强制要求应用之间低耦合。如果应用因业务原因耦合度不得不变高，则应从业务拆分的角度考虑是否将两个子应用整合成为一个。</p>\n</li>\n<li><p>高扩展性<br>微前端框架是一个非常灵活的框架，允许框架内的子应用进行任意形式的扩展，不限制基座和子应用依赖，基座和子应用可以基于业务和技术上\b\b来扩展功能，例如可以把基座扩展成一个云平台架子，或者改造成一个应用编排器。</p>\n</li>\n<li><p>低侵入性<br>从微前端框架层来说，无论是对基座还是子应用，都需要保证尽可能低的侵入。能只侵入依赖的就不侵入代码，能只侵入 10 行代码的坚决不侵入 20 行。过高的侵入性会增加使用成本，降低扩展性和协作效率。侵入性和扩展性共同决定了微前端框架的易用性。</p>\n</li>\n</ul>\n<h4 id=\"价值\"><a href=\"#价值\" class=\"headerlink\" title=\"价值\"></a>价值</h4><p>如果用一句话来形容微前端的价值，我称之为：</p>\n<blockquote>\n<p>因「无关」而「效率」</p>\n</blockquote>\n<p><strong>微前端解决应用在研发、维护、升级、变迁时因耦合而造成的维护性降低的问题，在超大型前端应用中尤为明显。</strong>    </p>\n<p>试想一下，如果一个巨型的 React(15) 单页应用，需要升级到 React(16) 的版本，那必定会迎来一波腥风血雨，做过此类不兼容升级工作的小伙伴一定知道心里的苦。<br>但如果是这个应用是微前端架构，完全可以保持基座依然是 React(15)，先将 A 子应用升级到 React(16)，既可以降低升级风险，还可以平稳过度。同理，这个机制在新技术实践的时候也适用，例如如果想试用 Vue3，就可以让 B 子应用使用 Vue3 开发\b，和 React 基座完成契合。甚至如果有一个 5 年前的项目 C 应用，突然想接入到我们系统里，按照传统的方式我们需要对这个 5 年前的项目做一次痛苦的改造，但按照微前端的模式他只需要在做一点接入相关的开发，即可与基座和 A、B 子应用融合。</p>\n<h3 id=\"1-3-形如-iframe-却非-iframe\"><a href=\"#1-3-形如-iframe-却非-iframe\" class=\"headerlink\" title=\"1.3 形如 iframe 却非 iframe\"></a>1.3 形如 iframe 却非 iframe</h3><p>写到这里，如果你对前端有了解，你可能会问：</p>\n<blockquote>\n<p>你说的这些我明白，但 iframe 不是可以解决你说的这些问题吗？</p>\n</blockquote>\n<p>那是当然，从 iframe 的机制来看，简直是为微前端而生的 html 原生组件，但回头一想，那些研究微前端的人总不能是傻子吧，如果 iframe 真的这么好用，还研究这么多干什么。    </p>\n<p>iframe 在使用上的确很方便，但功能限制缺有很多，有的微前端架构也是用 iframe 实现的，但都会面对如下问题：</p>\n<ul>\n<li>URL 状态的问题。iframe 的 url 状态会在刷新时丢失，同时后退、前进按钮都无法控制 iframe</li>\n<li>UI \b\b完全隔离。\biframe 内的 UI 只能在 iframe 内，这在需要弹框，或者层叠的时候会特别丑。比如一个 iframe 内部弹窗，遮罩智能盖住 iframe，无法影响到外面，导致看起来恨不协调</li>\n<li>上下文隔离。iframe 内外通信及其不方便，一般通过 url、cookie 等方案来通信</li>\n<li>性能消耗大。每一个 iframe 都可以看成是一个小的浏览器窗口，应用每次进入相当于打开多个窗口。一般会比单页应用更慢。</li>\n</ul>\n<p>这些问题有的可以曲线解决，有的没法解决，这些没法解决的问题会直接影响交互体验，有时这些影响是不被接受的。这促使人们开始寻找新的道路，有没有一种方案可以\b「形如 iframe 却非 iframe」呢？<br>从目前的发展趋势来看，“让子应用能够像 iframe 一样简单接入，消除 iframe 的那些缺点”\b 是微前端架构不断在攻坚的目标之一。</p>\n<h3 id=\"1-4-评估微前端框架\"><a href=\"#1-4-评估微前端框架\" class=\"headerlink\" title=\"1.4 评估微前端框架\"></a>1.4 评估微前端框架</h3><p>上文说的都是微前端架构的理论，在实际场景中，往往没有一个微前端框架是处处完美的，那么如果评估一个微前端框架的成熟度呢？<br>我推荐从 3 个维度来评价，分别是：</p>\n<ul>\n<li>运行隔离</li>\n<li>应用侵入</li>\n<li>使用体验</li>\n</ul>\n<p>「运行隔离」代表着微前端框架基座、子应用之间是否会相互影响，能够做到在需要影响的时候影响（例如模态框），不需要影响的时候完全隔离（例如样式污染，\b上下文污染）。<br>「应用侵入」代表着框架对基座和子应用的侵入性，对应用尽可能低的侵入，才能让应用有更大的扩展空间和更低的接入成本。<br>「使用体验」代表框架在开始开发到上线使用整个流程里的使用体验，包含代码开发、热更新调试、版本控制、持续集成、性能优化等，一个成熟的微前端框架，在使用体验上一定做的不差。</p>\n<h2 id=\"二、微前端之巅-乾坤\"><a href=\"#二、微前端之巅-乾坤\" class=\"headerlink\" title=\"二、微前端之巅 - 乾坤\"></a>二、微前端之巅 - 乾坤</h2><p>说了这些微前端理念，那么在当下的技术生态中，哪个微前端框架最成熟呢？那一定是「乾坤」了，本文除了介绍微前端的概念之外，还会深入「乾坤」的实现原理来剖析，「乾坤」是如何一步一步优化和精进，从而成为当前的「微前端之巅」的。</p>\n<h3 id=\"2-1-Why-乾坤\"><a href=\"#2-1-Why-乾坤\" class=\"headerlink\" title=\"2.1 Why 乾坤\"></a>2.1 Why 乾坤</h3><p><a href=\"https://github.com/umijs/qiankun\">乾坤(qiankun)</a>的命名由来：</p>\n<blockquote>\n<p>In Chinese traditional culture qian means heaven and kun stands for earth, so qiankun is the universe.</p>\n</blockquote>\n<p>看到乾坤的作者用英语描述乾坤的含义时，竟然有一点点想笑。<br>为什么说 qiankun 是微前端之巅呢？<br>市面上的微前端框架除了 qiankun 之外，应该就属 <code>single-spa</code> 最流行了，<code>single-spa</code> 是一个扩展性极高的微前端框架，他仅仅只实现了微前端基座与子应用的一些约定部分，例如生命周期，加载方式等等。其余的东西都需要自己开发，对于一个普通用户来说 <code>single-spa</code> 是无法直接上手使用，需要进行二次开发。<br>而乾坤是正是基于 <code>single-spa</code> 二次开发的，\b在 <code>single-spa</code> 的基础上优化了使用体验并扩展了功能，使得乾坤成为了一个开箱即用，功能强大的微前端框架。可以说乾坤是站在 <code>single-spa</code> 的肩膀上成为微前端之巅的。<br>目前国内大多数微前端架构的技术方案都是采用的乾坤。</p>\n<h3 id=\"2-2-乾坤的核心实现\"><a href=\"#2-2-乾坤的核心实现\" class=\"headerlink\" title=\"2.2 乾坤的核心实现\"></a>2.2 乾坤的核心实现</h3><p>本小结会详细介绍「乾坤」是如何连接基座与子应用的，以及「乾坤」的具体实现和技术原理是怎么样的。</p>\n<blockquote>\n<p>注：下文 qiankun 和 「乾坤」均指这个框架。qiankun 是他的英文名。「基座」代表微前端中的容器 - 主应用，容器内显示的称为「子应用」</p>\n</blockquote>\n<h4 id=\"2-2-1-应用接入原理\"><a href=\"#2-2-1-应用接入原理\" class=\"headerlink\" title=\"2.2.1 应用接入原理\"></a>2.2.1 应用接入原理</h4><p>如果把基座看成是一个架子，子应用是架子里内容的一部分。基座和子应用都是单独部署的两个地址，那么第一个问题：</p>\n<blockquote>\n<p>基座是如何加载子应用的？\b</p>\n</blockquote>\n<p>在主流微前端框架中，加载的方式一般分为两种：</p>\n<ul>\n<li>JS Entry - 子应用打包时将所有资源（html、css、js）全部打包成一个 js 文件。基座通过加载这个 js 加载子应用。</li>\n<li>HTML Entry - 子应用按照原有的模式打包，基座通过加载应用的入口文件（index.html），然后再加载入口文件中的页面资源，最终汇总成 html、css、js 资源再加载到页面。</li>\n</ul>\n<p>两种方式各有优劣，从体验的角度出发，HTML Entry 的体验更好，且侵入性更低，所以 qiankun 选择用 HTML Entry 的方式来加载子应用。\b   </p>\n<p><strong>那么 qiankun 又是怎么实现 HTML Entry 的呢？</strong><br>在 qiankun 的源码中，作者将这一部分抽离成了单独的 npm 库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;import-html-entry&quot;: &quot;^1.9.0&quot;</span><br></pre></td></tr></table></figure>\n<p>这个库主要做了这些事情：</p>\n<ol>\n<li>加载 entry html (index.html) 的内容到内存。</li>\n<li>将 entry html 中的 css、js、link 等标签下的内容获取出来（包含外部的和内联的），整理成网页所需的 js、css 列表。并将无用标签去掉（例如注释、ignore 等）。</li>\n<li>加载所有外链 js 脚本，并将这些外链 js 和内联 js 一起整理为 script list。</li>\n<li>加载所有外链 css 文件，并将其以内联（<code>&lt;style/&gt;</code>）的方式插入到 entry html 中。</li>\n<li>将处理后的 entry html 和待执行的 script list 返回给调用方（基座）。</li>\n</ol>\n<p>在 <code>import-html-entry</code> 库处理完之后，基座在需要的加载子应用时候将这个 html 放到对应的 DOM 容器节点，并执行 script list，即完成子应用的加载。<br>同时为了满足丰富的实际场景，<code>qiankun</code> 还提供了预加载和按需加载两种策略，以供不同的场景使用，开启预加载之后，基座会在浏览器空闲时（requestIdleCallback）加载其余子应用，反之，只会在需要显示子应用的时候加载。</p>\n<p>到这里，你可能会有第二个问题：</p>\n<blockquote>\n<p>上文只是说如何将应用加载到页面上，并没有说怎么建立关系，基座和子应用之间是如何建立关系的呢？</p>\n</blockquote>\n<p>\b首先在 <code>qiankun</code> 框架中，约定子应用必须导出 <code>bootstrap、mount、unmount</code> 三个声明周期函数，且必须以 <code>umd</code> 的格式导出模块。以 <code>Vue</code> 子应用的代码举例如下：<br><strong>main.ts</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export async function bootstrap() &#123;</span><br><span class=\"line\">  console.log(&quot;[vue] vue app bootstraped&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export async function mount(props: any) &#123;</span><br><span class=\"line\">  console.log(&quot;[vue] props from main framework&quot;, props);</span><br><span class=\"line\">  render(props);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export async function unmount() &#123;</span><br><span class=\"line\">  instance.$destroy();</span><br><span class=\"line\">  instance.$el.innerHTML = &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>vue.config.js</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">configureWebpack: &#123;</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            // 把子应用打包成 umd 库格式</span><br><span class=\"line\">            library: `$&#123;name&#125;-[name]`,</span><br><span class=\"line\">            libraryTarget: &#x27;umd&#x27;,</span><br><span class=\"line\">            jsonpFunction:`webpackJsonp_$&#123;name&#125;`,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>在上文最后，我们在加载子应用时\b有提到“执行 script list” 的步骤，这个步骤在执行完毕之后，就会检测该模块是否导出这三个生命周期函数，如果导出了，则认为这是一个子应用。    </p>\n<p>这三个生命周期函数分别的含义是：</p>\n<ul>\n<li>bootstrap 应用被装载。在应用首次初始化完成后触发，上文有提到 “执行 script list”，script list 执行完成后，即开始执行 bootstrap 函数。注意，此时应用只是被初始化，并不代表马上将要被显示。</li>\n<li>mount 应用被挂载。在应用需要显示时触发，此时，基座已经为子应用分配了 DOM 节点，然后调用 mount 函数。子应用在 mount 函数中可以根据基座分配的 DOM 节点，将子应用的内容渲染进去。</li>\n<li>unmount 应用被卸载。在子应用被关闭时触发，子应用需要在此函数中做一些清理操作。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，bootstrap 函数只会执行一次，而 mount 和 unmount 会根据基座对子应用的控制可能会执行多次。</p>\n</blockquote>\n<p>qiankun 在加载子应用时，会为 window 注入标志性变量 <code>window.__POWERED_BY_QIANKUN__</code>，子应用通过此标志来决定在基座中的加载逻辑和独立运行的加载逻辑，从而实现子应用可以在基座内外均可独立运行。</p>\n<h4 id=\"2-2-2-隔离的原理\"><a href=\"#2-2-2-隔离的原理\" class=\"headerlink\" title=\"2.2.2 隔离的原理\"></a>2.2.2 隔离的原理</h4><p>子应用和基座的隔离主要有两点：</p>\n<ol>\n<li>样式隔离</li>\n<li>js 隔离</li>\n</ol>\n<h5 id=\"样式隔离\"><a href=\"#样式隔离\" class=\"headerlink\" title=\"样式隔离\"></a>样式隔离</h5><p>要想做到子应用和基座之间的样式不会相互干扰，首先要做的就是样式隔离。<br>qiankun 提供了 3 种模式来实现不同效果的样式隔离：</p>\n<ol>\n<li><strong>动态载入 CSS(默认)</strong> - 代码中的配置为 <code>sandbox = true</code> ，这种模式的做法是直接将子应用的样式（2.2.1 中的 css 列表）全部直接加载到子应用挂载的 DOM 节点内，这样在卸载子应用的时候，移除该 DOM 节点，就可以自动去掉子应用使用的 css。但这种模式可能会导致子应用内的样式影响到基座。（例如子应用内和基座对同一个 id 的 DOM 元素配置了样式）</li>\n<li><strong>Shadow DOM 样式隔离</strong> - 代码中的配置为 <code>sandbox.strictStyleIsolation = true</code>，这种模式是使用浏览器原生的 Shadow DOM(mode = open) 实现，从而达到 Shadow Root 下的 css 无法影响到外部。参考链接：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM\">Shadow DOM</a></li>\n<li><strong>Scoped CSS 样式隔离</strong> - 代码中的配置为 <code>sandbox.experimentalStyleIsolation = true</code>。这种模式通过为 css 选择器添加 <code>[data-...]</code> 限制，从而实现样式的隔离，这种模式可以做到应用内的样式不会影响到外部。</li>\n</ol>\n<p><strong>咋眼一看，你一定会觉得，第 2，3 种方案更好，能够做到完全隔离，第一种会影响基座，但为什么 qiankun 默认的是第 1 种方案呢？</strong>   </p>\n<p>当然还是因为体验的原因，我们在 UI 开发的过程中，会使用到类似「模态框」、「引导框」这样的组件，这样的组件往往需要直接挂载到 body 下，对网页整体加上蒙版什么的，如果我们使用第 2，3 种方案，那么子应用就只能在子应用内部玩，对子应用外的样式全部无效，弹框之类的也会变得很丑，还可能有 bug。如下图：<br>第 2,3 种方案：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-5-28/1622192030980-image.png\"><br>第 1 种方案：<br><img src=\"https://cdn.jsdelivr.net/gh/csgajcr/imageroom/2021-5-29/1622254339541-image.png\"></p>\n<p>可见，没有遮罩的弹框显得索然无味。 </p>\n<p>所以综合权衡之下，qiankun 默认使用方案 1，通过人为约束子应用样式和基座区分开，也可以做到既满足弹框遮罩的场景，又实现基座和子应用样式互不影响。</p>\n<h5 id=\"js-隔离\"><a href=\"#js-隔离\" class=\"headerlink\" title=\"js 隔离\"></a>js 隔离</h5><p>js 隔离的核心是在基座和子应用中使用不同的上下文 (global env)，从而达成基座和子应用之间 js 运行互不影响。</p>\n<blockquote>\n<p>简单来说，就是给子应用单独的 <code>window</code>，避免对基座的 <code>window</code> 造成污染。</p>\n</blockquote>\n<p>qiankun 在 js 隔离上，同样提供了 3 种方案，分别是：</p>\n<ol>\n<li><code>LegacySandbox</code> - 传统 js 沙箱，目前已弃用，\b需要配置 <code>sandbox.loose = true</code> 开启。此沙箱使用 <code>Proxy</code> 代理子应用对 window 的操作，将子应用对 window 的操作同步到全局 window 上，造成侵入。但同时会将期间对 window 的新增、删除、修改操作记录到沙箱变量中，在子应用关闭时销毁，再根据记录将 window 还原到初始状态。</li>\n<li><code>ProxySandbox</code> - 代理 js 沙箱，非 IE 浏览器默认使用此沙箱。和 <code>LegacySandbox</code> 同样基于 <code>Proxy</code> 代理子应用对 window 的操作，\b和 <code>LegacySandbox</code> 不同的是，<code>ProxySandbox</code> 会创建一个虚拟的 window 对象提供给子应用使用，哪怕是在运行时，子应用也不会侵入对 window，实现完全的隔离。</li>\n<li><code>SnapshotSandbox</code> - 快照 js 沙箱，IE 浏览器默认使用此沙箱。因为 IE 不支持 <code>Proxy</code>。\b\b此沙箱的原理是在子应用启动时，创建基座 window 的快照，存到一个变量中，子应用的 window 操作实质上是对这个变量操作。<code>SnapshotSandbox</code> 同样会将子应用运行期间的修改存储至 <code>modifyPropsMap</code> 中，以便在子应用创建和销毁时还原。</li>\n</ol>\n<blockquote>\n<p>注：样式隔离、JS 隔离都在会子应用 mount 前，bootstrap 时处理。</p>\n</blockquote>\n<p>当然除了这些基本的隔离处理之外，qiankun 还提供了对 window 的各种监听和定时器的 Hook，保证子应用完整的销毁。   </p>\n<p>综合来说，qiankun 的 js 隔离方式比较完善，足够满足在子应用内的隔离需求了。</p>\n<h4 id=\"2-2-3-通信、路由的原理\"><a href=\"#2-2-3-通信、路由的原理\" class=\"headerlink\" title=\"2.2.3 通信、路由的原理\"></a>2.2.3 通信、路由的原理</h4><p>相比于上文子应用隔离的原理而言，通信和路由更加偏向于应用，qiankun 在这两方面的设计基于微前端理念中的「低耦合度」。技术实现则是直接基于 <code>single-spa</code> 的基础，做了一点简单的扩展。</p>\n<h5 id=\"通信的原理\"><a href=\"#通信的原理\" class=\"headerlink\" title=\"通信的原理\"></a>通信的原理</h5><p>在通信部分，qiankun 提供了全局的 state 供子应用和基座使用。同时提供了 2 个函数供子应用操作使用，分别是：</p>\n<ul>\n<li>onGlobalStateChange: <code>(callback: OnGlobalStateChangeCallback, fireImmediately?: boolean) =&gt; void</code> 在当前应用监听全局状态，有变更触发 callback，fireImmediately = true 立即触发 callback</li>\n<li>setGlobalState: <code>(state: Record&lt;string, any&gt;) =&gt; boolean</code> 按一级属性设置全局状态，子应用中只能修改已存在的一级属性</li>\n</ul>\n<blockquote>\n<p>注：<code>setGlobalState</code> 子应用仅能对全局 state 已存在的一级属性做修改，不能对 state 新增或删除属性。<code>onGlobalStateChange</code> 监听数据变化同样只针对于 state 已存在的一级属性。</p>\n</blockquote>\n<p>这样设计的目的是想把全局 state 的掌控权交给基座主应用，避免子应用乱操作。   </p>\n<p>如果以上数据的通信不够用，也可以使用 <code>window.addEventListener</code> 直接进行事件通信。</p>\n<h5 id=\"路由的原理\"><a href=\"#路由的原理\" class=\"headerlink\" title=\"路由的原理\"></a>路由的原理</h5><p>qiankun 提供单实例（单个子应用）和多实例（多个子应用同时显示）模式。这里我们只讨论单实例模式，多实例模式目前还处于实验性阶段，多实例路由目前无法使用。</p>\n<p>单实例模式下，qiankun 支持子应用使用 <code>hash</code> 和 <code>history</code> 两种路由模式，如果使用 <code>history</code> 需要设置 <code>base</code>。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  mode: &#x27;history&#x27;,</span><br><span class=\"line\">  base: &quot;/frame1&quot;,</span><br><span class=\"line\">  routes</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>qiankun 在 <code>registerMicroApps</code> 中获取应用激活规则和入口地址，在规则触发时就会加载该子应用，子应用加载完成后，应用内路由的权利就完全交给子应用了。<br>如果子应用资源使用的相对路径加载，那么子应用需要在被加载的第一时间指定 <code>webpack_public_path</code> 然后再初始化。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (window.__POWERED_BY_QIANKUN__) &#123;</span><br><span class=\"line\">  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步，qiankun 将子应用在基座中配置的入口地址传递给子应用，子应用指定 <code>webpack_public_path</code> 后即可正确加载页面资源。</p>\n<h2 id=\"三、总结-amp-思考\"><a href=\"#三、总结-amp-思考\" class=\"headerlink\" title=\"三、总结 &amp; 思考\"></a>三、总结 &amp; 思考</h2><p>本文的写作过程是非常花费精力的，作者从一开始对微前端不怎么了解，通过大量查阅资料、阅读源码配合一些实际操作经验，结合自身对微前端的理解，最终输出了本篇文章。<br>在这一路上，我发现了 qiankun 的一路迭代不光是依靠一个又一个的技术人书写精巧的代码堆砌而成，更重要的是 qiankun 的使命和设计思路的构建，在阅读乾坤技术圆桌的文章时，qiankun 的作者 <code>kuitos</code>、阿里内部开发者、社区贡献者对 qiankun 的使命和核心进行了非常深度的思考，多次精彩的脑暴和思维碰撞，这些思考指引着 qiankun 的发展，让 qiankun 的未来\b脱离传统「微前端」思想的束缚。<br>放眼整个框架圈，不光是 qiankun，许多知名开源框架都有这个过程。由此可以去想，我们在做技术组件，在做一些抽象的底层代码时，是否仔细去想过它的核心价值是什么。缺乏核心价值指导的组件是缺少灵魂的，它可以解决当下的问题，但也许无法面向未来。</p>\n","categories":["Web前端"],"tags":["Web前端","Web","微前端","架构"]},{"title":"聊聊技术面试","url":"/2022/02/21/thinking-about-interview/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近因为工作安排，我需要为我们小组面试一些合适的开发人员，其中有包括 <code>Android</code>、<code>Web</code>、<code>后端</code> 几个领域，面试的人加起来少说也有好几十个了。但其实通过的并不多，甚至不到 1/10，有时候甚至会开始怀疑是不是自己要求太高了，或者面试的点不对。于是也在不断的精进自己技术面试的方法，虽然在多次改进之后通过率并没有提升，但至少相比最开始的「轰炸式」面试还是科学很多，本篇文章的主要内容就是分享这些感受和心得。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"第一次面试\"><a href=\"#第一次面试\" class=\"headerlink\" title=\"第一次面试\"></a>第一次面试</h2><p>第一次作为主技术面试官面试别人的时候，我还是很紧张的，记得那次的受害人是一名 <code>Android</code> 开发。那时我已经 1 年多没有碰过 Android 研发了，很多知识自己也忘了，为了能 hold 住场面，我仔细阅读了简历，找出了一些能问的点，然后在网上找了很多份面试题，筛选了其中一部分我觉得还不错的题目记录下来，准备面试。面试开始的时候，我很自信，在他自我介绍完之后，开始了我早已准备好的「轰炸式」面试，一波儿下来，这名受害人明显招架不住这些即全面又深入的知识，节节败退，最终以不通过告终。虽然说我准备了这么多问题，但并没有故意刁难对方，秉承着能答到“够开发我们项目的标准”就给过，但他还是没有达到。</p>\n<p>经过这次面试后，我想，虽然结果还算客观，考察也算全面，但我也太辛苦了，得花很多时间去准备，未来随着面试的增多，一定不可能每份简历都这么玩。所以我就在想，在仅有的面试时间中，如何更客观、准确的评估候选人的真实能力，以及与岗位的匹配度呢？</p>\n<h2 id=\"考察的维度\"><a href=\"#考察的维度\" class=\"headerlink\" title=\"考察的维度\"></a>考察的维度</h2><p>回到面试本身的目的，面试是为了在许多候选人中找到一些适合对应工作岗位的候选人。<br>所以，考察的维度，一定和岗位本身是息息相关的。除了一些需要特别考察的能力之外，一般技术面试的场景，考察的维度有以下几个：</p>\n<ul>\n<li>技术能力：是否匹配工作岗位所需能力，深度和广度是否足够，能否快速上手。</li>\n<li>技术潜力：培养价值如何，哪怕与岗位能力不是很匹配，如果技术潜力优异，那么也是很值得考虑的。</li>\n<li>软实力：是否可以相互理解对方的意思，是否能把一个观点表达清楚。</li>\n<li>心态：是否拥有一颗开放的心态去面对问题。</li>\n</ul>\n<p>接下来，聊聊在考察以上维度时，我个人的一些方法和习惯。</p>\n<h3 id=\"技术能力\"><a href=\"#技术能力\" class=\"headerlink\" title=\"技术能力\"></a>技术能力</h3><p>考察技术能力是一个体力活儿，我个人喜欢把技术问题分为两大类：</p>\n<ol>\n<li>基础知识和原理 - 考察基础是否扎实</li>\n<li>候选人所掌握的技能 - 考察候选人的技术水平、潜力和亮点</li>\n</ol>\n<p>对于必备的基础知识和原理，照着问即可，如果答得好，可以追问一些原理类、思想类的问题。这一类问题就像是基础分，60 和 80 的区别不是很大，80+ 则可以用基础扎实来形容。<br>对于候选人所掌握的技能，我会根据候选人的项目经历和技能列表来出题，由浅入深，由点到面的问问题，这样既能考察候选人的技术深度，也能考察技术广度。在回答的过程中往往都会包含候选人的一些亮点。</p>\n<p><strong>你可能会问，为什么是候选人所掌握的技能，而不是岗位需要的技能呢？</strong><br>如果候选人掌握岗位所需的技能，那这是最好，可以多问。<br>如果候选人不掌握，那该技术又可以分为 2 种情况：</p>\n<ol>\n<li>学习成本很高，不会就不要的</li>\n<li>学习成本不高，来了可以学的</li>\n</ol>\n<p>对于第一种，一般可以在看简历的时候，初筛掉。<br>对于第二种，人家不会你问了也没用，而且成本不高，来了也可以学。那么应该重点考察候选人掌握的技能，潜力足够的话，也能很快掌握。</p>\n<p>一般问完候选人所掌握的技能之后，对候选人的评价已经有个大概了，如果不行，这时就可以结束面试了。如果觉得还可以，那么可以继续下一个考察项。</p>\n<h3 id=\"技术潜力\"><a href=\"#技术潜力\" class=\"headerlink\" title=\"技术潜力\"></a>技术潜力</h3><p>在上一步「技术能力」考察中，已经可以通过该同学工作的年限，和掌握技术的深度、广度得出初步的潜力，有潜力的同学和潜力一般的同学会有比较明显的差距。<br>除了这种实力上的差距之外，我一般还会问一些开放性问题来考察，例如：</p>\n<ol>\n<li>在 XXX 项目中，你解决过最棘手的问题是什么，怎么解决的，简单描述一下。</li>\n<li>你觉得你最大的优势是什么。</li>\n<li>平时你是怎么学习新知识，新技术的，如何体系化的学习一个技术。</li>\n</ol>\n<p>对于问题 1，可以关注候选人解决问题的思路，思考能力，以及韧性等。<br>对于问题 2，关注候选人对自己的认知，以及面试官对候选人的认知。<br>对于问题 3，关注候选人的学习习惯，以及系统性思维。<br>这仨问题没有标准答案，有潜力的同学和潜力一般的同学在这一环节的回答往往也有明显的差距，但有一点要注意，这类开放性问题也许他自己没有仔细思考对比过，所以给出的答案可能并不能代表他的实力，相比回答本身，更需要关注候选人为什么会给出这个回答，通过这仨问题，可以让你对候选人的潜力有一个更清晰的认知。</p>\n<blockquote>\n<p>问题 1，2 有的时候都能听到很不错的回答。但是问题 3，最容易听到的回答就是博客、论坛、公众号、看视频、看书等等。能对体系化学习有系统性思考的回答几乎没有听到过，不确定是不是这个问题没有设计好。</p>\n</blockquote>\n<h3 id=\"软实力-amp-心态\"><a href=\"#软实力-amp-心态\" class=\"headerlink\" title=\"软实力 &amp; 心态\"></a>软实力 &amp; 心态</h3><p>表达和沟通能力在技术能力的考察过程中，也能有一个初步的结论，如果面的是初中级（P3 - P5）的候选人或者比较年轻的候选人，那么软实力一般不会额外问，即使不那么好，只要不是太差或者很离谱，随着团队的磨合与培养，一般来说也没有什么问题。<br>对于一些具备管理经验，或者经验丰富的候选人来说，一般会多问两句，例如，如何去协调时间计划冲突，如何去推动一些规范等等问题。当然这一部分主要还是在非技术面里考察，技术面里关注的软实力更多的是能否与研发团队的其他角色顺利的打交道。</p>\n<p>心态和软实力有相似之处，所以就放到一起了，在技术面里都不是主要考察的内容，但可以作为一些参考，在心态上我一般会结合情况问一些偏感性的问题，比如：平时会加班吗，感觉怎么样，怎么看待加班。或是问他怎么和产品经理协作，有没有遇到过产品设计不合理的情况，以及研发团队的一些问题等等，通过这些偏感性的问题，可以了解候选人的心态是否足够开放，是否客观，偏理性还是偏感性，有没有戾气等等。</p>\n<h2 id=\"总结-amp-感受\"><a href=\"#总结-amp-感受\" class=\"headerlink\" title=\"总结 &amp; 感受\"></a>总结 &amp; 感受</h2><p>以上，就是我当前对技术面试的一些理解和看法。通过这几十波儿面试，我认为面试的核心是一个挖掘的过程，挖掘候选人的能力、亮点和问题，而不是想着如何把候选人考倒。在众多面试的候选人中，往往优秀的候选人是可以全方位吊打普通候选人的，无论是技术实力还是软实力，但这样的人实在是太少了。当然，并不是所有人都是「优秀」或者「不优秀」，大部分的候选人都处于有优秀的地方，但也有一些问题的情况，遇到这类候选人，有的问题可能答得不好，但当你挖掘到他的亮点时，他的回答还是能让你感觉到很 nice，所以大多数时候，更多的是取舍与权衡，根据岗位性质和面试官「挖掘」出的结果来评估，最终形成是否录用的结论。</p>\n","categories":["思考"],"tags":["成长","工作","面试"]},{"title":"Vuejs 项目从 JS 迁移至 TS","url":"/2020/05/25/vuejs-js-migrate-ts/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>TypeScript 是 Javascript 类型的超集，它可以编译成纯 Javascript。</p>\n</blockquote>\n<p>随着时间的推移，项目的不断增大，TypeScript 的优势越来越明显。虽然在代码量上，TypeScript 会多一些，但是其提供的类型检查，代码索引等功能大大增加了项目的可维护性。所以我推荐在 Vue 项目中也使用 Typescript，也许使用的过程对初学者并不是那么友好，但我认为从项目维护的角度出发，是值得去折腾的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、为什么要迁移\"><a href=\"#一、为什么要迁移\" class=\"headerlink\" title=\"一、为什么要迁移\"></a>一、为什么要迁移</h2><h3 id=\"1-1-TS-的优势\"><a href=\"#1-1-TS-的优势\" class=\"headerlink\" title=\"1.1 TS 的优势\"></a>1.1 TS 的优势</h3><ol>\n<li><p><strong>静态检查</strong><br>ts 的静态检查可以让我们在预编译的过程中发现代码中潜藏的问题，并予以修复。</p>\n</li>\n<li><p><strong>可维护性提升</strong><br>相较于 js 或者 es6 来说，ts 的代码可读性远高于他们。同时，在编写时也有很好的约束，来降低代码所产生的 BUG 概率。</p>\n</li>\n<li><p><strong>兼容性</strong><br>ts 可以近乎完美的兼容 js ，即使在 ts 编译报错的情况，仍然可以编译为 js 代码运行。这代表着在迁移的时候会方便不少。</p>\n</li>\n<li><p><strong>生态</strong><br>ts 有着良好的生态，前端的开源库中，大部分都会提供 ts 的声明文件，使得使用者更方便、准确的使用。</p>\n</li>\n</ol>\n<h3 id=\"1-2-可维护性\"><a href=\"#1-2-可维护性\" class=\"headerlink\" title=\"1.2 可维护性\"></a>1.2 可维护性</h3><p>一个好好的 js 项目为什么要迁移成 ts 呢，对于一个需要持续维护的前端项目来说，ts 的优势中最核心的就是「可维护性」的提升了。<br>可维护性主要体现在以下几个方面：</p>\n<ol>\n<li>类型拓展<br>javascript 是弱类型语言。Typescript 在类型上做了补充，这使得在写代码的时候，编辑器就可以告诉我们方法调用、定义、参数传递有没有错误。通过类型的约束来提高代码的稳定性。</li>\n<li>类的拓展<br>在 ES 当中也有类的概念，和 Typescript 的类不同，Typescript 对类做了更多的拓展，使其在面向对象的研发思想的运用上，更加自然和方便。</li>\n</ol>\n<h2 id=\"二、准备！\"><a href=\"#二、准备！\" class=\"headerlink\" title=\"二、准备！\"></a>二、准备！</h2><p>在开始之前需要先了解 vue-class-component、vue-property-decorator 和 tslint 。他们仨都是 vue + ts 的好帮手。</p>\n<h3 id=\"2-1-vue-class-component\"><a href=\"#2-1-vue-class-component\" class=\"headerlink\" title=\"2.1 vue-class-component\"></a>2.1 vue-class-component</h3><blockquote>\n<p>vue-class-component 项目地址:<a href=\"https://github.com/vuejs/vue-class-component\">https://github.com/vuejs/vue-class-component</a></p>\n</blockquote>\n<p>vue-class-component 是一个让我们以 ts 类的形式来编写 Vue Component 的库。<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &#123;&#123; count &#125;&#125;</span><br><span class=\"line\">    &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import Component from &#x27;vue-class-component&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// Define the component in class-style</span><br><span class=\"line\">@Component</span><br><span class=\"line\">export default class Counter extends Vue &#123;</span><br><span class=\"line\">  // Class properties will be component data</span><br><span class=\"line\">  count = 0</span><br><span class=\"line\"></span><br><span class=\"line\">  // Methods will be component methods</span><br><span class=\"line\">  increment() &#123;</span><br><span class=\"line\">    this.count++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decrement() &#123;</span><br><span class=\"line\">    this.count--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>有了 vue-class-component 之后，vue 组件的 data、methods 以及生命周期处理更加清晰一目了然。但这样也有一些缺点，比如当某个组件逻辑极为复杂的时候，我们会写出一个代码很长的类。这从代码整洁的角度来说，是不太友好的。</p>\n<h3 id=\"2-2-vue-property-decorator\"><a href=\"#2-2-vue-property-decorator\" class=\"headerlink\" title=\"2.2 vue-property-decorator\"></a>2.2 vue-property-decorator</h3><blockquote>\n<p>vue-property-decorator 项目地址:<a href=\"https://github.com/kaorun343/vue-property-decorator\">https://github.com/kaorun343/vue-property-decorator</a></p>\n</blockquote>\n<p>vue-property-decorator 是对 vue-class-component 库的拓展，它需要在 vue-class-component 的基础上进行使用。提供了更加丰富的 decorator（可以理解为 Java 中的注解）来方便 Vue Component 的开发。<br>例如对属性 Props 的简化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; Vue, Component, Prop &#125; from &#x27;vue-property-decorator&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\">export default class YourComponent extends Vue &#123;</span><br><span class=\"line\">  @Prop(Number) readonly propA: number | undefined</span><br><span class=\"line\">  @Prop(&#123; default: &#x27;default value&#x27; &#125;) readonly propB!: string</span><br><span class=\"line\">  @Prop([String, Boolean]) readonly propC: string | boolean | undefined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    propA: &#123;</span><br><span class=\"line\">      type: Number</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    propB: &#123;</span><br><span class=\"line\">      default: &#x27;default value&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    propC: &#123;</span><br><span class=\"line\">      type: [String, Boolean]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"三、开始！\"><a href=\"#三、开始！\" class=\"headerlink\" title=\"三、开始！\"></a>三、开始！</h2><p>这里主要以 vue-cli 的项目为例。vue-cli 提供的有 typescript-plugin。这个插件可以用于将现有项目迁移至 typescript。 </p>\n<h3 id=\"3-1-引入\"><a href=\"#3-1-引入\" class=\"headerlink\" title=\"3.1 引入\"></a>3.1 引入</h3><p>网上有很多文章都是说的手动添加 cli-plugin-typescript 依赖，然后按照标准项目结构，一个一个添加，一个一个改。这样有些麻烦，cli-plugin-typescript 提供了自动化的项目更改。仅仅需要执行以下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev typescript</span><br><span class=\"line\">npm install --save-dev @vue/cli-plugin-typescript</span><br><span class=\"line\">vue add typescript</span><br></pre></td></tr></table></figure>\n<p>执行之后会有如下提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">✔  Successfully installed plugin: vue-cli-plugin-typescript</span><br><span class=\"line\"></span><br><span class=\"line\">? Use class-style component syntax? (Y/n) </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里，询问我们是否使用 class 形式的组件语法。选择 <code>Y</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX) ?</span><br></pre></td></tr></table></figure>\n<p>这里，询问我们是否使用 Babel 编译插件，选择 <code>Y</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Convert all .js files to .ts?</span><br></pre></td></tr></table></figure>\n<p>这里，询问我们是否自动将所有 js 文件转换为 ts 文件，注意，这里的转换，只是转换文件名，代码并不会自动变更。选择 <code>Y</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Allow .js files to be compiled? </span><br></pre></td></tr></table></figure>\n<p>这里，询问我们是否支持 js 文件编译。选择 <code>Y</code><br>成功后提示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">✔  Successfully invoked generator for plugin: @vue/cli-plugin-typescript</span><br><span class=\"line\">   The following files have been updated / added:</span><br></pre></td></tr></table></figure>\n<p>这里会列出变更的文件。<br>插件会帮我们自动生成 vue 相关的声明文件 <code>shims-tsx.d.ts</code> 和 <code>shims-vue.d.ts</code> 还有 <code>tsconfig.json</code> 配置文件，我们可以按需修改这些配置。</p>\n<h3 id=\"3-2-如何修改\"><a href=\"#3-2-如何修改\" class=\"headerlink\" title=\"3.2 如何修改\"></a>3.2 如何修改</h3><p>完成上一步操作之后，项目的每个组件和 js 文件都会变成 ts 文件。但是里面的代码并没有变化，需要我们手动进行每个文件的修改。<br>.vue 文件我们需要按照 vue-property-decorator 的方式进行修改。<br>示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class=\"line\">    &lt;HelloWorld msg=&quot;Welcome to Your Vue.js + TypeScript App&quot;/&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class=\"line\">import &#123; Component, Vue &#125; from &#x27;vue-property-decorator&#x27;;</span><br><span class=\"line\">import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    HelloWorld,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default class App extends Vue &#123;&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;less&quot;&gt;</span><br><span class=\"line\">#app &#123;</span><br><span class=\"line\">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class=\"line\">  -webkit-font-smoothing: antialiased;</span><br><span class=\"line\">  -moz-osx-font-smoothing: grayscale;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  color: #2c3e50;</span><br><span class=\"line\">  margin-top: 60px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>普通的 ts 文件需要按照 typescript 的写法，补充一些类型的定义就可以了。</p>\n<blockquote>\n<p>注：有的文件可能会被 cli-typescript-plugin 的模板所覆盖，需要手动修改。</p>\n</blockquote>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>这种迁移的方式，相比纯手动来说，方便了一点点。但还是需要每一个文件自己改。那么有没有一种可以自动转换的方法呢？我查阅了一些资料，发现这一篇文章提供的思路还不错，是将代码逻辑转化为 AST ，然后再用 ts 去生成。对于大型项目，也许这是一种不错的思路。<br>参考链接：<a href=\"https://zhuanlan.zhihu.com/p/107595158\">https://zhuanlan.zhihu.com/p/107595158</a></p>\n","categories":["Web前端"],"tags":["Web","javascript","typescript","vuejs"]},{"title":"《价值》读后感","url":"/2021/07/18/worth-after-reading/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《价值》已经读完了，这本 500 页的书记录了作者张磊和张磊所创办的「高瓴」投资集团的心路历程。回想起阅读这本书之前，我一直以为这是一本讲经济、金融和投资的书籍，但书的第一章讲的却是作者自小的经历，从经历为起点，再到投资的哲学和价值的本质。深入浅出，将价值的本质和人生、经济、投资、产业等结合起来，为读者演绎了「价值」的魅力。<br>我欣赏作者的前瞻性，通过对价值本质的思考和探索，寻找创造价值的星星之火；通过对行业的深入和研究，形成不可阻挡的燎原之势。这些都离不开贯穿作者整个人生的理念：「长期主义的道路」、「做时间的朋友」、「与伟大的格局观者同行」和「守正用奇」。<br>那么，结合这些核心理念，谈谈我的感受。</p>\n<span id=\"more\"></span>\n<h2 id=\"长期主义之路\"><a href=\"#长期主义之路\" class=\"headerlink\" title=\"长期主义之路\"></a>长期主义之路</h2><p>「把时间和信念投入能够长期产生价值的事情中，尽力学习最有效率的思维方式和行为标准，遵循第一性原理，永远探求真理」是作者对「长期主义」的定义。在当下的这个浮躁和快节奏的时代，充满着各种各样的诱惑，有太多的人沉醉于短期和及时的满足，而忽略长期的价值。这导致大多数人更愿意去做短期能产生价值的事情，尽管这样的事情往往伴随着风险和竞争。而长期主义之路则是放眼于长期的收益，相比于直截了当的短期收益来说，更像是在「另辟蹊径」，更长的路径会伴随着更多的可能，路走的越长，就越难被复刻，积累的也会越来越多，使得你的付出与时间形成复利关系，源源不断的发挥价值。<br>长期主义的道路不是一条路走到黑，也不会一帆风顺，我们无法在一开始就预见许久之后的路，所以在我看来，长期主义的核心并不只是坚持和努力，更重要的是不断探索长期主义的方向，只有时刻保持一颗探求真理的心态，不断去挖掘长期主义道路的未来，在道路的分岔口做好每一次选择，才是一条长期主义道路的最佳护城河。<br><strong>那么，究竟怎么做才叫长期主义之路呢？</strong><br>站在我们每个人的角度，长期主义之路可以是我们生活息息相关的东西。往大了说，工作就是一条长期主义之路，生活也是。往小了说，一个习惯，一个想法都可以是一条长期主义之路。<br>拿工作来说吧，有些人会做职业生涯规划，来解决未来工作的各种问题，职业生涯规划就是长期主义之路的路。然而据我的观察，大多数人无论职业生涯规划做的多么严谨，多么完美，多么适合自己，最终发展结果和职业生涯规划匹配的人始终是少数。计划是真的赶不上变化，职业生涯规划之所以不是很准确，并不是因为制定规划本身不对，是因为缺乏「变化」。在这条规划之路中，最重要的则是中途如何调整，如何选择。所以一份真正可以指导自己的职业生涯规划，将会一直和自己相辅相成，随着自身的认知变化、能力变化、问题变化、状态的变化，不断改进，让自己和规划共同保持着进步。</p>\n<h2 id=\"做时间的朋友\"><a href=\"#做时间的朋友\" class=\"headerlink\" title=\"做时间的朋友\"></a>做时间的朋友</h2><p>与「长期主义之路」一样，做时间的朋友鼓励我们做事应从长计议，以长期收益为首要考虑方向，不能被眼前的短期利益所误导，权衡短期、中期、长期的价值，并找到其中的平衡点，让自己的目标与时间同行。</p>\n<h2 id=\"与伟大的格局观者同行\"><a href=\"#与伟大的格局观者同行\" class=\"headerlink\" title=\"与伟大的格局观者同行\"></a>与伟大的格局观者同行</h2><p>「选择与谁同行，比要去的远方更重要」，一个伟大的格局观者的魅力是无穷的，他们拥有超强的洞察力、同理心和执行力，能够保持初心、保持进化，能够从现象看本质，从转瞬看趋势，很多卓越的企业家和领导人都具备这些特质。在我们身边，这样的人总是极少数，他们不断散发着光芒，能以开放的心态和敏锐的思维去面对事物。正是因为有了他们，才有了向往的远方。所以，提升自己，让自己也变得卓越，如果可以找到他们，并与他们同行，是一件很酷的事情。<br>「夫尺有所短，寸有所长」，哪怕是一名伟大的格局观者，也有所长短。要成为他们，并不是需要完全具备所有优秀的特质。在这些优秀的特质中，我认为最核心的特质就是同理心了，同理心虽然人人都有，但一颗强大的同理心又特别稀缺，那怎么定义同理心的「强大」呢？我认为一颗强大的同理心可以让你保持头脑开放，理解现象、理解伙伴、理解需求、理解问题，以客观的视角去做选择和判断。我们常说，选择比努力更重要，而一颗强大同理心正是做选择时最需要的心态，它才是做「选择」最有用的技巧，\u001d让选择更接近真实。</p>\n<h2 id=\"守正用奇\"><a href=\"#守正用奇\" class=\"headerlink\" title=\"守正用奇\"></a>守正用奇</h2><p>「以正治国,以奇用兵」出自于老子所著的《道德经》，告诉我们治国要正，用兵要奇。在《价值》这本书中，作者也将「守正用奇」贯彻到整个高瓴的投资思想中，守住「价值」（正）创造的根本，用「不寻常」（奇）来帮助企业创造价值。<br>于我们个人来说，我认为「守正用奇」中的「守正」可以理解为遵守那些“正”的原则，「用奇」则理解为用更新颖、更有效的思路来解决问题。\b\b\b\b\b在我们的实际生活中，要守的正可能有很多，从社会层面的法律法规，道德品质，再到自身层面的不忘初心。用的奇更是数不胜数，每一次决策，每一个方案，每一盘游戏，每一行代码，都是在用奇招制胜。所以，我想作者要告诉我们的是：让我们一直坚守住“正”的东西，不要因为一时的私利而改变他们，同时保持一颗好奇心，不断去探索充满变化又价值满满的“奇”路。</p>\n","categories":["读书"]},{"title":"浅谈Unity与Android原生的桥接","url":"/2020/03/28/%E6%B5%85%E8%B0%88Unity%E4%B8%8EAndroid%E5%8E%9F%E7%94%9F%E7%9A%84%E6%A1%A5%E6%8E%A5/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在网络上，有许多关于 <em>Unity</em> 和 <em>Android</em> 互相调用的文章，里面的内容大同小异，都给出了相互调用最基本的方法。在这些文章中，有许多文章是很久之前的，里面的代码放到现在已经无法正常运行了，并且基本都说的比较简单。<br>本篇文章介绍的是以 Android 项目为主，Unity 项目为辅，以实战场景为基准来实现 <em>Unity</em> 和 <em>Android</em> 的桥接。在这其中，需要考虑桥接的功能型、稳定性、可拓展性、以及结合 <em>Android</em> 原生开发的一些特性。<br>那么究竟是如何实现的呢，请看下方详解！</p>\n<span id=\"more\"></span>\n<h2 id=\"一、原理概述\"><a href=\"#一、原理概述\" class=\"headerlink\" title=\"一、原理概述\"></a>一、原理概述</h2><p><em>Unity</em> 和 <em>Android</em> 桥接的原理和网络上大多数文章是一致的。<br>Unity 调用 Android 使用的是C#脚本所提供的 <em>AndroidJava</em> 系列工具类。<br>C#代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var javaClass = new AndroidJavaClass(&quot;[Java class package name]&quot;);</span><br><span class=\"line\">javaClass.CallStatic&lt;string&gt;(&quot;methodName&quot;, &quot;params1&quot;);</span><br></pre></td></tr></table></figure>\n<p>使用 AndroidJavaClass 调用是即方便又强大的，支持回调和返回值。且性能优秀。<br>Android 调用 Unity 使用的是 Unity 提供的 Jar包里的方法。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">UnityPlayer.UnitySendMessage(</span><br><span class=\"line\">            &quot;Unity Object Name&quot;,</span><br><span class=\"line\">            &quot;MethodName&quot;,</span><br><span class=\"line\">            &quot;message&quot;</span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure>\n<p>Unity Object Name 为 Unity 中场景对象的名称。<br>MethodName 为该对象绑定的脚本中的方法。<br>message 为发送的内容。<br>可以看到，Android 调用 Unity 的方式没有返回值，且只能是一个字符串类型的参数。所以如果想要达到两端统一调用，就需要一定的封装。那么具体是怎么封装的呢？请继续往下看！</p>\n<h2 id=\"二、架构分析\"><a href=\"#二、架构分析\" class=\"headerlink\" title=\"二、架构分析\"></a>二、架构分析</h2><p>首先，我们要对 Unity 与 Android 的桥接部分（以下简称：桥接层）进行架构的设计。</p>\n<blockquote>\n<p>注：本篇文章主要讨论以 Android 项目为主的情况，即为，Android 需要为Unity 提供大量功能接口。Unity 为 Android 部分提供少量接口。所以，这里的架构分析主要以 Android 原生部分的桥接层设计来进行后续的讲解。  </p>\n</blockquote>\n<p>架构的设计除了桥接层本身提供的业务功能，还需要考虑以下几个点：  </p>\n<ul>\n<li>方法调用设计</li>\n<li>回调机制的设计</li>\n<li>可拓展性</li>\n<li>接入便捷性</li>\n<li>可移植性</li>\n</ul>\n<p>这里先解释一下，为什么需要单独列出来回调机制的设计。在上文原理概述中，可以看到，Android 调用 Unity 的场景不支持回调、返回值和非字符串的传参。所以这里我们如果不进行回调机制的设计，那么将无法满足双方回调的场景。<br>下面，我们来逐一分析每一个点需要如何满足。</p>\n<h3 id=\"2-1-方法调用\"><a href=\"#2-1-方法调用\" class=\"headerlink\" title=\"2.1 方法调用\"></a>2.1 方法调用</h3><p>由于 Android 和 Unity 底层提供的相互调用接口不一致，所以如果想要达到相同的调用效果。就需要自行封装一套调用协议。这里，我们使用大家所熟知的 JSON 来作为方法调用协议的载体。<br>在调用的时候，将方法和其参数、回调信息，封装到一个对象中，序列化为JSON后传给对方。<br>方法调用协议举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;methodName&quot;,</span><br><span class=\"line\">\t&quot;callback&quot;: false,</span><br><span class=\"line\">\t&quot;args&quot;: [</span><br><span class=\"line\">\t\t&quot;&#123;\\&quot;name\\&quot;:\\&quot;argName1\\&quot;,\\&quot;value\\&quot;:\\&quot;value1\\&quot;&#125;&quot;,</span><br><span class=\"line\">\t\t&quot;&#123;\\&quot;name\\&quot;:\\&quot;argName2\\&quot;,\\&quot;value\\&quot;:\\&quot;value2\\&quot;&#125;&quot;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&quot;callbackId&quot;: &quot;callbackID&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上方的 JSON 就是方法对象序列化后的内容。方法对象的定义：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data class Command(</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 指令名称</span><br><span class=\"line\">     * 回调情况下name为回调ID</span><br><span class=\"line\">     */</span><br><span class=\"line\">    var name: String,</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 是否是回调指令</span><br><span class=\"line\">     */</span><br><span class=\"line\">    var callback: Boolean,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 参数List</span><br><span class=\"line\">     */</span><br><span class=\"line\">    var args: List&lt;String&gt;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回调ID</span><br><span class=\"line\">     */</span><br><span class=\"line\">    var callbackId: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>方法对象（下文也称指令对象）<br>方法对象主要分为两类，使用 Command.callback 字段来区分：<br>方法调用的对象：callback 为 false，代表一次普通的方法调用。<br>回调的对象：callback 为 true，代表一次回调的调用。<br>callback 相关的介绍请参考下方「2.2 回调机制」<br>简单解释一下每个参数的意义：  </p>\n<ul>\n<li>Command.name 指令名称  </li>\n</ul>\n<p>指令名称代表要调用的方法是什么。对方通过指令名称去执行对应的操作。<br><strong>注：在回调指令中，指令名称为回调的ID。</strong></p>\n<ul>\n<li>Command.args 参数列表  </li>\n</ul>\n<p>参数列表是一个字符串列表。列表每一个元素为一个参数信息的JSON。参数没有顺序要求。</p>\n<ul>\n<li>Command.callbackId 回调ID  </li>\n</ul>\n<p>callbackId 代表当次调用所携带的回调。callbackId 由调用方生成并维护。在需要回调时，被调用方根据 callbackId 发送回调指令实现回调的效果。<br>callbackId 格式32位随机字符串。</p>\n<hr>\n<p>因为 Unity 调用 Android 是支持返回值的。所以这里也对返回值进行了一次包装。类似网络请求的返回实体。<br>实体定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Result &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final int RESULT_SUCCESS = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static final int RESULT_EXCEPTION = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 错误码</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int code = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 错误信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 返回结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Object result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Unity 调用获取返回值的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var resultJson = bridgeClass.CallStatic&lt;string&gt;(&quot;onUnityCall&quot;, commandJson);</span><br><span class=\"line\">var result = JsonUtility.FromJson&lt;Result&lt;T&gt;&gt;(resultJson);</span><br></pre></td></tr></table></figure>\n<p><strong>注：这里的 onUnityCall 为 Android 提供的桥接入口方法。</strong></p>\n<h3 id=\"2-2-回调机制\"><a href=\"#2-2-回调机制\" class=\"headerlink\" title=\"2.2 回调机制\"></a>2.2 回调机制</h3><p>Command 方法对象已经可以满足我们的方法调用需求了。那么回调机制是如何设计的呢？<br>这里我们统一设计了一套回调机制。Unity 和 Android 均使用这套机制。以 Unity 部分举例，在需要传递回调的时候。会有一个回调的处理器来创建回调，创建之后将回调缓存起来，并为一个回调生成一个ID。这个ID和回调绑定。然后将此回调ID添加到 Command 对象 callbackId 字段上后发送。<br>附加 callbackId 的指令示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;TipService.dialog&quot;,</span><br><span class=\"line\">\t&quot;callback&quot;: false,</span><br><span class=\"line\">\t&quot;args&quot;: [&quot;&#123;\\&quot;name\\&quot;:\\&quot;message\\&quot;,\\&quot;value\\&quot;:\\&quot;Hello Unity and Android.\\&quot;&#125;&quot;],</span><br><span class=\"line\">\t&quot;callbackId&quot;: &quot;8710a212ffac41b5910462937ed62059&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Android 在接收到这个 Command 后执行异步操作。在需要回调的时候发送一条专用于回调指令通知对方。回调指令的 Command.callback 会置为 true。name 为 回调的 ID，示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;baf6b37f562e45b9b0ad7da4f00c91f8&quot;,</span><br><span class=\"line\">\t&quot;callback&quot;: true,</span><br><span class=\"line\">\t&quot;args&quot;: [&quot;&#123;\\&quot;name\\&quot;:\\&quot;isOK\\&quot;,\\&quot;value\\&quot;:true&#125;&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Unity 在收到回调指令后会交给回调处理器处理，根据name 找到对应的ID，取出回调，并将参数传递过去，调用回调。这样就形成了回调的闭环。同时，这样的设计是支持回调嵌套的（回调中调用回调）。</p>\n<blockquote>\n<p>注：这样的回调方式不支持一次传递多个回调，多回调的场景，可以单个回调传递多个参数，以参数来区分。</p>\n</blockquote>\n<h3 id=\"2-3-可移植性\"><a href=\"#2-3-可移植性\" class=\"headerlink\" title=\"2.3 可移植性\"></a>2.3 可移植性</h3><p>可移植性对桥接层来说同样很重要，我们需要考虑后续接入到其他应用中的情况。这里的可移植性主要针对 Android 的桥接部分。<br>首先，桥接层单独成一个模块。且尽可能的少依赖第三方库。所以我在这里的设计，仅引入了GSON作为序列化的工具库。以及将 Unity 提供的 jar 包作为编译时依赖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">compileOnly files(&#x27;libs/unity-classes.jar&#x27;)</span><br></pre></td></tr></table></figure>\n<p>其次，桥接层需要下沉到项目架构的最底部。不依赖任何其他业务模块。也就代表他需要和你的业务逻辑解耦合，提供的服务以接口注册的方式来处理和分发。<br>所以桥接层提供了服务的基类，注册接口和实例的相关功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 注册提供Unity方法的Service实例</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param service service实例</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void registerInstance(IUnityService service) &#123;</span><br><span class=\"line\">        BridgeServiceManager.INSTANCE.register(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 注册服务接口</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param serviceClass</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void register(Class&lt;? extends IUnityService&gt; serviceClass) &#123;</span><br><span class=\"line\">        BridgeServiceManager.INSTANCE.addInterface(serviceClass);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>有了注册的方式，上层业务模块就可以将自己的服务实现放到业务层，使用之前注册就可以。</p>\n<h3 id=\"2-4-接入便捷性\"><a href=\"#2-4-接入便捷性\" class=\"headerlink\" title=\"2.4 接入便捷性\"></a>2.4 接入便捷性</h3><p>接入便捷性主要考虑的方便业务层使用。所以对业务层注册进来的接口和实例，我采用的是注解处理 + 反射的方式进行调用。使得接入方在接口仅关心定义，实现类里仅关心实现。设计方式有点参考 Spring Controller 和 Retrofit Service。<br>举例：服务接口的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@UnityBridgeService(&quot;ToastService&quot;)</span><br><span class=\"line\">interface UnityToastService  : IUnityService &#123;</span><br><span class=\"line\">    @UnityBridgeMethod(name = &quot;show&quot;)</span><br><span class=\"line\">    fun showToast(@Param(&quot;msg&quot;) msg: String, @Param(&quot;time&quot;) time: Long)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>举例：接口实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UnityToastServiceImpl : UnityToastService &#123;</span><br><span class=\"line\">    override fun showToast(msg: String, time: Long) &#123;</span><br><span class=\"line\">        QtToast.show(msg, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">UnityBridge.register(UnityToastService::class.java)</span><br><span class=\"line\">UnityBridge.registerInstance(UnityToastServiceImpl())</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：在接入便捷性上，可以考虑开发 Gradle 插件来实现服务接口和实现的自动注入。</p>\n</blockquote>\n<h3 id=\"2-5-可拓展性\"><a href=\"#2-5-可拓展性\" class=\"headerlink\" title=\"2.5 可拓展性\"></a>2.5 可拓展性</h3><p>可拓展性和可移植性做的工作是相差不大的。在前面的设计基础上，已经满足了桥接层服务的可拓展性。</p>\n<h2 id=\"三、如何实现\"><a href=\"#三、如何实现\" class=\"headerlink\" title=\"三、如何实现\"></a>三、如何实现</h2><p>这一节主要挑选一些实现时涉及主流程、难点的一些实现来举例说明。的</p>\n<h3 id=\"3-1-桥接入口\"><a href=\"#3-1-桥接入口\" class=\"headerlink\" title=\"3.1 桥接入口\"></a>3.1 桥接入口</h3><p>桥接入口我定义了一个统一入口，也就是 Unity 的调用全部从一个方法进入，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Unity调用入口方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param command 指令序列化json</span><br><span class=\"line\">     * @return 返回值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static String onUnityCall(String command) &#123;</span><br><span class=\"line\">        Result result;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            LogUtils.INSTANCE.i(&quot;Received command:&quot; + command);</span><br><span class=\"line\">            Object obj = CommandManager.INSTANCE.onCommandReceived(command);</span><br><span class=\"line\">            result = ResultUtils.INSTANCE.getSuccessResult(obj);</span><br><span class=\"line\">        &#125; catch (Throwable thr) &#123;</span><br><span class=\"line\">            result = ResultUtils.INSTANCE.getErrorResult(thr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Warehouse.INSTANCE.getGson().toJson(result);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：由于 Unity 调用 Android 是通过底层反射，不支持Kotlin代码，所以入口的类需要使用 Java 编写。</p>\n</blockquote>\n<h3 id=\"3-2-Command-处理流程\"><a href=\"#3-2-Command-处理流程\" class=\"headerlink\" title=\"3.2 Command 处理流程\"></a>3.2 Command 处理流程</h3><p>Command（指令） 的处理从入口调用后，会经过以下几步处理：</p>\n<ol>\n<li>反序列化</li>\n<li>检查指令信息是否合法</li>\n<li>检查本地是否提供该指令的处理服务。</li>\n<li>判断是否为回调指令</li>\n<li>执行指令</li>\n</ol>\n<p>以上流程代码较为简单，我定义了 <code>CommandManager</code> 来做以上的事情。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">            command = Warehouse.gson.fromJson(commandJson, Command::class.java)</span><br><span class=\"line\">        &#125; catch (e: Throwable) &#123;</span><br><span class=\"line\">            throw UnityBridgeRuntimeException(&quot;Gson serialized error.Please check command json correctly or not. - $&#123;e.message&#125;&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        checkCommandAvailable(command)</span><br><span class=\"line\">        return if (CallbackController.commandIsCallback(command)) &#123;</span><br><span class=\"line\">            CallbackController.executeCallback(command)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            CommandController.executeCommand(command)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-回调控制\"><a href=\"#3-3-回调控制\" class=\"headerlink\" title=\"3.3 回调控制\"></a>3.3 回调控制</h3><p>如果业务层提供的方法需要回调，我提供了一个回调的基类和实现来方便使用。<br>回调接口如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface ICallbackHandler :</span><br><span class=\"line\">    IMethodChainInvoke&lt;ICallbackHandler&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 清除参数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    fun clearParams()</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 调用回调</span><br><span class=\"line\">     */</span><br><span class=\"line\">    fun call()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要提供回调的服务接口举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@UnityBridgeService(&quot;MessageService&quot;)</span><br><span class=\"line\">interface UnityMessageService : IUnityService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @UnityBridgeMethod(name = &quot;registerSingleMessageListener&quot;)</span><br><span class=\"line\">    fun registerMessageListener(@Param(&quot;cmd&quot;) messageCmd: Int, callbackHandler: ICallbackHandler): String</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在执行 Command 时，会反射调用，反射调用就会判断如果参数列表中包含 ICallbackHandler 就会去实例化一个回调处理的辅助类传递下去。<br>回调处理的辅助类定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">internal class CallbackHandler(var id: String) : ICallbackHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 参数map</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private var params: MutableMap&lt;String, Any?&gt; = ConcurrentHashMap()</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回调中的回调对象（用于回调中需要回调的场景）</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private var callback: AbsCallback? = null</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun clearParams() &#123;</span><br><span class=\"line\">        params.clear()</span><br><span class=\"line\">        callback = null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun putParam(name: String, value: Any?): CallbackHandler &#123;</span><br><span class=\"line\">        params[name] = value</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun setCallback(callback: AbsCallback): CallbackHandler &#123;</span><br><span class=\"line\">        this.callback = callback</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun call() &#123;</span><br><span class=\"line\">        CallbackController.sendCallbackCommand(id, params, callback)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：上方代码中 AbsCallback 相关的代码是用于 Unity 回调 Android 的场景。其他代码是 Android 回调 Unity 的场景。所以如果理解困难时，AbsCallback 相关代码可以去掉。</p>\n</blockquote>\n<h3 id=\"3-4-反射调用\"><a href=\"#3-4-反射调用\" class=\"headerlink\" title=\"3.4 反射调用\"></a>3.4 反射调用</h3><p>反射调用是这套设计的核心之一了，反射本身代码没有太多的难点。只是有几点需要注意：</p>\n<ol>\n<li>Kotlin 基础数据类型 Gson 反序列化不支持。</li>\n<li>由于需要获取 <code>@Param</code> 注解的值与指令对象的参数做映射，所以序列化需要经过2次，第一次根据名字映射，获取到参数的类型，第二次再根据参数类型反序列化具体的值。</li>\n</ol>\n<p>处理 Kotlin 基础数据类型的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun kotlinClassConvert(clazz: Class&lt;*&gt;): Class&lt;*&gt; &#123;</span><br><span class=\"line\">        when (clazz) &#123;</span><br><span class=\"line\">            Int::class.java -&gt;</span><br><span class=\"line\">                return Integer::class.java</span><br><span class=\"line\">            Boolean::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Boolean::class.java</span><br><span class=\"line\">            Float::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Float::class.java</span><br><span class=\"line\">            Double::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Double::class.java</span><br><span class=\"line\">            Byte::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Byte::class.java</span><br><span class=\"line\">            Char::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Character::class.java</span><br><span class=\"line\">            Short::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Short::class.java</span><br><span class=\"line\">            Long::class.java -&gt;</span><br><span class=\"line\">                return java.lang.Long::class.java</span><br><span class=\"line\">            else -&gt;</span><br><span class=\"line\">                return clazz</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>两次反序列化处理调用参数代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private fun &lt;T : Any?&gt; findCommandParam(</span><br><span class=\"line\">        command: Command,</span><br><span class=\"line\">        paramName: String,</span><br><span class=\"line\">        paramType: Class&lt;T&gt;</span><br><span class=\"line\">    ): CommandParam&lt;T&gt; &#123;</span><br><span class=\"line\">        command.args.forEach &#123;</span><br><span class=\"line\">            val commandParamName = Warehouse.gson.fromJson(it, CommandParamName::class.java)</span><br><span class=\"line\">            if (commandParamName.name == paramName) &#123;</span><br><span class=\"line\">                //构造带泛型的反序列化type</span><br><span class=\"line\">                val type = TypeToken.getParameterized(CommandParam::class.java, paramType).type</span><br><span class=\"line\">                return Warehouse.gson.fromJson(it, type)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return CommandParam(paramName, null)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>反射调用代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private fun reflectInvoke(command: Command, method: Method, instance: Any): Any? &#123;</span><br><span class=\"line\">        val args = Array&lt;Any?&gt;(method.parameterTypes.size) &#123; null &#125;</span><br><span class=\"line\">        val commandArgs = 1</span><br><span class=\"line\">        CommandUtils.getMethodParamsName(method).forEachIndexed &#123; index, paramName -&gt;</span><br><span class=\"line\">            val typeClass = CommandUtils.kotlinClassConvert(method.parameterTypes[index])</span><br><span class=\"line\">            if (typeClass == ICallbackHandler::class.java) &#123;</span><br><span class=\"line\">                //方法的参数类型是回调类型 并且command中带有回调的ID，则创建一个handler</span><br><span class=\"line\">                if (CallbackController.commandHasCallback(command)) &#123;</span><br><span class=\"line\">                    args[index] = CallbackHandler(command.callbackId!!)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                val commandParam = findCommandParam(command, paramName, typeClass)</span><br><span class=\"line\">                args[index] = commandParam.value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return method.invoke(instance, *args)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"四、关于开源\"><a href=\"#四、关于开源\" class=\"headerlink\" title=\"四、关于开源\"></a>四、关于开源</h2><p>目前我没有考虑开源桥接层的模块，因为在我们的项目中，桥接层的应用还没有得到复杂场景的检验，稳定性无法保证得很好。在后需桥接层迭代成熟后，再考虑开源。</p>\n","categories":["Android"],"tags":["Android","Unity","桥接"]},{"title":"关于","url":"/about/index.html","content":"<p>你好，我是 Jcr。<br>欢迎来到「关于」一栏。来到这里，一定是想了解我吧。<br>我是一名 <del>Android</del> 全栈程序员，在重庆工作。技术上主攻 <del>Android</del> <del>前端</del> <del>后端</del> 前端方向，同时也对其他端保持着兴趣和学习的状态。也可以称我为全栈\b\b（干）工程师。<br>生活上，平时喜欢玩玩游戏，看看书，打打乒乓球啥的，也比较喜欢折腾点有的没的东西。<br>如果你想要联系我，可以通过下方联系方式噢~<br>QQ：610691723<br>Email：<a href=\"mailto:&#105;&#64;&#x6a;&#99;&#114;&#46;&#x70;&#x75;&#x62;\">&#105;&#64;&#x6a;&#99;&#114;&#46;&#x70;&#x75;&#x62;</a></p>\n<hr>\n<p>其他应用：<br>Jcr’s Warehouse : <a href=\"http://explorer.jcr.pub/\">http://explorer.jcr.pub/</a></p>\n<hr>\n<p>思考，是我们不断进步的根本，共勉。</p>\n"},{"title":"categories","url":"/categories/index.html","content":""},{"title":"友情链接","url":"/links/index.html","content":"<p>@ClanceyHuang : <a href=\"http://debug.cool/\">http://debug.cool/</a><br>@Leesir : <a href=\"https://www.jianshu.com/u/b8adc2044cde\">https://www.jianshu.com/u/b8adc2044cde</a></p>\n"},{"title":"tags","url":"/tags/index.html","content":""}]